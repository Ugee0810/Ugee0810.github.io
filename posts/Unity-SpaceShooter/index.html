<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="위키북스 절대강좌! 유니티 책 따라가기" /><meta property="og:locale" content="en" /><meta name="description" content="Rearning to C# / Unity 21.3.x" /><meta property="og:description" content="Rearning to C# / Unity 21.3.x" /><link rel="canonical" href="https://ugee0810.github.io//posts/Unity-SpaceShooter/" /><meta property="og:url" content="https://ugee0810.github.io//posts/Unity-SpaceShooter/" /><meta property="og:site_name" content="Ugee’s Tech Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-03T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="위키북스 절대강좌! 유니티 책 따라가기" /><meta name="twitter:site" content="@" /><meta name="google-site-verification" content="Ml2iJIkJ2zZDMNrcGMlCnS-Xedu1IYdjNWQKCAUzZKM" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-06T18:53:14+09:00","datePublished":"2022-09-03T00:00:00+09:00","description":"Rearning to C# / Unity 21.3.x","headline":"위키북스 절대강좌! 유니티 책 따라가기","mainEntityOfPage":{"@type":"WebPage","@id":"https://ugee0810.github.io//posts/Unity-SpaceShooter/"},"url":"https://ugee0810.github.io//posts/Unity-SpaceShooter/"}</script><title>위키북스 절대강좌! 유니티 책 따라가기 | Ugee's Tech Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Ugee's Tech Blog"><meta name="application-name" content="Ugee's Tech Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/profile.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Ugee's Tech Blog</a></div><div class="site-subtitle font-italic">Rearning to C# / Unity 21.3.x</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Ugee0810" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['shu990810','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>위키북스 절대강좌! 유니티 책 따라가기</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>위키북스 절대강좌! 유니티 책 따라가기</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1662130800" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 3, 2022 </em> </span> <span> Updated <em class="" data-ts="1662457994" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 6, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/Ugee0810">송환욱(Song HwanUK)</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="17825 words"> <em>99 min</em> read</span></div></div></div><div class="post-content"><hr /><p><img data-src="https://user-images.githubusercontent.com/85896566/188261890-7183879c-3e2a-4e5e-968d-57762a68f64a.png" alt="image" data-proofer-ignore></p><h1 id="-01장--유니티-엔진의-소개생략">※ 01장 : 유니티 엔진의 소개(생략)</h1><p><br /></p><hr /><h1 id="-02장--게임-개발-준비">※ 02장 : 게임 개발 준비</h1><h2 id="이-책에서-개발할-게임-소개-및-개발-순서"><span class="mr-2">이 책에서 개발할 게임 소개 및 개발 순서</span><a href="#이-책에서-개발할-게임-소개-및-개발-순서" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 책을 통해 개발할 게임은 3인칭 시점 슈팅(TPS, Third Person Shooting) 게임이다.</p><p>개발 순서</p><ol><li>게임 개발 환경 설정<li>게임에서 사용할 리소스 내려받기 및 설치<li>게임의 배경이 되는 스테이지 제작<li>주인공의 이동 및 공격 기능 구현<li>적 캐릭터 생성 및 추적 기능 구현<li>주인공과 적 캐릭터 간의 공격 및 피격 기능 구현<li>게임 매니저 및 오브젝트 풀링 구현</ol><h2 id="프로젝트-생성"><span class="mr-2">프로젝트 생성</span><a href="#프로젝트-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>유니티 허브</p><ul><li>새 프로젝트 생성 : 3D / SpaceShooter<li>기존 프로젝트 관리<li>유니티 라이센스 등록</ul><p>유니티 버전</p><ul><li>Unity 2021.3.9f1(LTS)</ul><h2 id="유니티-에디터의-환경설정"><span class="mr-2">유니티 에디터의 환경설정</span><a href="#유니티-에디터의-환경설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="레이아웃"><span class="mr-2">레이아웃</span><a href="#레이아웃" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/85896566/188261465-37a8c1c0-7a0b-40ef-b0c6-3e4e7f5b8d37.png" alt="image" data-proofer-ignore></p><p>내가 사용하는 커스텀이다.</p><p>프로젝트와 하이러키, 인스펙터 이동 동선이 가까워서 좋다.</p><h3 id="프로젝트-뷰의-칼럼"><span class="mr-2">프로젝트 뷰의 칼럼</span><a href="#프로젝트-뷰의-칼럼" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/85896566/188261570-0866032f-f0e5-4a3e-bb9b-e9b8815d5c45.png" alt="image" data-proofer-ignore></p><p>보통 ‘One Column Layout’를 사용한다.</p><p>Sprite나 Metarial 등을 볼 땐 ‘Two Column Layout’이 편했다.</p><h2 id="프로젝트-뷰의-체계적인-관리"><span class="mr-2">프로젝트 뷰의 체계적인 관리</span><a href="#프로젝트-뷰의-체계적인-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>프로젝트 뷰는 게임 개발에 사용하는 모든 리소스가 저장되는 곳이므로, 개발을 진행할수록 많은 리소스가 쌓이므로 혼란이 생긴다. 그러므로 처음부터 체계적으로 관리하는 게 중요하다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188261764-c890fb5e-f716-4f08-b1bc-e1200d18b1cc.png" alt="image" data-proofer-ignore></p><h2 id="캐릭터-모델-임포트하기"><span class="mr-2">캐릭터 모델 임포트하기</span><a href="#캐릭터-모델-임포트하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 책에선 MADFINGER Games - ShadowGun:Deadzone 게임의 에셋을 사용한다.</p><ul><li><a href="https://github.com/indieGameMaker/UnityBook">깃허브 저장소에서 내려받기</a></ul><h3 id="유니티-패키지를-통한-리소스-설치"><span class="mr-2">유니티 패키지를 통한 리소스 설치</span><a href="#유니티-패키지를-통한-리소스-설치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/85896566/188262072-98dac32d-7b10-4b91-9717-11b141d944df.png" alt="image" data-proofer-ignore></p><p>프로젝트 뷰에 드래그 &amp; 드랍으로 패키지를 임포트한다.</p><h2 id="asset-store"><span class="mr-2">Asset Store</span><a href="#asset-store" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>에셋 스토어는 다양한 리소스를 사고팔 수 있는 오픈마켓이다.</p><p>※ 라이센스를 주의하며 설치할 것</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188262160-22845a88-aed5-47ca-aa6b-ffea6b9f7810.png" alt="image" data-proofer-ignore></p><h3 id="무료-리소스-내려받기"><span class="mr-2">무료 리소스 내려받기</span><a href="#무료-리소스-내려받기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>설치 목록</p><ul><li>Yughues Free Metal Materials<li>Skybox Volume 2 (Nebula)<li>Barrel</ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188262190-c06a8d52-9a8c-4714-9068-34401e848f95.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188262271-4fb6d3b6-1069-47e0-8a8f-e42cdb727602.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188262305-f60fe45a-a698-4a0f-ac74-36671a14abf7.png" alt="image" data-proofer-ignore></p><p>이후 패키지 매니저에서 내려 받기</p><h2 id="정리"><span class="mr-2">정리</span><a href="#정리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>프로젝트 폴더 설정<li>사용할 리소스 설치</ul><p>게임 개발에 필요한 여러 가지 에셋을 설치했다.</p><p>유니티의 장점 중 하나인 에셋 스토어에서는 많은 무료 에셋을 제공한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188262620-aded7a34-65fb-4290-82d6-f14f830c6b27.png" alt="image" data-proofer-ignore></p><p><br /></p><hr /><h1 id="-03장--게임-스테이지-제작">※ 03장 : 게임 스테이지 제작</h1><h2 id="바닥-생성-및-배치"><span class="mr-2">바닥 생성 및 배치</span><a href="#바닥-생성-및-배치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>게임의 배경이 도는 스테이지를 제작할 때 먼저 작업하는 것 중 하나가 바로 바닥인 Floor다.</p><p>보통 유니티에서 제공하는 원시 모델(Primitive Model) 중 Plane 또는 Cube를 사용한다.</p><p>트랜스폼 스케일 값 1단위는 1m로 디자인 되어있다.</p><p>※ 오브젝트를 생성하면 항상 포지션 값을 확인 후 리셋하는 습관을 기른다.</p><p>아래의 설정을 하면 자동으로 월드 좌표 원점으로 설정해준다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188262916-49434042-7d39-404a-bca5-644fefa5feeb.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188263017-67cda7ef-4090-4c13-9bdf-dfa70790ad78.png" alt="image" data-proofer-ignore></p><h2 id="texture텍스처"><span class="mr-2">Texture(텍스처)</span><a href="#texture텍스처" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>텍스처(Texture)란 3D 모델의 표면에 매핑시킬 이미지 파일을 지칭한다.</p><p>텍스처의 크기는 가로 세로가 2ⁿ(예: 256x256, 1024x1024) 형태일 때 압축을 지원하며, 속도가 가장 빠르다.</p><p>특히 모바일 플랫폼에서 속도를 향상시키고 싶다면 반드시 2ⁿ(POT, Power Of Two) 형태의 텍스처를 사용해야 한다.</p><h3 id="텍스처의-해상도-조절"><span class="mr-2">텍스처의 해상도 조절</span><a href="#텍스처의-해상도-조절" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/85896566/188291697-887b7984-075d-4ac0-8f0f-bb5dcb948d5f.png" alt="image" data-proofer-ignore></p><ul><li>해상도를 줄일 수록 용량이 크게 줄어든다.<li>프로젝트를 진행할 때 대상 플랫폼을 명확히 설정하고 임포트한 텍스처의 품질을 어떻게 관리할 것인지 미리 결정해야 한다.<li>따라서 프로젝트 진행 중 임포트한 텍스처는 바로 적절한 품질로 설정하는 작업을 병행해야 최적화 작업이 수월하다.</ul><h2 id="material머티리얼"><span class="mr-2">Material(머티리얼)</span><a href="#material머티리얼" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>3D 모델에 텍스처를 적용하려면 3D 모델과 텍스처 사이에 반드시 Metarial이 필요하다.</p><p>머티리얼은 3D 모델에 적용할 텍스처의 다양한 속성을 설정하는 역할을 한다.</p><p>즉, “어떤 텍스처를, 어떤 간격으로 반복하고, 표면의 재질은 어떻게 표현하느냐” 등의 속성을 설정한다.</p><h3 id="머티리얼의-자동-적용"><span class="mr-2">머티리얼의 자동 적용</span><a href="#머티리얼의-자동-적용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>※ 객체에 텍스처를 적용하는 방법은 두 가지가 있다.</p><p>1.드래그 &amp; 드랍</p><ul><li>적용 시 자동으로 “Matarials” 폴더 생성</ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188292237-015ab30f-6784-45dc-9c9f-8e6288de1760.png" alt="image" data-proofer-ignore></p><ul><li>텍스처와 머티리얼이 여러 폴더에 산재<li>텍스처가 어떤 절차를 걸쳐서 메시에 연결되는지 명확히 알아야하므로 초보자에겐 권장하지 않음</ul><h3 id="머티리얼-생성"><span class="mr-2">머티리얼 생성</span><a href="#머티리얼-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>2.텍스처 슬롯 바로 옆에 있는 브라우저 버튼을 클릭해 직접 선택</p><ul><li>“Matarials” 폴더를 만들고, 아래의 절차대로 머티리얼을 생성한다.</ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188292281-ad2bfd11-8aea-45b2-9120-01f7d81ec296.png" alt="image" data-proofer-ignore></p><ul><li>머티리얼의 작명 방법은 개발자들마다 다른데, “m”, “mt”와 같은 Prefix나 Postfix를 붙이기도 한다.</ul><h3 id="albedo-normal-map-적용"><span class="mr-2">Albedo, Normal Map 적용</span><a href="#albedo-normal-map-적용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>드래그 &amp; 드랍 또는 브라우저 버튼을 클릭하여 Albedo와 Normal Map에 연결해준다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188292384-ec7cdf33-e35c-4ed5-abd0-c57dfc7718e5.png" alt="image" data-proofer-ignore></p><p>브라우저 버튼 왼쪽 네모 칸을 Ctrl+Click 하면 프리뷰를 볼 수 있다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188292427-e01e9b36-c631-4686-abf4-b01c0f253b46.png" alt="image" data-proofer-ignore></p><h3 id="머티리얼-적용-방법"><span class="mr-2">머티리얼 적용 방법</span><a href="#머티리얼-적용-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>※ 완성된 머티리얼을 적용하는 방법 또한 두 가지가 있다.</p><ul><li>하이러키의 객체나, 씬 뷰에 배치된 객체에게 오브젝트 뷰에서 드래그 &amp; 드랍<li>적용할 객체를 선택한 후 인스펙터에서 Matarials 속성에 드래그 &amp; 드랍</ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188292505-a404abea-382a-492e-9b97-71846e98390a.png" alt="image" data-proofer-ignore></p><h4 id="tip---mesh-filter-mesh-renderer-component"><span class="mr-2">TIP - Mesh Filter, Mesh Renderer Component</span><a href="#tip---mesh-filter-mesh-renderer-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>애니메이션이 적용되지 않은 3D 모델은 반드시 메쉬 필터와 메쉬 렌더러 컴포넌트가 있다.</p><p>Mesh Filter</p><ul><li>해당 모델의 3차원 형상 정보인 메시 데이터를 가지고 있다.</ul><p>Mesh Renderer</p><ul><li>Mesh Filter의 메시 데이터를 기반으로 화면에 렌더링을 처리한다.</ul><p>또한 유니티에서 제공하는 “~ Renderer” 계열의 컴포넌트는 반드시 Materials 속성이 있다.</p><p>이는 텍스처 정보를 가진 머티리얼을 연결하는 속성임을 의미한다.</p><h3 id="타일링-속성"><span class="mr-2">타일링 속성</span><a href="#타일링-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>머티리얼의 기능 가운데 텍스처를 욕실의 타일처럼 반복시키는 기능이 있다.</p><p>인스펙터 뷰에 Tiling 속성의 X, Y값의 n당 n번 패턴 반복화 한다는 것이다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188292619-d0800ebf-31bd-4c2b-bbd6-ae4f7b8c082a.png" alt="image" data-proofer-ignore></p><h4 id="tip---main-maps-secondary-maps"><span class="mr-2">TIP - Main Maps, Secondary Maps</span><a href="#tip---main-maps-secondary-maps" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Secondary Maps 섹션의 속성값을 변경 했다가 변화가 없다고 혼동하지 않도록 유의.</p><p>Secondary Maps 섹션은 3D 모델의 특정 부분을 좀 더 세밀하게 표현하기 위한 텍스처를 적용하는 영역이다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188292645-331aafa8-a153-4411-9844-5ea236d943b0.png" alt="image" data-proofer-ignore></p><h3 id="프리뷰의-다양한-기능"><span class="mr-2">프리뷰의 다양한 기능</span><a href="#프리뷰의-다양한-기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/85896566/188292708-5df2f833-3b66-47f9-80d6-f3fc0db1b25a.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188292780-7b02de90-f796-4e33-b492-8936e2b8c366.png" alt="image" data-proofer-ignore></p><ul><li>확대, 최소화 가능<li>구체 뿐만 아니라 다양한 물체로 적용된 모습을 볼 수 있다.<li>광원의 유/무에 따른 모습<li>3점(케밥 메뉴)에선 별도의 윈도우 창으로 분리해 볼 수 있다.</ul><h2 id="shader셰이더-및-pbs물리-기반-셰이딩"><span class="mr-2">Shader(셰이더) 및 PBS(물리 기반 셰이딩)</span><a href="#shader셰이더-및-pbs물리-기반-셰이딩" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>셰이더는 렌더링할 때 픽셀의 농담, 색조, 명암을 결정하는 프로그래밍 방식을 말한다.</p><p>쉽게 표현하면, 화면에 텍스처를 표현할 때 재질감 또는 효과를 표현하는 기능이다.</p><p>셰이더 프로그래밍은 DirectX, OpenGL에 따라 서로 다른 언어로 구현되고 3D 그래픽스의 이론적인 배경을 많이 알아야 할 정도로 깊이 있는 지식을 요구하는 분야이다.</p><p>유니티는 셰이더 프로그래밍 지식이나 경험이 없더라도 내장 셰이더(Built in Shader)를 제공해줘 손쉽게 사용할 수 있다.</p><p>2017년 부터 공개된 물리 기반 셰이딩(PBS, Physically-Based Shading)은 물체가 가진 고유의 특성에 맞게 재질을 표현하는 것으로, 현실세계에 존재하는 돌, 나무, 유리, 플라스틱, 금속 등과 같은 재질감을 하난의 셰이더에서 표현할 수 있게 설계돼 있다.</p><ul><li><p>Metallic Value Charts <img data-src="https://user-images.githubusercontent.com/85896566/188292824-2d081fd5-1b22-486e-891e-089ba859efc7.png" alt="image" data-proofer-ignore></p><li><p>Specular Value Charts <img data-src="https://user-images.githubusercontent.com/85896566/188292826-ee8fe37b-657c-451b-b9e7-2136987a459b.png" alt="image" data-proofer-ignore></p></ul><p>유니티의 Standard Shader의 몇 가지 중요한 Matarial Parameters는 다음과 같다.</p><h3 id="렌더링-모드"><span class="mr-2">렌더링 모드</span><a href="#렌더링-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/85896566/188293024-217d63fd-f45b-42ac-8620-59d75a9520c2.png" alt="image" data-proofer-ignore></p><div class="table-wrapper"><table><thead><tr><th>Rendering Mode 옵션<th>설명<tbody><tr><td>Opaque(불투명)<td>기본값으로 불투명한 텍스처를 표현하는 옵션이다. 투명한 부분이 전혀 없는 Solid 객체에 적합하다.<tr><td>Cutout(그물망 표현)<td>불투명한 부분과 투명한 부분을 동시에 표현하는 옵션이다. 주로 풀, 그물망 등을 표현할 떄 적합하다.<tr><td>Fade(홀로그램 효과)<td>투명 속성값을 가진 객체를 페이드 아웃시키는 옵션으로, 페이드 인/아웃을 애니메이션 처리할 수 있다. 불투명한 객체를 부분적으로 페이드 아웃시킬 수 있어 홀로그램 효과를 구현할 수 있다.<tr><td>Transparent(투명)<td>투명한 플라스틱 또는 유리와 같은 재질을 표현하는 옵션이다.</table></div><h3 id="albedo알베도"><span class="mr-2">Albedo(알베도)</span><a href="#albedo알베도" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Albedo는 빛을 반사하는 정도를 말하며, 반사율이라고도 한다.</p><p>일반적으로 가장 기본이 되는 텍스처를 연결하는 속성이다.</p><h3 id="metallic메탈릭"><span class="mr-2">Metallic(메탈릭)</span><a href="#metallic메탈릭" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Metallic은 객체 표면에 금속의 재질을 표현하기 위한 텍스처다.</p><p>슬라이드가 1에 가까워질수록 금속 재질에 가까워진다.</p><h3 id="normal-map노멀-맵"><span class="mr-2">Normal Map(노멀 맵)</span><a href="#normal-map노멀-맵" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Normal Map은 표면의 세밀한 입체감이나 질감을 표현하기 위한 텍스처의 일종으로 3D 모델링으로 많은 Polygon을 소모하지 않고 같은 효과를 낼 수 있다. 수치가 커질수록 거친 음영효과를 낸다.</p><h3 id="height-map하이트-맵"><span class="mr-2">Height Map(하이트 맵)</span><a href="#height-map하이트-맵" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Height Map은 텍스처로 높낮이를 표현하는 것으로, 노멀 맵과 비슷한 기능을 하지만, 좀 더 돌출시켜 뒤에 있는 사물을 가리는 Occlusion 효과를 낼 수 있다. 슬라이더로 돌출되는 높이를 설정할 수 있다.</p><h3 id="occlusion오클루전"><span class="mr-2">Occlusion(오클루전)</span><a href="#occlusion오클루전" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Occlusion은 흑백의 텍스처로 간접조명에 의해 생기는 명암을 더욱 뚜렷이 표시해 사물의 입체감과 깊이감을 살리는 데 사용한다. Occlusion에 사용할 텍스처는 일반적으로 3D 모델링 툴 또는 서드파티 툴에서 추출한다.</p><h3 id="emission이미션"><span class="mr-2">Emission(이미션)</span><a href="#emission이미션" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Emission은 스스로 빛을 방출하는 속성을 말한다. 속성값을 변경하면 객체의 표면에서 방출되는 빛의 강도와 빛의 색상을 설정할 수 있는 항목이 나타난다. 또한 하단에 전역 조명에 반영하기 위한 옵션이 나타난다.</p><h3 id="detail-mask디테일-마스크"><span class="mr-2">Detail Mask(디테일 마스크)</span><a href="#detail-mask디테일-마스크" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Detail Mask는 Secondary Maps에 적용할 마스크를 설정하는 텍스처 슬롯이다. 특정 부분만 좀 더 세부적인 텍스처를 표현할 때 사용한다.</p><h4 id="info---standard-shader-세부-정보"><span class="mr-2">Info - Standard Shader 세부 정보</span><a href="#info---standard-shader-세부-정보" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>유니티의 Standard Shader에 대한 세부 정보는 Unity Documents에서 볼 수 있다.</p><ul><li><a href="https://docs.unity3d.com/kr/current/Manual/shader-StandardShader.html">Unity Documents</a></ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188293296-4733085e-90b3-4bd2-b43e-d83e0e4fb071.png" alt="image" data-proofer-ignore></p><h2 id="prefab프리팹"><span class="mr-2">Prefab(프리팹)</span><a href="#prefab프리팹" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Prefab의 사전적 의미는 조립식 주택 또는 미리 부품을 만들어 놓고 현장에서는 조립만 하는 건축 기법을 의미한다. 유니티에선 자주 사용하는 객체를 미리 부품처럼 만들어 놓고 재사용할 수 있게 하는 것이다.</p><p>프리팹을 복제해서 만든 Clone 객체의 속성은 원본과 일치한다. 따라서 원본 프리팹을 수정하면 그 Clone에게도 수정 사항이 일괄적으로 적용되는 특성이 있다.</p><p>100개의 Clone들을 일일이 수정해줄 필요 없이 원본만 수정하면 되는 강력한 기능이다.</p><h3 id="nested-prefab-중첩-프리팹"><span class="mr-2">Nested Prefab, 중첩 프리팹</span><a href="#nested-prefab-중첩-프리팹" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Unity 2018.3 버전부터 지원하기 시작한 Nested Prefab 기능은 프리팹 하위에 다른 프리팹을 추가할 수 있는 기능이다.</p><ul><li>프리팹 하위에 프리팹을 추가할 수 있기 때문에 개발 효율성을 높인다.<li>OOP 개념의 상속이 가능하다. 다른 프리팹을 상속받아 다양한 기능을 추가할 수 있다.<li>프리팹 모드 기능으로 프리팹만 수정할 수 있는 별도의 인터페이스를 제공한다.</ul><h3 id="벽-만들기"><span class="mr-2">벽 만들기</span><a href="#벽-만들기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Floor 객체의 네 군데 모서리에 배치할 벽을 프리팹으로 만들어 배치하자.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188293706-ac749403-5a7b-4e09-a74e-9f2f64b82452.png" alt="image" data-proofer-ignore></p><p>머티리얼도 생성한다.</p><h4 id="tip---모바일-최적화-셰이더"><span class="mr-2">TIP - 모바일 최적화 셰이더</span><a href="#tip---모바일-최적화-셰이더" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>자동으로 설정되는 Standard 셰이더는 고품질을 내기 위한 셰이더이기에 모바일 플랫폼에서는 무겁다.</p><p>따라서 좀 더 가벼운 “Bumped Diffuse”를 선택해 셰이더를 수정한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188293761-e9359ab9-ccb9-4aac-8c24-b886b71fb0d5.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188293787-719bf82e-971a-4e7d-b928-b4ae073d0514.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188293821-9905b3f9-0323-4680-98b3-5aa4b7247063.png" alt="image" data-proofer-ignore></p><p>아직까진 음영이나 표면의 흠집 같은 세밀함이 표현되지 않는다.</p><p>Floor처럼 노멀 맵도 적용해보자.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188293853-a130964a-62f3-42e5-8329-8b8392a128ac.png" alt="image" data-proofer-ignore></p><p>지금 이 셰이더에선 스페큘러 속성(빛을 반사하는 속성)이 표현되지 않기 때문에 금속 재질을 표현하지 못하는 것은 아쉬운 부분이다.</p><p>Legacy Shader/Bumped Specular로 변경해서 Main Color, Specular Color, Shininess 등의 속성을 수정해 재질감을 표현해보자.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188293924-21ccb24a-3988-4272-b113-d35ef7402a7e.png" alt="image" data-proofer-ignore></p><h3 id="프리팹-생성"><span class="mr-2">프리팹 생성</span><a href="#프리팹-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>하이러키 뷰에서 프로젝트 뷰로 드래그 &amp; 드롭하면 같은 이름으로 프리팹이 생성된다.</p><p>만약 프리팹 원본이 삭제되어 인스턴스가 끊어진 경우 Clone 객체들은 붉은색 이름으로 바뀌는데, 이 땐 [Prefab] -&gt; [Unpack Completely]를 선택한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188294006-54014407-8611-4d5e-8947-86d2921004cd.png" alt="image" data-proofer-ignore></p><h3 id="프리팹의-복제-및-네이밍"><span class="mr-2">프리팹의 복제 및 네이밍</span><a href="#프리팹의-복제-및-네이밍" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>객체 복사는 복사할 객체를 지정하고 Ctrl + D를 누르면 넘버링이 붙으며 복제된다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188294087-785aedd3-c03c-446a-b25d-5b26285daff6.png" alt="image" data-proofer-ignore></p><h4 id="tip---복제-네이밍-형식-변경"><span class="mr-2">TIP - 복제 네이밍 형식 변경</span><a href="#tip---복제-네이밍-형식-변경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>네이밍 형식은 [Project Settings] -&gt; [Editor]의 “Numbering Scheme”의 “Game Object Naming”을 변경한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188294101-75c58b80-1f50-4e61-aa2e-13a150aeab29.png" alt="image" data-proofer-ignore></p><h3 id="snapping스내핑-기능"><span class="mr-2">Snapping(스내핑) 기능</span><a href="#snapping스내핑-기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>객체가 객체에 붙이기 쉽도록 표면 스내핑(Surface Snapping)과 정점 스내핑(Vertex Snapping) 기능을 제공한다.</p><p>사용하려면 Move Tool(W)을 선택해야 한다.</p><ul><li>Vertex Snapping<ul><li>메시의 꼭짓점과 꼭짓점을 붙이는 기능<li>먼저 객체간 거리를 벌려준다.</ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188294201-1ba8f2bb-222f-4dd6-87c3-4dc51d363234.png" alt="image" data-proofer-ignore></p><ul><li>꼭짓점으로 커서를 옮긴 후 (V)키를 누른 상태로 드래그 &amp; 드롭으로 이동 후 객체간 스내핑이 완료되면 (V)키를 릴리스한다.</ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188294249-0475728f-3b94-49d7-b8eb-057555644548.png" alt="image" data-proofer-ignore></p></ul><p>나머지 벽도 완료된 모습</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188294303-ffaddf34-8369-48cd-ad01-76a5e0fbee6b.png" alt="image" data-proofer-ignore></p><h2 id="light조명"><span class="mr-2">Light(조명)</span><a href="#light조명" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>게임의 분위기와 완성도가 완전히 달라질 수도 있을 만큼 중요한 요소이다. 설치할수록 시각적인 효과는 커지지만, 조명을 처리하기 위한 렌더링 부하는 늘어날 수 밖에 없다. 따라서 최소한의 조명으로 시각적인 효과와 게임 수행 속도 사이의 균형을 맞추는 데 항상 신경 써야 한다.</p><p>유니티는 게임의 속도를 저하하지 않고 실시간 조명의 효과를 낼 수 있는 라이트매핑 및 라이트 프로브 기능을 제공한다. 그 내용은 본문 11장에 있다.</p><p>유니티가 제공하는 조명은 크게 네 가지가 있다.</p><h3 id="directional-light"><span class="mr-2">Directional Light</span><a href="#directional-light" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/85896566/188294439-d741311c-b089-43cf-b48f-9c4a7636e118.png" alt="image" data-proofer-ignore></p><ul><li>전체 화면에 균일한 빛을 비춘다. (태양과 같은 조명)<li>위치는 어디에 있든 관계 없지만(보통 y는 100) 빛을 비추는 각도에 따라 그림자의 방향과 길이가 달라진다.<li>실시간 조명 중에서 가장 비용이 적게 드는 조명이다.</ul><h3 id="point-light"><span class="mr-2">Point Light</span><a href="#point-light" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/85896566/188294453-31e0394c-9f44-48aa-8e41-d701ac04d330.png" alt="image" data-proofer-ignore></p><ul><li>일반 전구와 같은 성격(위치한 좌표 기준 360˚)<li>전역 조명이 아니므로 Range 속성으로 범위 조절</ul><h3 id="spot-light"><span class="mr-2">Spot Light</span><a href="#spot-light" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/85896566/188294493-3cde1b63-5812-4e1d-bfcc-d4f01a090566.png" alt="image" data-proofer-ignore></p><ul><li>Corn 모양의 조명(손전등)<li>실시간 처리 비용이 가장 비싸다.<li>빛이 뻗어 나가는 각도를 조절할 수 있는 Spot Angle 속성이 있다.</ul><h3 id="area-light"><span class="mr-2">Area Light</span><a href="#area-light" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/85896566/188294870-ea52e9b1-b559-4ae4-a13f-2de2edd55543.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188294884-38c568d3-6b9f-42b8-b430-3e53648b7aa4.png" alt="image" data-proofer-ignore></p><ul><li>사각형, 원 형태의 조명으로, 한쪽 면에서 빛을 발하는 조명<li>Lighting View에서 라이트맵을 Bake해야만 확인할 수 있다. 따라서 유일하게 실시간 조명이 아니다.<li>주로 간접 조명으로 이용</ul><h2 id="실시간-라이트매핑-기능"><span class="mr-2">실시간 라이트매핑 기능</span><a href="#실시간-라이트매핑-기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>유니티는 백그라운드로 라이트맵을 베이킹할 수 있는 기능을 제공한다. 개발 중에 조명의 효과를 볼 수 있어 반복적인 작업에 매우 편리하다.</p><h3 id="lighting-setting-에셋"><span class="mr-2">Lighting Setting 에셋</span><a href="#lighting-setting-에셋" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>먼저 라이팅 뷰에서 해당 씬의 조명 속성을 저장하는 Lighting Settings 에셋을 생성해야 한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188294929-516416fe-d85d-4826-9333-71a9c24d1c66.png" alt="image" data-proofer-ignore></p><p>보관은 Scene 폴더에서 하는 게 적절하다.</p><h3 id="auto-generate-옵션"><span class="mr-2">Auto Generate 옵션</span><a href="#auto-generate-옵션" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>라이팅 뷰의 아래에 있는 [Auto Generate] 옵션을 체크하면 실시간 라이트맵을 베이크한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188294951-7bc080a7-943c-4385-8ef3-696a8cf3223a.png" alt="image" data-proofer-ignore></p><p>정식적인 내용은 11장에서…</p><h2 id="하늘-표현-방식"><span class="mr-2">하늘 표현 방식</span><a href="#하늘-표현-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>게임에서 하늘을 표현하는 대표적인 방식으로는 Skybox와 SkyDome이 있다.</p><ul><li>Skybox<ul><li>카메라가 볼 수 있는 하늘의 여섯 방면(left, front, right, back, top, bottom)의 이미지를 Cube 형태로 배치해 표현한다.</ul><li>Skydome<ul><li>돔 형태이 메시에 하늘의 이미지 텍스처를 입혀 구현한다.</ul></ul><h3 id="6-sided-skybox6방면-스카이박스"><span class="mr-2">6 sided skybox(6방면 스카이박스)</span><a href="#6-sided-skybox6방면-스카이박스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>먼저 머티리얼을 생성하고, 셰이더의 콤보 박스에서 [Skybox] -&gt; [6sided]를 선택한다. 이후에 준비한 텍스처들을 연결한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188295083-b7b8f124-1118-4580-b1eb-fe764f08f108.png" alt="image" data-proofer-ignore></p><h3 id="스카이박스-적용"><span class="mr-2">스카이박스 적용</span><a href="#스카이박스-적용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>완성된 Skybox 머티리얼을 라이팅 뷰의 Environment 탭에서 Skybox Material 속성에 드래그 &amp; 드랍한다. 또는 단순히 씬 뷰의 빈 공간에 드래그 &amp; 드랍해도 된다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188295111-a0bbf8f2-1fd7-4d90-86e9-3bf3b0bd4162.png" alt="image" data-proofer-ignore></p><h3 id="procedural-skybox프로시저럴-스카이박스"><span class="mr-2">Procedural Skybox(프로시저럴 스카이박스)</span><a href="#procedural-skybox프로시저럴-스카이박스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>텍스처를 적용하지 않고 하늘의 색상, 대기 농도, 노출(밝기), 태양의 위치와 크기 등을 설정 가능<li>유니티 프로젝트를 처음 열었을 때 이 스카이박스가 적용되어 있다.<li>Default-Skybox는 여러가지 설정값을 변경할 수 없으므로 별도의 머티리얼로 만들어야 함</ul><p>머티리얼 적용 방법은 아까와 같이 셰이더 콤보 박스에서 [Procedural]을 선택한다.</p><p>아래의 표는 프로시저럴 스카이박스의 속성별 기능이다.</p><div class="table-wrapper"><table><thead><tr><th>속성<th>설명<tbody><tr><td>Sun<td>None : 태양 이미지를 표시하지 않음<br />Simple : 태양 주변에 헤일로(Halo) 처리를 하지 않음<br />High Quality : 태양 주변에 헤일로 처리<tr><td>Sun Size<td>태양 이미지 크기 조절<tr><td>Sun Size Convergence<td>태양 주변의 퍼지는 빛의 범위를 조절 (High Quality일 때만 표시됨)<tr><td>Almosphere Thickness<td>대기 농도 : 청명하거나 탁한 정도를 조절<tr><td>Sky Tint<td>하늘 색상 조절<tr><td>Ground<td>대지 색상 조절<tr><td>Exposure<td>노출 조절</table></div><p><img data-src="https://user-images.githubusercontent.com/85896566/188295365-d571e7c2-d65d-40f3-a464-e388f401a442.png" alt="image" data-proofer-ignore></p><p>태양 위치를 변경하는 부분은 라이팅 뷰의 Environment 탭에서 Sun Source 속성에 기본 생성된 Directional light의 위치와 각도를 변경하면 된다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188295459-32d85af5-41f0-415d-a99a-d046667e90f2.png" alt="image" data-proofer-ignore></p><h3 id="cubemap-skybox큐브맵-스카이박스"><span class="mr-2">Cubemap Skybox(큐브맵 스카이박스)</span><a href="#cubemap-skybox큐브맵-스카이박스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>이 방식은 먼저 큐브맵을 생성한 후 하늘을 표현한다. 큐브맵은 6 sided skybox와 마찬가지로 6장의 텍스처가 필요하며 주변 환경을 반사하는 효과에 주로 사용한다.</p><p>이 스카이박스를 적용하려면 여섯 방면의 이미지가 한 장의 텍스처에 있어야 하며, Texture Type을 Cubemap으로 설정해야 한다.</p><p>다만 한 장의 텍스처에 여섯 방면의 이미지를 합칠 때는 다음과 같은 세 가지 방식으로 작업해야 한다.</p><div class="table-wrapper"><table><thead><tr><th>매핑 타입<th>이미지 형태<tbody><tr><td>6 Frame Layout(Cube Environment)<td>여섯 방면의 이미지를 평면으로 배치<tr><td>Latitude-Longitude(Cylindrical)<td>파노라마 이미지로 실린더 형태의 이미지<tr><td>Mirrored Ball(Spheremap)<td>구체(Sphere) 이미지</table></div><h4 id="tip---큐브맵-정보"><span class="mr-2">TIP - 큐브맵 정보</span><a href="#tip---큐브맵-정보" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>큐브맵 생성에 관한 자세한 내용은 다음 페이지를 참조한다.</p><ul><li><a href="https://docs.unity3d.com/Manual/class-Cubemap.html">Unity Documents</a></ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188295724-4b4759c0-2b5b-455f-81a7-573ff0d1874d.png" alt="image" data-proofer-ignore></p><h4 id="info---여섯-방면-스카이박스의-drawcall드로우콜-소모량"><span class="mr-2">Info - 여섯 방면 스카이박스의 DrawCall(드로우콜) 소모량</span><a href="#info---여섯-방면-스카이박스의-drawcall드로우콜-소모량" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>6 sided skybox는 6개의 텍스처를 사용하므로 기본적으로 6 드로우콜을 소모하지만, 큐브맵 스카이박스와 프로시저럴 스카이박스는 1 드로우콜만 소모하므로 좋은 대안이 될 수 있다. 또한 Sky Dome 역시 1장의 텍스처를 사용할 경우 1 드로우콜만 소모하므로 드로우콜을 낮출 수 있다는 장점이 있다.</p><p>하지만 게임의 특성에 따라 카메라가 볼 수 있는 최대거리(Far clipping Plane)를 제한해야 할 때는 Sky Dome 방식을 적용하는 것은 적합하지 않을 수 있다.</p><h2 id="정리-1"><span class="mr-2">정리</span><a href="#정리-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>스테이지 디자인<li>스카이박스 적용</ul><p>이번 장에서는 게임의 무대가 되는 스테이지를 제작했다.</p><p><br /></p><hr /><h1 id="-04장--주인공-캐릭터-제작">※ 04장 : 주인공 캐릭터 제작</h1><h2 id="3d-모델-불러오기"><span class="mr-2">3D 모델 불러오기</span><a href="#3d-모델-불러오기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>3D 모델을 씬 뷰 또는 하이러키 뷰로 드래그 &amp; 드랍하여 배치</p><p>Transfrom의 Position값이 원점(0, 0, 0)인지 확인할 것</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188297777-86d0b117-d4de-4da9-a807-6809be21297d.png" alt="image" data-proofer-ignore></p><h2 id="유니티-엔진의-개발-방식"><span class="mr-2">유니티 엔진의 개발 방식</span><a href="#유니티-엔진의-개발-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>유니티는 2가지 개발 방식을 지원한다.</p><ul><li>컴포넌트 기반의 개발(CBD, Component Based Development)<li>데이터 기반의 개발(DOTS, Data Oriented Technology Stack)<ul><li>멀티스레드 기반<li>초보자가 접하기에는 어렵다.<li>개발 중인 기능이 많아 안정화 버전이 나올 때까지는 상용으로 사용하기에 위험부담이 크다.</ul></ul><h3 id="컴포넌트-기반의-개발-방식"><span class="mr-2">컴포넌트 기반의 개발 방식</span><a href="#컴포넌트-기반의-개발-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>CBD 방식은 일종의 소프트웨어 개발 방법론으로, 독립적인 기능 단위로 컴포넌트를 제작한 다음 필요한 기능을 조립하는 방식을 말한다.</p><p>이 개발 방식의 장점은 컴포넌트의 재사용이 가능하고 높은 생산성이다.</p><p>컴포넌트는 인스펙터 뷰에서 확인할 수 있다.</p><p>그 중에서 어느 객체라도 Transform 컴포넌트는 유일하게 삭제할 수 없다.</p><p>트랜스폼 컨포넌트는 해당 게임오브젝트의 3차원 위치, 각 축에 대한 각도 및 스케일 속성을 가진다. 따라서 3차원 공간에서 어떤 객체가 존재하려면 이러한 정보가 반드시 있어야 하므로 삭제할 수 없는 컴포넌트이다.</p><h2 id="c-스크립트"><span class="mr-2">C# 스크립트</span><a href="#c-스크립트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>유니티의 엔진의 코어 부분은 C++로 제작됐고 초기 버전에서는 자바스크립트 문법을 차용한 UnityScript를 지원했지만, 2017년 부터 C# 언어만 지원한다.</p><p>C#은 C++, 자바 언어의 장점을 차용한 Managed Language(메모리 자동 연산 언어)로써 국내외를 막론하고 많이 사용되는 인기 있는 언어이다.</p><p>고급 문법은 이 책에선 다루지 않는 거 같다.</p><h3 id="스크립트-코드-에디터"><span class="mr-2">스크립트 코드 에디터</span><a href="#스크립트-코드-에디터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>나는 주로 Visual Studio 2022를 개발 도구로 사용한다.</p><p>블로그 포스팅은 마크다운 프리뷰어 익스텐션을 사용하기 위해 VSCode를 사용한다.</p><h3 id="추천하는-코드-에디터"><span class="mr-2">추천하는 코드 에디터</span><a href="#추천하는-코드-에디터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>VS20xx, VSCode, JetBrains Rider 등을 유니티 개발에 추천하고 있다.</p><h3 id="코드-에디터-변경"><span class="mr-2">코드 에디터 변경</span><a href="#코드-에디터-변경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Preferences의 [External Tools] 섹션의 External Script Editor에서 서드파티 에디터를 선택한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188298218-246be729-5668-47dc-8823-c87af080bd85.png" alt="image" data-proofer-ignore></p><p>만약 VSCode를 스크립트 에디터로 사용한다면 코드 자동완성 기능을 사용하기 위해 C# 확장 패키지를 설치해야 한다.</p><ul><li><a href="https://code.visualstudio.com/docs/other/unity">바로가기</a></ul><h3 id="c-스크립트-생성"><span class="mr-2">C# 스크립트 생성</span><a href="#c-스크립트-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>프로젝트 뷰 우클릭 [Create] -&gt; [C# Script] 선택</p><p>스크립트 네임은 클래스명이 된다.</p><p>프로젝트 뷰의 스크립트 파일 이름을 변경하면 클래스명은 수동으로 변경해주어야 컴파일 에러가 나지 않는다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188548878-6e37fdfa-95bd-4ecb-868a-9636e63ee827.png" alt="image" data-proofer-ignore></p><h3 id="유니티의-주요-이벤트-함수p122"><span class="mr-2">유니티의 주요 이벤트 함수(P.122)</span><a href="#유니티의-주요-이벤트-함수p122" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>유니티의 생명주기(Life Cycle)에 대한 내용은 본 블로그의 다른 게시물에 정리되어 있다.</p><ul><li><a href="https://ugee99.github.io/posts/Unity-LifeCycle/">바로가기</a></ul><h3 id="이벤트-함수의-호출-순서"><span class="mr-2">이벤트 함수의 호출 순서</span><a href="#이벤트-함수의-호출-순서" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre>    <span class="k">private</span> <span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 주로 게임의 상태 값, 변수의 초기화에 사용</span>
        <span class="c1">// 가장 처음 1회 실행</span>
        <span class="c1">// 스크립트가 비활성화돼 있어도 실행된다.</span>
        <span class="c1">// Coroutine으로 실행 불가능</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Awake() -&gt; OnEnable() -&gt; Start()</span>
        <span class="c1">// Update함수 호출 전에 호출</span>
        <span class="c1">// Coroutine으로 실행 가능</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 프레임마다 호출</span>
        <span class="c1">// 호출 간격이 불규칙적임</span>
        <span class="c1">// 화면의 렌더링 주기와 일치</span>
        <span class="c1">// 주로 게임의 핵심 로직을 작성</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">LateUpdate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Update 함수가 종료된 후 호출</span>
        <span class="c1">// 모든 Update()가 호출되고 나서 한 번씩 호출</span>
        <span class="c1">// 주로 Update()에서 전처리가 끝난 후 실행해야 하는 로직에 사용</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">FixedUpdate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 일정한 간격으로 호출(Default 0.02/s)</span>
        <span class="c1">// 물리 엔진의 계산 주기와 일치</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnEnable</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 게임 오브젝트 또는 스크립트가 Enable될 때마다 호출</span>
        <span class="c1">// 주로 사용자 정의 이벤트 연결에 사용</span>
        <span class="c1">// Coroutine으로 실행 불가능</span>
    <span class="p">}</span>
    
    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDisable</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 게임 오브젝트 또는 스크립트가 Disable될 때 호출</span>
        <span class="c1">// 주로 이벤트 연결을 종료할 때 사용</span>
        <span class="c1">// Coroutine으로 실행 불가능</span>
    <span class="p">}</span>
</pre></table></code></div></div><h2 id="키보드-입력값-받아들이기"><span class="mr-2">키보드 입력값 받아들이기</span><a href="#키보드-입력값-받아들이기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>유니티에서 제공하는 Input Class는 외부(키보드, 마우스, 조이패드 등)에서 들어오는 입력값을 관리하는 클래스다. InputSystem의 내용은 14장에서 따로 다룬다.</p><h3 id="inputmanager"><span class="mr-2">InputManager</span><a href="#inputmanager" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/85896566/188550882-7e4b6a8a-80f3-489d-825c-b792c4475899.png" alt="image" data-proofer-ignore></p><p>키본적으로 정의되어 있는 내용도 있고, 추가도 가능하다.</p><h3 id="getaxis"><span class="mr-2">GetAxis()</span><a href="#getaxis" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>미리 설정한 키 조합의 반환값 가져오는 함수.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">h</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span> <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>
        <span class="kt">float</span> <span class="n">v</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>   <span class="c1">// -1.0f ~ 0.0f ~ +1.0f </span>

        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"h : "</span> <span class="p">+</span> <span class="n">h</span><span class="p">);</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"v : "</span> <span class="p">+</span> <span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
</pre></table></code></div></div><p><img data-src="https://user-images.githubusercontent.com/85896566/188551483-3303abd6-baa4-4d1e-b441-2329bf659627.png" alt="image" data-proofer-ignore></p><h3 id="스크립트-적용-방식"><span class="mr-2">스크립트 적용 방식</span><a href="#스크립트-적용-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Scene View에 적용할 객체에게 스크립트를 드래그 &amp; 드랍<li>하이러키 뷰의 적용할 객체에게 스크립트를 드래그 &amp; 드랍<li>적용할 객체의 인스펙터 뷰에 스크립트를 드래그 &amp; 드랍(권장)<li>적용할 객체의 인스펙터 뷰에서 Add Component로 스크립트 검색</ul><h4 id="tip---잘못-추가된-에셋을-찾는-방법"><span class="mr-2">TIP - 잘못 추가된 에셋을 찾는 방법</span><a href="#tip---잘못-추가된-에셋을-찾는-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><img data-src="https://user-images.githubusercontent.com/85896566/188551938-5e9f8a02-3b51-4ca4-8b5e-83d1ef5a894f.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188551969-9497974f-190c-4586-8d80-564955b34a6a.png" alt="image" data-proofer-ignore></p><p>스크립트 뿐만 아니라 모든 에셋(머티리얼, 프리팹, 리소스 등)도 이와 같은 방법으로 조회 가능하다.</p><h4 id="info---input에-정의되지-않은-축-이름을-사용했을-때-발생하는-오류"><span class="mr-2">Info - Input에 정의되지 않은 축 이름을 사용했을 때 발생하는 오류</span><a href="#info---input에-정의되지-않은-축-이름을-사용했을-때-발생하는-오류" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><img data-src="https://user-images.githubusercontent.com/85896566/188552232-9e13a7d6-a365-4594-ae97-080d0df640dc.png" alt="image" data-proofer-ignore></p><p>스크립트에서 InputManager에 정의된 키 값의 이름을 문자열로 받게 되면 컴파일 에러가 발생하지 않는다.</p><p>따라서 이와 같은 에러가 발생하면 대/소문자, 띄어쓰기 등을 확인할 것.</p><h3 id="getaxisraw"><span class="mr-2">GetAxisRaw()</span><a href="#getaxisraw" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Input.GetAxis(“Horizontal”)는 -1.0f ~ +1.0f 사이의 연속적인 값을 반환한다. 따라서 부드러운 이동이 필요할 때는 GetAxis()를 사용한다. 하지만 키보드 입력값에 따라 방향을 즉시 바꾸거나 속도를 변경해야할 땐Input.GetAxisRaw(“Horizontal”)를 사용해야 한다. GetAxisRaw는 불연속적인(이산, Discrete) -1.0f, 0.0f, +1.0f의 세 가지 값만 변환한다.</p><h2 id="캐릭터의-이동"><span class="mr-2">캐릭터의 이동</span><a href="#캐릭터의-이동" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>유니티에서 어떤 물체를 이동시키거나 회전시키는 방법은 2가지로 분류할 수 있다.</p><ul><li>모든 게임오브젝트에 있는 Transform Component의 Position, Rotation 속성값을 변경하는 것<li>유니티 엔진에 내장된 물리 엔진을 이용해 물리적인 힘(Force) 또는 회전력(Torque)를 가해 변경시키는 것</ul><p>쉽게 말해</p><ul><li>Tranform Component를 이용<li>물리 엔진(PhysX, Box2D)을 사용</ul><p>애니메이션으로도 이동 및 회전을 할 수 있다. 하지만 이것 역시 Transform Component의 속성값을 연속적으로 기록한 것을 재생하는 것이기 때문에 Transform Component를 이용하는 방법이다.</p><p>아래의 코드는 Player - ‘이동 로직 추가’이다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">PlayerCtrl</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">h</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span> <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>
        <span class="kt">float</span> <span class="n">v</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>   <span class="c1">// -1.0f ~ 0.0f ~ +1.0f </span>

        <span class="c1">// Transform Component Position 속성값 변경</span>
        <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>누적 대입 연산자로 인해 프레임마다 z축만 +1되는 코드이다.</p><h3 id="vector3-구조체"><span class="mr-2">Vector3 구조체</span><a href="#vector3-구조체" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>유니티에서 3차원 좌표에 대한 개념을 익히려면 Vector3 구조체에 대해 알아야 한다. 이는 3차원 벡터와 좌푯값을 저장하기 위한 용도로 사용되며, 다음 코드는 Vector3 구조체의 일부분이다. 3차원 x, y, z 값이 float로 선언된 것과 방향을 지시하는 약칭(Shorthand)를 볼 수 있다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">struct</span> <span class="nc">Vector3</span> <span class="p">:</span> <span class="n">IEquatable</span><span class="p">&lt;</span><span class="n">Vector3</span><span class="p">&gt;,</span> <span class="n">IFormattable</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">kEpsilon</span> <span class="p">=</span> <span class="m">1E-05f</span><span class="p">;</span>

        <span class="k">public</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">kEpsilonNormalSqrt</span> <span class="p">=</span> <span class="m">1E-15f</span><span class="p">;</span>

        <span class="c1">//</span>
        <span class="c1">// 요약:</span>
        <span class="c1">//     X component of the vector.</span>
        <span class="k">public</span> <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>

        <span class="c1">//</span>
        <span class="c1">// 요약:</span>
        <span class="c1">//     Y component of the vector.</span>
        <span class="k">public</span> <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>

        <span class="c1">//</span>
        <span class="c1">// 요약:</span>
        <span class="c1">//     Z component of the vector.</span>
        <span class="k">public</span> <span class="kt">float</span> <span class="n">z</span><span class="p">;</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Vector3</span> <span class="n">zeroVector</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Vector3</span> <span class="n">oneVector</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">1f</span><span class="p">,</span> <span class="m">1f</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Vector3</span> <span class="n">upVector</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Vector3</span> <span class="n">downVector</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="p">-</span><span class="m">1f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Vector3</span> <span class="n">leftVector</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(-</span><span class="m">1f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Vector3</span> <span class="n">rightVector</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">1f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Vector3</span> <span class="n">forwardVector</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">1f</span><span class="p">);</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Vector3</span> <span class="n">backVector</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="p">-</span><span class="m">1f</span><span class="p">);</span>
        <span class="p">[</span><span class="err">중략</span><span class="p">...]</span>
</pre></table></code></div></div><p>다음 표에 제시된 것은 Vector3 구조체의 여러 속성 중에서 자주 사용되는 속성이다.</p><div class="table-wrapper"><table><thead><tr><th>속성<th>설명<tbody><tr><td>magnitude<td>벡터의 길이(read only)<tr><td>normalized<td>크기가 1인 벡터, 정규화 벡터(read only)<tr><td>sqrMagnitude<td>벡터의 길이의 제곱(read only)<tr><td>x<td>벡터의 x 성분(3차원 공간의 x 좌표<tr><td>y<td>벡터의 y 성분(3차원 공간의 y 좌표<tr><td>z<td>벡터의 z 성분(3차원 공간의 z 좌표</table></div><h3 id="normalized-vector정규화-벡터"><span class="mr-2">Normalized Vector(정규화 벡터)</span><a href="#normalized-vector정규화-벡터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Vector는 크기와 방향을 나타낼 수 있는 데이터 타입으로, 그 중 각 축의 크기가 1인 벡터를 정규화 벡터(Normalized Vector)라 한다. 즉, 방향만 표시하는 벡터라고 생각하면 된다.</p><p>Vector3 구조체에서 제공하는 방향을 가리키는 정규화 벡터는 다음과 같다.</p><div class="table-wrapper"><table><thead><tr><th>Shorthand<th>의미<tbody><tr><td>Vector3.forward<td>Vector3(0, 0, 1)<tr><td>Vector3.back<td>Vector3(0, 0, -1)<tr><td>Vector3.left<td>Vector3(-1, 0, 0)<tr><td>Vector3.right<td>Vector3(1, 0, 0)<tr><td>Vector3.up<td>Vector3(0, 1, 0)<tr><td>Vector3.down<td>Vector3(0, -1, 0)<tr><td>Vector3.one<td>Vector3(1, 1, 1)<tr><td>Vector3.zero<td>Vector3(0, 0, 0)</table></div><p><img data-src="https://user-images.githubusercontent.com/85896566/188555682-09b0c0b8-c8f6-48eb-986d-8342b5b6fcff.png" alt="image" data-proofer-ignore></p><p>유니티는 왼손 좌표계를 사용한다.</p><p>따라서 Vector3.forward가 z축 +1이라는 것을 이해할 수 있다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">h</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span> <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>
        <span class="kt">float</span> <span class="n">v</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>   <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>
                                               
        <span class="c1">// 정규화 벡터를 사용한 코드</span>
        <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+=</span> <span class="cm">/*전진 방향*/</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="cm">/*속력*/</span><span class="m">1</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><h3 id="컴포넌트-캐시-처리"><span class="mr-2">컴포넌트 캐시 처리</span><a href="#컴포넌트-캐시-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Update()의 사용엔 항상 최적화에 주의를 기울여야 한다. 조금이라도 부하가 걸리는 함수나 잘못된 로직은 피해야 한다. 특히 프레임마다 Transform Component에 접근하는 이동 방식은 바람직하지 않다.</p><p>앞서 Update()내에서 Transform Component의 멤버 변수 transform을 사용했는데, 이를 미리 변수에 담아 두고 해당 변수에 접근하는 방식이 미세하지만 빠르다. 따라서 컴포넌트의 캐시 처리란 스크립트에서 접근해야 할 컴포넌트를 Awake()나 Start()에서 미리 변수에 할당한 후에 그 변수를 통해 접근하는 것을 말한다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">PlayerCtrl</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="n">Transform</span> <span class="n">tr</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Transform Component를 추출해 변수에 대입</span>
        <span class="n">tr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="err">중략</span><span class="p">...]</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="info---getcomponent-함수의-사용법"><span class="mr-2">Info - GetComponent 함수의 사용법</span><a href="#info---getcomponent-함수의-사용법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">tr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
<span class="n">tr</span> <span class="p">=</span> <span class="nf">GetComponent</span><span class="p">(</span><span class="s">"Transform"</span><span class="p">)</span> <span class="k">as</span> <span class="n">Transform</span><span class="p">;</span>
<span class="n">tr</span> <span class="p">=</span> <span class="p">(</span><span class="n">Transform</span><span class="p">)</span><span class="nf">GetComponent</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Transform</span><span class="p">));</span>
</pre></table></code></div></div><p>위에 열거한 방법은 모두 같은 의미이다.</p><p>또, Start()에서 tr 변수에 할당하는 구문은 아래 코드를 축약한 것이다.</p><p>C#에서 this는 해당 클래스(스크립트)를 뜻함.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">tr</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">gameobject</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>

<span class="s">"이 스크립트가 포함된 게임 오브젝트가 가진 여러 컴포넌트 중에서 Transform 컴포넌트를 추출해 tr 변수에 저장한다."</span>
</pre></table></code></div></div><h3 id="translate"><span class="mr-2">Translate()</span><a href="#translate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>이 함수는 게임 오브젝트의 이동 처리를 편하게 할 수 있는 함수로서, 함수의 원형은 다음과 같다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">Translate</span><span class="p">(</span><span class="n">Vector3</span> <span class="n">direction</span><span class="p">,</span> <span class="p">[</span><span class="n">Space</span> <span class="n">relativeTo</span><span class="p">])</span>
</pre></table></code></div></div><p>이 함수로 Transform Component의 Position 속성값을 계산해 이동하는 복잡한 방식의 코딩을 예방할 수 있다.</p><p>Translate()의 두 번째 인자는 기준 좌표계인데, 인자를 생략하면 로컬 좌표를 기준으로 한다.</p><ul><li>Space.World(월드 좌표계)<li>Space.Self(로컬 좌표계)</ul><p>이 함수를 이용해 수정한 PlayerCtrl 스크립트는 다음과 같다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">PlayerCtrl</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">// 컴포넌트 캐시 처리할 변수</span>
    <span class="n">Transform</span> <span class="n">tr</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Transform Component를 추출해 변수에 대입</span>
        <span class="n">tr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">h</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span> <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>
        <span class="kt">float</span> <span class="n">v</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>   <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>

        <span class="c1">// Translate()를 이용한 이동 로직</span>
        <span class="n">tr</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="m">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="timedletatime"><span class="mr-2">Time.dletaTime</span><a href="#timedletatime" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Time.dletaTime은 이전 프레임의 시작 시각부터 현재 프레임이 시작되는 시간의 차(델타)를 말한다. 쉽게 풀이하면 이전 프레임부터 현재 프레임까지 걸린 시간의 차다.</p><p>Update()는 프레임에 따라 호출 되는데, 이 횟수가 기기의 성능마다 다르므로 속도가 달라지는 문제가 발생한다. 이 문제는 Time.dletaTime을 곱해주는 것으로 해결할 수 있다.</p><p>30프레임은 1/30초, 60프레임은 1/60초를 해주어 프레임 레이트가 서로 다른 기기에서도 개발자가 정한 일정한 속도로 이동시킬 수 있다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">tr</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span> <span class="p">*</span> <span class="m">1</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>Time.deltaTime을 곱하지 않으면 -&gt; 프레임당 지정한 유닛만큼 이동<li>Time.deltaTime을 곱하면 -&gt; 초당 지정한 유닛만큼 이동</ul><p>특히 Update()에 이동 및 회전 로직을 작성했다면 반드시 Time.deltaTime 속성을 사용해야 한다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">PlayerCtrl</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">// 컴포넌트 캐시 처리할 변수</span>
    <span class="n">Transform</span> <span class="n">tr</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">float</span> <span class="n">moveSpeed</span> <span class="p">=</span> <span class="m">10.0f</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Transform Component를 추출해 변수에 대입</span>
        <span class="n">tr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">h</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span> <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>
        <span class="kt">float</span> <span class="n">v</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>   <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>

        <span class="c1">// Translate()를 이용한 이동 로직</span>
           <span class="n">tr</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="n">v</span> <span class="p">*</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">moveSpeed</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span>
        <span class="c1">// tr.Translate({전진/후진 변수} * {이동할 방향} * {속도} * Time.deltaTime);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="public-private-접근-제한자"><span class="mr-2">public, private 접근 제한자</span><a href="#public-private-접근-제한자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>C#에서 지원하는 접근 제한자는 public, private, protected, internal이 있다. 접근 제한자는 외부 클래스(구조체), 멤버 변수 등의 접근을 허용하는 범위를 지정한다.</p><div class="table-wrapper"><table><thead><tr><th>접근 제한자<th>설명<tbody><tr><td>public<td>외부 클래스(외부 스크립트)에서 접근 가능<tr><td>private<td>동일 클래스(스크립트 內)에서만 접근 가능. 외부에서는 불가능<tr><td>protected<td>private과 동일하게 외부에선 접근이 불가능하고, 상속받은 파생 클래스에서만 접근 가능<tr><td>internal<td>같은 어셈블리에서만 접근 가능. 클래스의 경우 접근 제한자를 생략하면 internal이 기본값으로 설정됨</table></div><p>유니티에서 public으로 선언한 변수는 인스펙터 뷰의 프로퍼티로 노출돼 값을 직접 수정할 수 있다. 반대로 private 접근 제한자로 설정된 변수는 노출되지 않는다.</p><h3 id="인스펙터-뷰에-노출된-변수의-우선순위"><span class="mr-2">인스펙터 뷰에 노출된 변수의 우선순위</span><a href="#인스펙터-뷰에-노출된-변수의-우선순위" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>public으로 접근되는 변수의 변경은 인스펙터 뷰가 우선이다. 즉, 스크립트에선 10의 속도를 주었는데, 인스펙터 뷰에선 20으로 변경했을 때 게임에 적용되는 속도는 20으로 지정되어 있다.</p><h3 id="private-변수의-인스펙터-뷰-노출"><span class="mr-2">private 변수의 인스펙터 뷰 노출</span><a href="#private-변수의-인스펙터-뷰-노출" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>인스펙터 뷰의 모드를 디버그 모드로 설정하면 private 변숫값도 확인할 수 있다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188562761-eaa1b8b1-7ecf-49e3-8e7d-cdfd27930333.png" alt="image" data-proofer-ignore></p><p>또 다른 방법은 SerializeField 속성(Attribute)을 사용하는 것이다. 이 방법은 디버그 모드가 아니여도 private 접근 지시자의 속성을 유지한 채 인스펙터 뷰에 노출하는 기능이다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span> <span class="n">Transform</span> <span class="n">tr</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="벡터의-덧셈-연산"><span class="mr-2">벡터의 덧셈 연산</span><a href="#벡터의-덧셈-연산" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>이제 플레이어의 좌우 이동을 구현하기 위해 Vector3.right의 +, -값을 곱한다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">h</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span> <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>
        <span class="kt">float</span> <span class="n">v</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>   <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>

        <span class="c1">// 전후좌우 이동 방향 벡터 계산</span>
        <span class="n">Vector3</span> <span class="n">moveDir</span> <span class="p">=</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">+</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">h</span><span class="p">);</span>

        <span class="c1">// Translate(이동 방향 * 속력 * Time.deltaTime) 이동 로직</span>
        <span class="n">tr</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="n">moveDir</span> <span class="p">*</span> <span class="n">moveSpeed</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>플레이했을 때 대각선 이동은 빠른 감이 있었다. moveDir 변수는 Vector3 타입으로, 키보드 입력값을 이용해 벡터 연산을 했다. 전진 방향의 벡터와 좌우 방향의 벡터를 덧셈 연산하면 대각선 방향의 벡터가 생성된다. 이 대각선 벡터의 길이는 피타고라스의 정리ˇ에 의해 루트2(약 1.414・・・)임을 알 수 있다.</p><ul><li>피타고라스의 정리 <img data-src="https://user-images.githubusercontent.com/85896566/188564473-78ea0ee1-c225-49af-8880-6e96bd6b9f41.png" alt="image" data-proofer-ignore></ul><p>대각선으로 이동할 때 속도가 빨라진 원인이다. 따라서 길이가 1인 벡터로 변환해 방향 성분만 사용해야 한다. 이처럼 길이가 1인 벡터를 ‘단위 벡터’ 또는 ‘정규화 벡터(Normalized Vector)’라고 앞서 언급했다.</p><p>벡터의 방향 성분만 추출하기 위해 정규화 벡터로 변경하려면 Vector3.normalized 속성을 이용해 정규화 벡터값을 사용한다. 즉, Vector3 타입으로 선언한 moveDir 변수는 vormalized 속성을 이용할 수 있다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">PlayerCtrl</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="n">Transform</span> <span class="n">tr</span><span class="p">;</span> <span class="c1">// 컴포넌트 캐시 처리할 변수</span>

    <span class="k">public</span> <span class="kt">float</span> <span class="n">moveSpeed</span> <span class="p">=</span> <span class="m">8.0f</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">tr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span> <span class="c1">// Transform Component를 추출해 변수에 대입</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">h</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span> <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>
        <span class="kt">float</span> <span class="n">v</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>   <span class="c1">// -1.0f ~ 0.0f ~ +1.0f</span>
        <span class="n">Vector3</span> <span class="n">moveDir</span> <span class="p">=</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">+</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">h</span><span class="p">);</span> <span class="c1">// 전후좌우 이동 방향 벡터 계산</span>
        <span class="n">tr</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="n">moveDir</span><span class="p">.</span><span class="n">normalized</span> <span class="p">*</span> <span class="n">moveSpeed</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span> <span class="c1">// Translate(이동 방향 * 속력 * Time.deltaTime) 이동 로직</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="info---벡터의-크기와-정규화"><span class="mr-2">Info - 벡터의 크기와 정규화</span><a href="#info---벡터의-크기와-정규화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>벡터의 크기(magnitude)는 Vector3.magnitude 함수를 이용해 가져올 수 있다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">vec1</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="nf">Magnitude</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">vec2</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="nf">Magnitude</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">+</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">vec3</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="nf">Magnitude</span><span class="p">((</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">+</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span><span class="p">).</span><span class="n">normalized</span><span class="p">);</span>

        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"vec1 : "</span> <span class="p">+</span> <span class="n">vec1</span><span class="p">);</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"vec2 : "</span> <span class="p">+</span> <span class="n">vec2</span><span class="p">);</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"vec3 : "</span> <span class="p">+</span> <span class="n">vec3</span><span class="p">);</span>
    <span class="p">}</span>
</pre></table></code></div></div><p><img data-src="https://user-images.githubusercontent.com/85896566/188566506-10e63054-257c-4d3f-9960-b9e96fcf7074.png" alt="image" data-proofer-ignore></p><h2 id="캐릭터-회전---rotate"><span class="mr-2">캐릭터 회전 - Rotate</span><a href="#캐릭터-회전---rotate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>게임 오브젝트를 회전할 때는 Transform.rotation 속성값을 변경하거나 Rotate 계열의 함수를 사용할 수 있다. 가장 기초적인 Rotate()는 다음과 같은 다양한 인자를 사용할 수 있다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="p">-</span> <span class="k">void</span> <span class="nf">Rotate</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector3</span> <span class="n">eulerAngles</span><span class="p">,</span> <span class="p">[</span><span class="n">Space</span> <span class="n">relativeTo</span><span class="p">]);</span>
<span class="p">-</span> <span class="k">void</span> <span class="nf">Rotate</span><span class="p">(</span><span class="kt">float</span> <span class="n">xAngle</span><span class="p">,</span> <span class="kt">float</span> <span class="n">yAngle</span><span class="p">,</span> <span class="kt">float</span> <span class="n">zAngle</span><span class="p">,</span> <span class="p">[</span><span class="n">Space</span> <span class="n">relativeTo</span><span class="p">]);</span>
<span class="p">-</span> <span class="k">void</span> <span class="nf">Rotate</span><span class="p">(</span><span class="n">Vector3</span> <span class="n">axis</span><span class="p">,</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">,</span> <span class="p">[</span><span class="n">Space</span> <span class="n">relativeTo</span><span class="p">]);</span>
</pre></table></code></div></div><p>다음 코드는 Update()에서 Rotate()의 인자에 Y축에 Time.deltaTime을 곱해서 시계방향으로 회전하는 것을 볼 수 있다. Rotate()의 인자는 모두 다르지만 전부 같은 의미이다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">transform</span><span class="p">.</span><span class="nf">Rotate</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span>
  <span class="n">transform</span><span class="p">.</span><span class="nf">Rotate</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
  <span class="n">transform</span><span class="p">.</span><span class="nf">Rotate</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">up</span><span class="p">,</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>PlayerCtrl.cs</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">PlayerCtrl</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="n">Transform</span> <span class="n">tr</span><span class="p">;</span> <span class="c1">// 컴포넌트 캐시 처리할 변수</span>

    <span class="k">public</span> <span class="kt">float</span> <span class="n">moveSpeed</span> <span class="p">=</span> <span class="m">8.0f</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">turnSpeed</span> <span class="p">=</span> <span class="m">80.0f</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">tr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span> <span class="c1">// Transform Component를 추출해 변수에 대입</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">h</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">v</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">r</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Mouse X"</span><span class="p">);</span>

        <span class="n">Vector3</span> <span class="n">moveDir</span> <span class="p">=</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">+</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">h</span><span class="p">);</span> <span class="c1">// 전후좌우 이동 방향 벡터 계산</span>
        <span class="n">tr</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="n">moveDir</span><span class="p">.</span><span class="n">normalized</span> <span class="p">*</span> <span class="n">moveSpeed</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span> <span class="c1">// Translate(이동 방향 * 속력 * Time.deltaTime) 이동 로직</span>
        <span class="n">tr</span><span class="p">.</span><span class="nf">Rotate</span><span class="p">(</span><span class="n">r</span> <span class="p">*</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="n">turnSpeed</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span>        <span class="c1">// Vector3.up 축을 기준으로 turnSpeed만큼의 속도로 회전</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="씬-뷰에서-가상-카메라의-이동"><span class="mr-2">씬 뷰에서 가상 카메라의 이동</span><a href="#씬-뷰에서-가상-카메라의-이동" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>씬 뷰의 가상 카메라가 오브젝트를 추적하게 하려면</p><ol><li>하이러키 뷰에서 추적할 객체를 선택<li>Shift + F 또는 [Edit] -&gt; [Lock View to Selected]<li>플레이</ol><p><img data-src="https://user-images.githubusercontent.com/85896566/188568795-b3ee7e17-c0ed-4e09-b940-7af97299865c.png" alt="image" data-proofer-ignore></p><h2 id="animation"><span class="mr-2">Animation</span><a href="#animation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>유니티는 Legacy Animation과 Mecanim Animation이라는 두 가지 유형의 애니메이션을 지원한다.</p><ul><li>레거시 애니메이션 : 하위 호환성을 고려한 애니메이션, 소스 코드로 컨트롤해야 함<li>메카님 애니메이션 : 모션 캡처 애니메이션, 리타게팅ˇ 기능</ul><p>주인공 캐릭터는 레거시 애니메이션 타입으로 구현하고, 적 캐릭터는 메카님 애니메이션을 적용해보자.</p><ul><li>리타게팅(Retagetting) : 애니메이션을 재사용하는 기능을 말한다. 6장에서 자세히 소개</ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188572525-2b3f37f9-9f7e-40a3-b16b-02892430dd85.png" alt="image" data-proofer-ignore></p><div class="table-wrapper"><table><thead><tr><th>Animation Type 옵션<th>설명<tbody><tr><td>none<td>애니메이션을 사용하지 않는다.<tr><td>Legacy<td>하위 호환성을 유지하기 위한 이전 방식의 애니메이션<tr><td>Generic<td>메카님 애니메이션. 인체형 모델이 아닌 3D 모델에 적용. 리타게팅 불가<tr><td>Humanoid<td>메카님 애니메이션. 사람과 같이 2족 보행하는 모델에 적용. 리타게팅 가능</table></div><p>Player는 레거시 애니메이션을 사용하기로 했으니 Legacy로 변경해준다.</p><h4 id="info---메카님-애니메이션-권장"><span class="mr-2">Info - 메카님 애니메이션 권장</span><a href="#info---메카님-애니메이션-권장" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>레거시 애니메이션은 하위 호환성을 고려한 유형이기 때문에 유니티사는 특별한 경우가 아니면 메카님 애니메이션을 사용하길 권장함. 하짐나 빠른 속도와 간단한 애니메이션을 동작하는 데는 아직도 레거시 애니메이션이 유용하게 사용되고 있다. 또한, 개발자 포럼에서 레거시 애니메이션은 곧 지원 중단될 것으로 예측하는 개발자들이 있지만, 당분간은 계속 지원할 것으로 예상한다.</p><p>하이러키 뷰에 배치되어 있는 Player 객체의 인스펙터 뷰를 보면 Animation 컴포넌트가 추가돼 있다. 이 모델은 레거시 타입으로 설정된 모델을 의미한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188573896-27fcffc3-f238-4e9e-bbec-8135bebc13a5.png" alt="image" data-proofer-ignore></p><p>애니메이션 처리가 된 3D 모델을 씬 뷰에 추가했을 때 Animation Type에 따라 다음과 같이 서로 다른 컴포넌트가 자동으로 추가된다.</p><ul><li>레거시 애니메이션 : Animation Component<li>메카님 애니메이션 : Animator Component</ul><p>둘 다 애니메이션과 관련된 컴포넌트지만, 작동 방식이 전혀 다르다. 따라서 3D 모델에 추가된 컴포넌트의 종류를 보고 해당 모델의 애니메이션 유형이 무엇으로 설정됐는지 구별할 수 있어야 한다.</p><h3 id="animation-clip"><span class="mr-2">Animation Clip</span><a href="#animation-clip" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>애니메이션 클립 : 캐릭터의 걷기, 달리기, 점프, 총 쏘기와 같은 동작을 기록한 파일을 말한다. 그리고 애니메이션 컴포넌트는 애니메이션 클립에 기록된 관절의 위치와 회전 값을 프레임 단위로 재생시키는 역할을 한다.</p><p>3D 모델링 툴에서 제작한 애니메이션 클립을 애니메이션 파일로 만드는 방법에는 세 가지 방식이 있다.</p><ol><li>모든 애니메이션 클립이 하나의 애니메이션 파일에 들어 있고, 각 애니메이션 클립이 시작 프레임과 종료 프레임을 가지는 방식<li>위와 동일하게 모든 애니메이션 클립이 하나의 애니메이션 파일에 들어가 있지만, 미리 분리된 경우<li>애니메이션 클립을 동작별로 분리해 별도의 파일로 생성하는 방식. 이 때 생성된 애니메이션 클립의 파일명은 “모델명@애니메이션 클립명” 형태의 명명 규칙이 적용된다. 애니메이션 클립의 수가 많거나 애니메이션의 수정 작업이 빈번하게 일어날 것으로 예상한다면 이 방식으로 작업하는 것을 추천</ol><h3 id="애니메이션-적용"><span class="mr-2">애니메이션 적용</span><a href="#애니메이션-적용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>하이러키 뷰의 객체를 적용할 애니메이션 인스펙터 뷰 - 프리뷰에 드래그 &amp; 드랍<li>프로젝트 뷰의 원본 객체를 적용할 애니메이션 인스펙터 뷰 - 프리뷰에 드래그 &amp; 드랍</ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188576051-d4c495a3-18ba-43fd-b03a-c7fe737fe78d.png" alt="image" data-proofer-ignore></p><p>애니메이션 클립의 Wrap Mode 속성값 중 ‘Loop’로 설정한다.</p><ul><li>Loop : 클립의 첫 프레임부터 마지막 프레임까지 계속 반복</ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188576783-944f09ab-e790-4516-99cd-3ddff2c3f851.png" alt="image" data-proofer-ignore></p><p>애니메이션 컴포넌트 속성값</p><ul><li>Animation : 실행되면 처음 동작하는 애니메이션 클립을 연결<li>Animations[] : 해당 모델이 실행할 수 있는 클립들을 저장(즉, 여기 포함되어 있지 않은 클립은 실행 불가)<li>Play Automatically : 게임이 실행되면 자동으로 클립을 재생함(언체크시 스크립팅으로 체크 가능)<li>이하 생략</ul><p>아래의 코드는 Play Automatically를 언체크하고 스크립트에서 직접 컨트롤 하는 코드이다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">PlayerCtrl</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">// 컴포넌트 캐시 처리할 변수</span>
    <span class="n">Transform</span> <span class="n">tr</span><span class="p">;</span>
    <span class="n">Animation</span> <span class="n">anim</span><span class="p">;</span>

    <span class="p">[</span><span class="err">중략</span><span class="p">...]</span>
    
    <span class="k">private</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Component를 추출해 변수에 대입</span>
        <span class="n">tr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
        <span class="n">anim</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Animation</span><span class="p">&gt;();</span>

        <span class="c1">// 애니메이션 실행</span>
        <span class="n">anim</span><span class="p">.</span><span class="nf">Play</span><span class="p">(</span><span class="s">"Idle"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="p">[</span><span class="err">중략</span><span class="p">...]</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><img data-src="https://user-images.githubusercontent.com/85896566/188578873-49ed1133-34a7-4b72-a76d-0984bce99f6f.png" alt="image" data-proofer-ignore></p><p>이제 주인공 캐릭터를 이동시키면 이동 방향에 적합한 애니메이션을 생성되게 만들어보자.</p><h3 id="animation-blending"><span class="mr-2">Animation Blending</span><a href="#animation-blending" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>유니티는 현재 수행 중인 애니메이션에서 다른 애니메이션으로 변경될 때 이를 부드럽게 연결해주는 애니메이션 블렌딩 기능을 제공한다.</p><p>주인공이 정지 상태일 때는 Idle 애니메이션을 실행하다가 전진하는 경우 자연스럽게 RunF 애니메이션으로 변경되게 해보자.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>    <span class="k">private</span> <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="p">[</span><span class="err">중략</span><span class="p">...]</span>
      <span class="nf">PlayerAnim</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span> <span class="c1">// 주인공 캐릭터의 애니메이션 설정</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">PlayerAnim</span><span class="p">(</span><span class="kt">float</span> <span class="n">h</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="c1">// 키보드 입력값을 기준으로 동작할 애니메이션 수행</span>
    <span class="p">{</span>
        <span class="k">if</span>      <span class="p">(</span><span class="n">v</span> <span class="p">&gt;=</span>  <span class="m">0.1f</span><span class="p">)</span> <span class="n">anim</span><span class="p">.</span><span class="nf">CrossFade</span><span class="p">(</span><span class="s">"RunF"</span><span class="p">,</span> <span class="m">0.25f</span><span class="p">);</span> <span class="c1">// 전진 애니메이션 실행</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="p">&lt;=</span> <span class="p">-</span><span class="m">0.1f</span><span class="p">)</span> <span class="n">anim</span><span class="p">.</span><span class="nf">CrossFade</span><span class="p">(</span><span class="s">"RunB"</span><span class="p">,</span> <span class="m">0.25f</span><span class="p">);</span> <span class="c1">// 후진 애니메이션 실행</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="p">&gt;=</span>  <span class="m">0.1f</span><span class="p">)</span> <span class="n">anim</span><span class="p">.</span><span class="nf">CrossFade</span><span class="p">(</span><span class="s">"RunR"</span><span class="p">,</span> <span class="m">0.25f</span><span class="p">);</span> <span class="c1">// 오른쪽 이동 애니메이션 실행</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="p">&lt;=</span> <span class="p">-</span><span class="m">0.1f</span><span class="p">)</span> <span class="n">anim</span><span class="p">.</span><span class="nf">CrossFade</span><span class="p">(</span><span class="s">"RunL"</span><span class="p">,</span> <span class="m">0.25f</span><span class="p">);</span> <span class="c1">// 왼쪽 이동 애니메이션 실행</span>
        <span class="k">else</span>                 <span class="n">anim</span><span class="p">.</span><span class="nf">CrossFade</span><span class="p">(</span><span class="s">"Idle"</span><span class="p">,</span> <span class="m">0.25f</span><span class="p">);</span> <span class="c1">// 정지 시 대기 애니메이션 실행</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>PlayerAnim()는 주인공 캐릭터에 적절한 애니메이션 클립을 재생시키는 역할을 한다. 주인공 캐릭터의 이동 방향을 판단하는 기준인 h와 v 변수를 인자로 넘겨준다. 주인공 캐릭터가 전후/좌우로 움직이는 것을 0을 기준으로 판단할 수 있기 때문이다. 그리고 키보드를 누르지 않아서 0 값이 전달되면 대기 상태인 Idle 애니메이션 클립을 실행한다.</p><p>애니메이션 클립을 실행하는 CrossFade()는 두 개의 인자를 받는다. 첫 번째 인자는 변경할 애니메이션 클립의 명칭이며, 두 번째 인자는 다른 애니메이션 클립으로 페이드아웃되는 시간을 의미한다. 이 때 단순히 정해진 시간동안 애니메이션이 변경되는 것이 아니라 애니메이션 키프레임을 보간(Interpolate)해 부드럽게 보정시킨다.</p><h2 id="무기-장착"><span class="mr-2">무기 장착</span><a href="#무기-장착" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>무기류를 장착하려면 모델의 Bone 구조를 확인해야 한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188583052-9d8ff156-357c-4476-af91-8270ed8de9a2.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188583507-2f48b364-a0bb-4ab9-82c2-b9ba1705c51c.png" alt="image" data-proofer-ignore></p><p>무기류를 장착해준다면 처음엔 무기 객체의 Transform 속성값을 리셋해준다.</p><p>이후 플레이에서 애니메이션과 무기류의 싱크를 확인하고 부족하다면 Transform을 적절히 변경해준다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188584121-56839ffc-a57f-4e74-b290-6dc055170bee.png" alt="image" data-proofer-ignore></p><h2 id="그림자"><span class="mr-2">그림자</span><a href="#그림자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>게임에 있어서 입체감을 표현하기 위한 그림자 효과는 매우 중요한 요소다. 이어서 그림자를 표현하는 몇 가지 방법을 소개하고자 한다.</p><h3 id="실시간-그림자"><span class="mr-2">실시간 그림자</span><a href="#실시간-그림자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>유니티는 Directional Light, Point Light, Spotlight라는 세 가지 광원에 대해 실시간 그림자(Real Time Shadow)를 지원한다. 하지만 모바일 디바이스의 성능에 따라 실시간 그림자는 처리 비용이 매우 크다.</p><p>유니티는 실시간 그림자가 기본으로 적용돼 있으며 Directional Light 속성 중 Shadow Type 옵션으로 설정한다. Shadow Type 속성으로는 No Shadows, Soft Shadows, Hard Shadows로 세 가지 옵션이 있고 각각은 아래의 내용이다.</p><ul><li>No Shadows : 실시간 그림자를 적용하지 않는다.(기본 설정값) <img data-src="https://user-images.githubusercontent.com/85896566/188585485-5fd8de1e-7bbc-48f5-a5c8-8942ddd38399.png" alt="image" data-proofer-ignore><li>Soft Shadows : 실시간 그림자를 표현하지만, 외곽선에 계단 현상이 발생한다. <img data-src="https://user-images.githubusercontent.com/85896566/188585527-2f50d710-cfa8-40cd-8ccb-538bc4c40e16.png" alt="image" data-proofer-ignore><li>Hard Shadows : 부드러운 실시간 그림자를 표현하지만, 가장 많은 부하를 준다. <img data-src="https://user-images.githubusercontent.com/85896566/188585577-352dfa66-8ba8-492f-aba9-8a08b66c1b15.png" alt="image" data-proofer-ignore></ul><p>실시간 그림자의 시각적 효과는 매우 탁월하지만, 엔진에 많은 부하를 준다. 따라서 실시간 그림자 효과가 필요 없는 3D 모델은 실시간 그림자 영향에서 제외하는 설정을 빠뜨리지 않아야 한다.</p><p>3D 모델은 Mesh Renderer 또는 Skinned Mesh Renderer 중 한 컴포넌트를 반드시 갖고 있다. 그리고 이 두 가지 컴포넌트에는 실시간 그림자와 관련된 Cast Shadows와 Receive Shadows 속성이 있다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188586219-ec933ae1-d2a2-4d3b-b9ba-3d2c7c4ae2b4.png" alt="image" data-proofer-ignore></p><ul><li>Cast Shadows : 빛을 받아서 자신의 그림자를 만들 것인지 결정하는 속성 |Cast Shadows|Option| |—|—| |Off|그림자를 만들지 않는다.| |On|그림자를 만든다.| |Two Sided|백 페이스 컬링을 무시하고 그림자를 양면으로 만든다.| |Shadows Only|그림자를 만들지만, 자신은 렌더링하지 않는다. 즉, 화면에 보이지 않는 특성이 있어 그림자 처리만을 위한 로우 폴리 3D 모델에 활용할 수 있다.|<li>Receive Shadows : 다른 그림자에 들어갔을 때 표면에 그림자의 영향을 받는지 아닌지</ul><p>따라서 실시간 그림자의 영향을 받지 않아도 시각적 효과에 크게 상관없는 3D 모델은 이 두가지 옵션을 적절히 설정해 그림자를 생성하지 않게 한다.</p><h4 id="info--cast-shadows-속성의-two-sided-옵션에-대해"><span class="mr-2">Info = Cast Shadows 속성의 Two Sided 옵션에 대해</span><a href="#info--cast-shadows-속성의-two-sided-옵션에-대해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Plane 또는 Quad처럼 단면(Single-Side)만 렌더링 하는 모델은 Cast Shadows 속성을 On으로 하고, 빛을 모델의 뒤쪽(Backface)에서 비추면 그림자가 생성되지 않는다.(두 번째 그림 참고). 이 때 Cast Shadows 속성을 Two Sided로 설정하면 그림자가 생성된다.(세 번째 그림 참고).</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188587747-bbae2429-cb33-4625-bfb4-b270b6a50994.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188588083-1ef86843-19db-4927-a5fa-821e23af1720.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188588158-69088fde-024c-44d2-bc5b-73ad29f8cd21.png" alt="image" data-proofer-ignore></p><h3 id="메시를-이용한-그림자"><span class="mr-2">메시를 이용한 그림자</span><a href="#메시를-이용한-그림자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>실시간 그림자보다 시각적인 효과는 덜 하지만, 그래도 입체감을 낼 수 있는 가벼운 그림자 처리를 구현할 수 있는 방법. 단순한 평면 메시를 이용하는 방법으로 모바일 게임에서 흔히 볼 수 있는 방식</p><p>먼저 객체에 적용된 실시간 그림자가 생성되지 않도록 설정한다. + 무기류</p><ul><li>Cast Shadows - Off<li>Receive Shadows - 언체크</ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188589022-a3ce0133-733c-4cb1-b6c4-2f951acc4a05.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188589500-307b6a1b-e4e9-4423-b154-70140b185eaf.png" alt="image" data-proofer-ignore></p><p>다음 단계로 그림자를 표시할 메시는 유니티에서 제공하는 Quad를 사용한다. Quad 모델을 생성해 Player에게 자식화한다.</p><ul><li>콜라이더 컴포넌트 삭제<li>이름 변경<li>준비한 Material 지정<li>Material Shader를 [Mobile] -&gt; [Particles] -&gt; [Multiply]로 변경</ul><p><img data-src="https://user-images.githubusercontent.com/85896566/188591059-fa12ac74-a614-4127-b851-b4d427ea6328.png" alt="image" data-proofer-ignore></p><p>이 방법은 부하가 적은 방법으로 많이 사용되고 있지만, 스테이지에 굴곡이 있거나 경사로가 있다면 그림자가 다른 메시에 묻혀 제대로 표현되지 않는다는 점도 기억하자.</p><h2 id="level-of-detail-설정"><span class="mr-2">Level Of Detail 설정</span><a href="#level-of-detail-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>LOD, Level Of Detail란, 화면을 렌더링하는 카메라로부터 멀리 떨어질수록 낮은 폴리곤으로 변경해 렌더링 부하를 줄여주는 기법이다.</p><p>주인공 모델의 3가지 메시는 3단계 LOD로 설정된 메시다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188591864-488c4d45-81ff-49f8-a8ca-5c40bfa5a1a2.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188591939-b3a0b748-bc8b-4320-827a-452f36862d1e.png" alt="image" data-proofer-ignore></p><p><img data-src="https://user-images.githubusercontent.com/85896566/188592027-19ee3a96-c59b-45a3-8e25-e1c9d30e0a34.png" alt="image" data-proofer-ignore></p><h3 id="lod-group-component"><span class="mr-2">LOD Group Component</span><a href="#lod-group-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>LOD Group Component는 카메라와 피사체의 거리에 따라 렌더링할 메시를 결정하는 역할을 함 LOD Group Component를 Add한다.</p><p>LOD 구간대로 메시를 차례대로 드래그 &amp; 드롭한다. LOD 0구간은 하이 폴리곤이며 숫자가 커질수록 로우 폴리곤 메시를 연결한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188592843-af83f7e3-d156-4d1b-8849-a4ebba3126e8.png" alt="image" data-proofer-ignore></p><p>Culled(Red)는 카메라와의 거리가 아주 멀리 떨어져 화면에서 렌더링하지 않는 구간을 의미한다.</p><p>주인공 캐릭터는 대부분 카메라와의 거리가 고정돼있기 때문에 굳이 LOD를 적용할 필요는 없지만, 멀티플레이어 게임에서는 상대편이 멀리 떨어져 있는 내 캐릭터를 봤을 때 LOD가 유용하게 사용될 수 있다. 특히 모바일 게임에서는 렌더링 최적화 기법 가운데 중요하게 꼽는 것 중 하나가 바로 LOD 기능이다.</p><h2 id="follow-camera-로직"><span class="mr-2">Follow Camera 로직</span><a href="#follow-camera-로직" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">FollowCam</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">// 따라가야 할 대상을 연결할 변수</span>
    <span class="k">public</span> <span class="n">Transform</span> <span class="n">targetTr</span><span class="p">;</span>
    <span class="c1">// Main Camera 자신의 Transform 컴포넌트</span>
    <span class="k">private</span> <span class="n">Transform</span> <span class="n">camTr</span><span class="p">;</span>

    <span class="c1">// 따라갈 대상으로부터 떨어질 거리</span>
    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">2.0f</span><span class="p">,</span> <span class="m">20.0f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">distance</span> <span class="p">=</span> <span class="m">10.0f</span><span class="p">;</span>

    <span class="c1">// Y축으로 이동할 높이</span>
    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.0f</span><span class="p">,</span> <span class="m">10.0f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">height</span> <span class="p">=</span> <span class="m">2.0f</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Main Camera 자신의 Transform 컴포넌트를 추출</span>
        <span class="n">camTr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">LateUpdate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 추적해야 할 대상의 뒤쪽으로 distance만큼 이동</span>
        <span class="c1">// 높이를 height만큼 이동</span>
        <span class="n">Vector3</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">targetTr</span><span class="p">.</span><span class="n">position</span>
                      <span class="p">+</span> <span class="p">(-</span><span class="n">targetTr</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">distance</span><span class="p">)</span>
                      <span class="p">+</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="n">height</span><span class="p">);</span>

        <span class="c1">// Camera를 피벗 좌표를 향해 회전</span>
        <span class="n">camTr</span><span class="p">.</span><span class="nf">LookAt</span><span class="p">(</span><span class="n">targetTr</span><span class="p">.</span><span class="n">position</span> <span class="p">+</span> <span class="p">(</span><span class="n">targetTr</span><span class="p">.</span><span class="n">up</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>[Range(min, max)] 어트리뷰트를 사용하면 다음 라인에 선언한 변수의 입력 범위를 (min, max)로 제한할 수 있고, 인스펙터 뷰에 슬라이드 바를 표시한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188594277-b3c9c9a8-e8c8-4388-abb6-ce0adfa6e83f.png" alt="image" data-proofer-ignore></p><p>LateUpdate()에서 후처리 로직으로 이용한 이유는 Update()의 순서에 플레이어의 이동 로직이 항상 먼저 실행되는 것이 보장되지 않기 때문에 카메라가 떨리는 현상이 발생한다. 따라서 선행된 결괏값을 갖고 후처리 작업을 해야 하므로 LateUpdate()를 이용했다.</p><p>Transform.LookAt() 함수는 인자로 Vector3 좌표 또는 Transform 컴포넌트를 전달하면 해당 좌표로 회전시키는 기능을 한다. 먼저 카메라의 위치를 이동시킨 후 따라갈 대상을 향해 카메라의 각도를 회전시키는 역할</p><h3 id="vecotr3lerp-vector3slerp"><span class="mr-2">Vecotr3.Lerp, Vector3.Slerp</span><a href="#vecotr3lerp-vector3slerp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>선형 보간(Linear Interpolation)과 구면 선형 보간(Spherical Linear Interpolation)은 시작점과 끝점 사이의 특정 위치의 값을 추정할 때 사용한다. 이러한 보간 함수는 현재 값을 목푯값으로 변경할 때 갑자기 변경하지 않고 부드럽게 변경시키는 로직에 많이 활용된다.</p><p>선형 보간이라는 명칭에서 알 수 있듯이 “선형”은 “직선”을 의미한다. 균일한 속도로 이동시키거나 회전시킬 때 사용한다.</p><p>유니티에서는 Lerp 선형 보간 함수를 제공하며 Vector3, Mathf, Quaternion, Color 구조체에서 사용할 수 있다.</p><p>매개변수는 Lerp(a, b, t)로, a와 b를 잇는 선을 t를 통해 분할하는 지점을 반환한다. 예를 들어 t값이 0.5라면 a, b의 중간지점을 반환한다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188597015-35e390e2-0f85-4768-af40-f2474ef65675.png" alt="image" data-proofer-ignore></p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">Vector3</span><span class="p">.</span><span class="nf">Lerp</span><span class="p">(</span><span class="err">시작</span> <span class="err">좌표</span><span class="p">,</span> <span class="err">종료</span> <span class="err">좌표</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="n">Mathf</span><span class="p">.</span><span class="nf">Lerp</span><span class="p">(</span><span class="err">시작</span> <span class="err">값</span><span class="p">,</span> <span class="err">종료</span> <span class="err">값</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Lerp</span><span class="p">(</span><span class="err">시작</span> <span class="err">각도</span><span class="p">,</span> <span class="err">종료</span> <span class="err">각도</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</pre></table></code></div></div><p>구면 선형 보간(Spherical Linear Interpolation)은 직선의 형태가 아닌 구면(구체)의 형태로 값을 추론한다. 구면을 따라서 값을 반환하기에 시간 t가 증가할 때 시작점과 종료점은 느리게 증가하고 중간지점은 동일한 시간 대비 이동해야 할 거리가 크기 때문에 빠르게 이동하는 특성이 있다. 따라서 구면 선형 보간은 회전 로직에 사용된다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188598037-2aba1e2b-37e1-4e33-bddf-655729cece61.png" alt="image" data-proofer-ignore></p><p>유니티에서 제공하는 구면 선형 보간 함수는 Slerp로 Vector3, Quaternion 구조체에서 사용할 수 있고, 매개변수는 Lerp와 똑같이 가지게 되며 함수의 사용법은 다음과 같다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">Vector3</span><span class="p">.</span><span class="nf">Slerp</span><span class="p">(</span><span class="err">시작</span> <span class="err">좌표</span><span class="p">,</span> <span class="err">종료</span> <span class="err">좌표</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Slerp</span><span class="p">(</span><span class="err">시작</span> <span class="err">각도</span><span class="p">,</span> <span class="err">종료</span> <span class="err">각도</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</pre></table></code></div></div><p>이제 스크립트를 수정한다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">FollowCam</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">// 따라가야 할 대상을 연결할 변수</span>
    <span class="k">public</span> <span class="n">Transform</span> <span class="n">targetTr</span><span class="p">;</span>
    <span class="c1">// Main Camera 자신의 Transform 컴포넌트</span>
    <span class="k">private</span> <span class="n">Transform</span> <span class="n">camTr</span><span class="p">;</span>

    <span class="c1">// 따라갈 대상으로부터 떨어질 거리</span>
    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">2.0f</span><span class="p">,</span> <span class="m">20.0f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">distance</span> <span class="p">=</span> <span class="m">10.0f</span><span class="p">;</span>

    <span class="c1">// Y축으로 이동할 높이</span>
    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.0f</span><span class="p">,</span> <span class="m">10.0f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">height</span> <span class="p">=</span> <span class="m">2.0f</span><span class="p">;</span>

    <span class="c1">// 반응 속도</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">damping</span> <span class="p">=</span> <span class="m">10.0f</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Main Camera 자신의 Transform 컴포넌트를 추출</span>
        <span class="n">camTr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">LateUpdate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 추적해야 할 대상의 뒤쪽으로 distance만큼 이동</span>
        <span class="c1">// 높이를 height만큼 이동</span>
        <span class="n">Vector3</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">targetTr</span><span class="p">.</span><span class="n">position</span>
                      <span class="p">+</span> <span class="p">(-</span><span class="n">targetTr</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">distance</span><span class="p">)</span>
                      <span class="p">+</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="n">height</span><span class="p">);</span>

        <span class="err">구면</span> <span class="err">선형</span> <span class="err">보간함수를</span> <span class="err">사용해</span> <span class="err">부드럽게</span> <span class="err">위치를</span> <span class="err">변경</span>
        <span class="n">camTr</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="nf">Slerp</span><span class="p">(</span><span class="n">camTr</span><span class="p">.</span><span class="n">position</span><span class="p">,</span>           <span class="c1">// 시작 위치</span>
                                      <span class="n">pos</span><span class="p">,</span>                       <span class="c1">// 목표 위치</span>
                                      <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span> <span class="p">*</span> <span class="n">damping</span><span class="p">);</span> <span class="c1">// 시간 t</span>

        <span class="c1">// Camera를 피벗 좌표를 향해 회전</span>
        <span class="n">camTr</span><span class="p">.</span><span class="nf">LookAt</span><span class="p">(</span><span class="n">targetTr</span><span class="p">.</span><span class="n">position</span> <span class="p">+</span> <span class="p">(</span><span class="n">targetTr</span><span class="p">.</span><span class="n">up</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>변경한 코드는 카메라가 이동할 목표 위치를 변수에 저장한 후 Slerp()를 이용해 점진적으로 이동시킨다. 실행해보면 처음 작성했던 코드보다 부드러워진 것을 확인할 수 있다.</p><h3 id="vector3smoothdamp"><span class="mr-2">Vector3.SmoothDamp</span><a href="#vector3smoothdamp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>부드럽게 이동시키는 방법 중 Vector3.SmoothDamp() 함수를 이용하는 방법도 있다. 보통 카메라의 Follow 로직에 많이 사용되며 사용법은 다음과 같다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">Vector3</span><span class="p">.</span><span class="nf">SmoothDamp</span><span class="p">(</span><span class="n">Vector3</span> <span class="n">current</span><span class="p">,</span>
                   <span class="n">Vector3</span> <span class="n">target</span><span class="p">,</span>
                   <span class="k">ref</span> <span class="n">Vector3</span> <span class="n">currentVelocity</span><span class="p">,</span>
                   <span class="kt">float</span> <span class="n">smoothTime</span><span class="p">,</span>
                   <span class="kt">float</span> <span class="n">maxSpeed</span><span class="p">,</span>
                   <span class="kt">float</span> <span class="n">deltaTime</span><span class="p">);</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>매개 변수<th>설명<tbody><tr><td>current<td>시작 위치<tr><td>target<td>목표 위치<tr><td>currentVelocity<td>현재 속도<tr><td>smoothTime<td>목표 위치까지의 도달 시간<tr><td>maxSpeed<td>최대 속력 제한 값(기본값: 무한대 Mathf.Infinity), 생략 가능<tr><td>deltaTime<td>프레임 보정을 위한 델타 타임(기본값: Time.deltaTime), 생략 가능</table></div><p>앞서 작성한 코드에서 구면 선형 보간을 사용한 부분은 주석 처리하고 다음과 같이 수정한다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">FollowCam</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">// 따라가야 할 대상을 연결할 변수</span>
    <span class="k">public</span> <span class="n">Transform</span> <span class="n">targetTr</span><span class="p">;</span>
    <span class="c1">// Main Camera 자신의 Transform 컴포넌트</span>
    <span class="k">private</span> <span class="n">Transform</span> <span class="n">camTr</span><span class="p">;</span>

    <span class="c1">// 따라갈 대상으로부터 떨어질 거리</span>
    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">2.0f</span><span class="p">,</span> <span class="m">20.0f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">distance</span> <span class="p">=</span> <span class="m">10.0f</span><span class="p">;</span>

    <span class="c1">// Y축으로 이동할 높이</span>
    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.0f</span><span class="p">,</span> <span class="m">10.0f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">height</span> <span class="p">=</span> <span class="m">2.0f</span><span class="p">;</span>

    <span class="c1">// 반응 속도</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">damping</span> <span class="p">=</span> <span class="m">10.0f</span><span class="p">;</span>

    <span class="c1">// SmoothDamp에서 사용할 변수</span>
    <span class="k">private</span> <span class="n">Vector3</span> <span class="n">velocity</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Main Camera 자신의 Transform 컴포넌트를 추출</span>
        <span class="n">camTr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">LateUpdate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 추적해야 할 대상의 뒤쪽으로 distance만큼 이동</span>
        <span class="c1">// 높이를 height만큼 이동</span>
        <span class="n">Vector3</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">targetTr</span><span class="p">.</span><span class="n">position</span>
                      <span class="p">+</span> <span class="p">(-</span><span class="n">targetTr</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">distance</span><span class="p">)</span>
                      <span class="p">+</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="n">height</span><span class="p">);</span>

        <span class="c1">// 구면 선형 보간함수를 사용해 부드럽게 위치를 변경</span>
        <span class="c1">// camTr.position = Vector3.Slerp(camTr.position,           // 시작 위치</span>
        <span class="c1">//                               pos,                       // 목표 위치</span>
        <span class="c1">//                               Time.deltaTime * damping); // 시간 t</span>

        <span class="c1">// SmoothDamp을 이용한 위치 보간</span>
        <span class="n">camTr</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="nf">SmoothDamp</span><span class="p">(</span><span class="n">camTr</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="c1">// 시작 위치</span>
                                            <span class="n">pos</span><span class="p">,</span>            <span class="c1">// 목표 위치</span>
                                            <span class="k">ref</span> <span class="n">velocity</span><span class="p">,</span>   <span class="c1">// 현재 속도</span>
                                            <span class="n">damping</span><span class="p">);</span>       <span class="c1">// 목표 위치까지 도달할 시간</span>

        <span class="c1">// Camera를 피벗 좌표를 향해 회전</span>
        <span class="n">camTr</span><span class="p">.</span><span class="nf">LookAt</span><span class="p">(</span><span class="n">targetTr</span><span class="p">.</span><span class="n">position</span> <span class="p">+</span> <span class="p">(</span><span class="n">targetTr</span><span class="p">.</span><span class="n">up</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Damping 속성을 0.1로 변경하고 테스트해보면 구면 선형 보간 로직에 사용했던 Damping 변수는 값이 클수록 반응 속도가 빨랐지만 SmoothDamp에서는 목표 지점까지 이동할 때 걸리는 시간으로 사용되기 때문에 반대로 값이 작을수록 반응 속도가 빨라진다.</p><h3 id="target-offset-적용"><span class="mr-2">Target Offset 적용</span><a href="#target-offset-적용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>지금까지의 코드를 플레이해보면 주인공 캐릭터가 중앙에 위치해 전반 시야가 매우 좁다. 이것은 FollowCam.cs에서 메인 카메라가 플레이어를 향해 LookAt 처리를 해서 플레이어의 피벗 좌표를 바라보기 때문이다. 따라서 LookAt 좌표를 조정해서 전방 시야를 확보해보자.</p><p>스크립트를 다음과 같이 수정한다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">FollowCam</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">// 따라가야 할 대상을 연결할 변수</span>
    <span class="k">public</span> <span class="n">Transform</span> <span class="n">targetTr</span><span class="p">;</span>
    <span class="c1">// Main Camera 자신의 Transform 컴포넌트</span>
    <span class="k">private</span> <span class="n">Transform</span> <span class="n">camTr</span><span class="p">;</span>

    <span class="c1">// 따라갈 대상으로부터 떨어질 거리</span>
    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">2.0f</span><span class="p">,</span> <span class="m">20.0f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">distance</span> <span class="p">=</span> <span class="m">10.0f</span><span class="p">;</span>

    <span class="c1">// Y축으로 이동할 높이</span>
    <span class="p">[</span><span class="nf">Range</span><span class="p">(</span><span class="m">0.0f</span><span class="p">,</span> <span class="m">10.0f</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">height</span> <span class="p">=</span> <span class="m">2.0f</span><span class="p">;</span>

    <span class="c1">// 반응 속도</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">damping</span> <span class="p">=</span> <span class="m">10.0f</span><span class="p">;</span>

    <span class="c1">// 카메라 LookAt의 Offset 값</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">targetOffset</span> <span class="p">=</span> <span class="m">2.0f</span><span class="p">;</span>

    <span class="c1">// SmoothDamp에서 사용할 변수</span>
    <span class="k">private</span> <span class="n">Vector3</span> <span class="n">velocity</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Main Camera 자신의 Transform 컴포넌트를 추출</span>
        <span class="n">camTr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">LateUpdate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 추적해야 할 대상의 뒤쪽으로 distance만큼 이동</span>
        <span class="c1">// 높이를 height만큼 이동</span>
        <span class="n">Vector3</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">targetTr</span><span class="p">.</span><span class="n">position</span>
                      <span class="p">+</span> <span class="p">(-</span><span class="n">targetTr</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">distance</span><span class="p">)</span>
                      <span class="p">+</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="n">height</span><span class="p">);</span>

        <span class="c1">// 구면 선형 보간함수를 사용해 부드럽게 위치를 변경</span>
        <span class="c1">// camTr.position = Vector3.Slerp(camTr.position,           // 시작 위치</span>
        <span class="c1">//                               pos,                       // 목표 위치</span>
        <span class="c1">//                               Time.deltaTime * damping); // 시간 t</span>

        <span class="c1">// SmoothDamp을 이용한 위치 보간</span>
        <span class="n">camTr</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="nf">SmoothDamp</span><span class="p">(</span><span class="n">camTr</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="c1">// 시작 위치</span>
                                            <span class="n">pos</span><span class="p">,</span>            <span class="c1">// 목표 위치</span>
                                            <span class="k">ref</span> <span class="n">velocity</span><span class="p">,</span>   <span class="c1">// 현재 속도</span>
                                            <span class="n">damping</span><span class="p">);</span>       <span class="c1">// 목표 위치까지 도달할 시간</span>

        <span class="c1">// Camera를 피벗 좌표를 향해 회전</span>
        <span class="n">camTr</span><span class="p">.</span><span class="nf">LookAt</span><span class="p">(</span><span class="n">targetTr</span><span class="p">.</span><span class="n">position</span> <span class="p">+</span> <span class="p">(</span><span class="n">targetTr</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="n">targetOffset</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>실행한 화면이다. 카메라가 플레이어를 향해 다가오고, 캐릭터가 화면 아래쪽에 배치되고 전방 시야가 확보됐다.</p><p><img data-src="https://user-images.githubusercontent.com/85896566/188604709-4ca10931-d865-480f-8dbe-722d0aed5d73.png" alt="image" data-proofer-ignore></p><h2 id="정리-2"><span class="mr-2">정리</span><a href="#정리-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>주인공 3D 모델 임포트<li>C# 스크립트 생성 방법<li>키보드 입력값 처리<li>캐랙터의 이동 및 회전<li>애니메이션 처리<li>실시간 그림자와 모바일용 그림자 처리<li>LOD 설정<li>FollowCamera 로직 구현</ul><p>게임오브젝트와 컴포넌트 사이의 관계와 기본적인 이동, 회전 기능에 대한 스크립트를 작성해봤다.</p><p><br /></p><hr /><h1 id="-05장--총-발사-로직">※ 05장 : 총 발사 로직</h1><h2 id="총알-모델-준비"><span class="mr-2">총알 모델 준비</span><a href="#총알-모델-준비" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="rigidbody-component"><span class="mr-2">Rigidbody Component</span><a href="#rigidbody-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="physics-manager물리-엔진-속성-설정"><span class="mr-2">Physics Manager(물리 엔진 속성 설정)</span><a href="#physics-manager물리-엔진-속성-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="collider-component"><span class="mr-2">Collider Component</span><a href="#collider-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="box-collider"><span class="mr-2">Box Collider</span><a href="#box-collider" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="sphere-collider"><span class="mr-2">Sphere Collider</span><a href="#sphere-collider" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="capsule-collider"><span class="mr-2">Capsule Collider</span><a href="#capsule-collider" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="mesh-collider"><span class="mr-2">Mesh Collider</span><a href="#mesh-collider" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="wheel-collider"><span class="mr-2">Wheel Collider</span><a href="#wheel-collider" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="terrain-collider"><span class="mr-2">Terrain Collider</span><a href="#terrain-collider" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="충돌-감지-조건"><span class="mr-2">충돌 감지 조건</span><a href="#충돌-감지-조건" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="충돌-이벤트"><span class="mr-2">충돌 이벤트</span><a href="#충돌-이벤트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="tag-이용"><span class="mr-2">Tag 이용</span><a href="#tag-이용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="oncollisionenter-콜백-함수"><span class="mr-2">OnCollisionEnter 콜백 함수</span><a href="#oncollisionenter-콜백-함수" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="comparetag-함수"><span class="mr-2">CompareTag 함수</span><a href="#comparetag-함수" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="bullet의-프리팹-전환"><span class="mr-2">Bullet의 프리팹 전환</span><a href="#bullet의-프리팹-전환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="총알-발사-로직"><span class="mr-2">총알 발사 로직</span><a href="#총알-발사-로직" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="총알의-발사-위치"><span class="mr-2">총알의 발사 위치</span><a href="#총알의-발사-위치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="런-모드에서-수정한-속성"><span class="mr-2">런 모드에서 수정한 속성</span><a href="#런-모드에서-수정한-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="기즈모의-활용"><span class="mr-2">기즈모의 활용</span><a href="#기즈모의-활용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="스크립트-작성-방식"><span class="mr-2">스크립트 작성 방식</span><a href="#스크립트-작성-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="trail-renderer총알-발사-궤적-효과"><span class="mr-2">Trail Renderer(총알 발사 궤적 효과)</span><a href="#trail-renderer총알-발사-궤적-효과" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="trail-renderer"><span class="mr-2">Trail Renderer</span><a href="#trail-renderer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="프리팹의-변경-내용-조회-및-저장"><span class="mr-2">프리팹의 변경 내용 조회 및 저장</span><a href="#프리팹의-변경-내용-조회-및-저장" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="파티클-활용하기"><span class="mr-2">파티클 활용하기</span><a href="#파티클-활용하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="충돌-지점과-법선-벡터"><span class="mr-2">충돌 지점과 법선 벡터</span><a href="#충돌-지점과-법선-벡터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="quaternion"><span class="mr-2">Quaternion</span><a href="#quaternion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="폭발-효과-및-폭발력-생성"><span class="mr-2">폭발 효과 및 폭발력 생성</span><a href="#폭발-효과-및-폭발력-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="scale-factor"><span class="mr-2">Scale Factor</span><a href="#scale-factor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="하이러키-뷰의-간략화"><span class="mr-2">하이러키 뷰의 간략화</span><a href="#하이러키-뷰의-간략화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="mesh-renderer텍스처-변경"><span class="mr-2">Mesh Renderer(텍스처 변경)</span><a href="#mesh-renderer텍스처-변경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="폭발력-적용하기---addexplosionforce"><span class="mr-2">폭발력 적용하기 - AddExplosionForce</span><a href="#폭발력-적용하기---addexplosionforce" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="overlapspherenonalloc"><span class="mr-2">OverlapSPhereNonAlloc</span><a href="#overlapspherenonalloc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="audio"><span class="mr-2">Audio</span><a href="#audio" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="audiolistener-audiosource-component"><span class="mr-2">AudioListener, AudioSource Component</span><a href="#audiolistener-audiosource-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="오디오-파일-임포트-및-설정"><span class="mr-2">오디오 파일 임포트 및 설정</span><a href="#오디오-파일-임포트-및-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="오디오-임포트-옵션---load-type"><span class="mr-2">오디오 임포트 옵션 - Load Type</span><a href="#오디오-임포트-옵션---load-type" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="오디오-임포트-옵션---compression-format"><span class="mr-2">오디오 임포트 옵션 - Compression Format</span><a href="#오디오-임포트-옵션---compression-format" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="총소리-구현"><span class="mr-2">총소리 구현</span><a href="#총소리-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="총구-화염-효과---muzzle-flash"><span class="mr-2">총구 화염 효과 - Muzzle Flash</span><a href="#총구-화염-효과---muzzle-flash" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="코루틴-함수"><span class="mr-2">코루틴 함수</span><a href="#코루틴-함수" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="muzzleflash의-블링크-효과"><span class="mr-2">MuzzleFlash의 블링크 효과</span><a href="#muzzleflash의-블링크-효과" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="muzzleflash의-텍스처-오프셋-변경"><span class="mr-2">MuzzleFlash의 텍스처 오프셋 변경</span><a href="#muzzleflash의-텍스처-오프셋-변경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="코루틴의-응용---임계치"><span class="mr-2">코루틴의 응용 - 임계치</span><a href="#코루틴의-응용---임계치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="정리-3"><span class="mr-2">정리</span><a href="#정리-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><br /></p><hr /><h1 id="-06장--적-캐릭터-제작">※ 06장 : 적 캐릭터 제작</h1><h2 id="유한-상태-머신의-정의"><span class="mr-2">유한 상태 머신의 정의</span><a href="#유한-상태-머신의-정의" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="메카님"><span class="mr-2">메카님</span><a href="#메카님" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="적-캐릭터-3d-모델-임포트"><span class="mr-2">적 캐릭터 3D 모델 임포트</span><a href="#적-캐릭터-3d-모델-임포트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="메카님-애니메이션으로-전환"><span class="mr-2">메카님 애니메이션으로 전환</span><a href="#메카님-애니메이션으로-전환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="애니메이션-클립-속성"><span class="mr-2">애니메이션 클립 속성</span><a href="#애니메이션-클립-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="애니메이션-리타게팅"><span class="mr-2">애니메이션 리타게팅</span><a href="#애니메이션-리타게팅" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="animator-component"><span class="mr-2">Animator Component</span><a href="#animator-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="애니메이터-컨트롤러"><span class="mr-2">애니메이터 컨트롤러</span><a href="#애니메이터-컨트롤러" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="스테이트-전이와-파라미터"><span class="mr-2">스테이트 전이와 파라미터</span><a href="#스테이트-전이와-파라미터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="내비게이션---적-캐릭터의-순찰-및-추적"><span class="mr-2">내비게이션 - 적 캐릭터의 순찰 및 추적</span><a href="#내비게이션---적-캐릭터의-순찰-및-추적" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="내비게이션-설정---navigation-static-flag"><span class="mr-2">내비게이션 설정 - Navigation Static Flag</span><a href="#내비게이션-설정---navigation-static-flag" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="내비메시-베이크"><span class="mr-2">내비메시 베이크</span><a href="#내비메시-베이크" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="navmeshagent-component"><span class="mr-2">NavMeshAgent Component</span><a href="#navmeshagent-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="유한-상태-머신-구현"><span class="mr-2">유한 상태 머신 구현</span><a href="#유한-상태-머신-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="적-캐릭터의-상태-체크"><span class="mr-2">적 캐릭터의 상태 체크</span><a href="#적-캐릭터의-상태-체크" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="적-캐릭터의-행동-구현"><span class="mr-2">적 캐릭터의 행동 구현</span><a href="#적-캐릭터의-행동-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="애니메이션-동기화"><span class="mr-2">애니메이션 동기화</span><a href="#애니메이션-동기화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="몬스터-공격-루틴"><span class="mr-2">몬스터 공격 루틴</span><a href="#몬스터-공격-루틴" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="몬스터-피격-리액션"><span class="mr-2">몬스터 피격 리액션</span><a href="#몬스터-피격-리액션" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="혈흔-효과"><span class="mr-2">혈흔 효과</span><a href="#혈흔-효과" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="resources-폴더"><span class="mr-2">Resources 폴더</span><a href="#resources-폴더" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="적-캐릭터의-공격-능력"><span class="mr-2">적 캐릭터의 공격 능력</span><a href="#적-캐릭터의-공격-능력" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="ontriggerenter-콜백-함수"><span class="mr-2">OnTriggerEnter 콜백 함수</span><a href="#ontriggerenter-콜백-함수" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="특정-레이어-간의-충돌-감지"><span class="mr-2">특정 레이어 간의 충돌 감지</span><a href="#특정-레이어-간의-충돌-감지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="본-구조의-최적화"><span class="mr-2">본 구조의 최적화</span><a href="#본-구조의-최적화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="몬스터-공격-중지"><span class="mr-2">몬스터 공격 중지</span><a href="#몬스터-공격-중지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="애니메이션의-재생-속도-조절"><span class="mr-2">애니메이션의 재생 속도 조절</span><a href="#애니메이션의-재생-속도-조절" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="사용자-정의-이벤트---delegate"><span class="mr-2">사용자 정의 이벤트 - Delegate</span><a href="#사용자-정의-이벤트---delegate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="델리게이트"><span class="mr-2">델리게이트</span><a href="#델리게이트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="주인공의-사망-이벤트-처리"><span class="mr-2">주인공의 사망 이벤트 처리</span><a href="#주인공의-사망-이벤트-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="몬스터의-사망-처리"><span class="mr-2">몬스터의 사망 처리</span><a href="#몬스터의-사망-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="root-transform-position"><span class="mr-2">Root Transform Position</span><a href="#root-transform-position" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="정리-4"><span class="mr-2">정리</span><a href="#정리-4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><br /></p><hr /><h1 id="-07장--유니티-ui-시스템">※ 07장 : 유니티 UI 시스템</h1><h2 id="유니티-ui-구현-형태"><span class="mr-2">유니티 UI 구현 형태</span><a href="#유니티-ui-구현-형태" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="imgui"><span class="mr-2">IMGUI</span><a href="#imgui" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="ui-toolkit"><span class="mr-2">UI Toolkit</span><a href="#ui-toolkit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="unity-ui"><span class="mr-2">Unity UI</span><a href="#unity-ui" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="ui-리소스-준비"><span class="mr-2">UI 리소스 준비</span><a href="#ui-리소스-준비" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="canvas-객체"><span class="mr-2">Canvas 객체</span><a href="#canvas-객체" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="eventsystem-객체"><span class="mr-2">EventSystem 객체</span><a href="#eventsystem-객체" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="canvas-객체의-component"><span class="mr-2">Canvas 객체의 Component</span><a href="#canvas-객체의-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="canvas-component"><span class="mr-2">Canvas Component</span><a href="#canvas-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="screen-space---overlay"><span class="mr-2">Screen Space - Overlay</span><a href="#screen-space---overlay" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="screen-space---camera"><span class="mr-2">Screen Space - Camera</span><a href="#screen-space---camera" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="world-space"><span class="mr-2">World Space</span><a href="#world-space" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="rect-transform-component"><span class="mr-2">Rect Transform Component</span><a href="#rect-transform-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="앵커-프리셋"><span class="mr-2">앵커 프리셋</span><a href="#앵커-프리셋" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="기본-앵커-프리셋"><span class="mr-2">기본 앵커 프리셋</span><a href="#기본-앵커-프리셋" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="alt-키-조합의-앵커-프리셋"><span class="mr-2">Alt 키 조합의 앵커 프리셋</span><a href="#alt-키-조합의-앵커-프리셋" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="shift-키-조합의-앵커-프리셋"><span class="mr-2">Shift 키 조합의 앵커 프리셋</span><a href="#shift-키-조합의-앵커-프리셋" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="alt--shift-키-조합의-앵커-프리셋"><span class="mr-2">Alt + Shift 키 조합의 앵커 프리셋</span><a href="#alt--shift-키-조합의-앵커-프리셋" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="anchoredposition-속성"><span class="mr-2">anchoredPosition 속성</span><a href="#anchoredposition-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="anchors-속성"><span class="mr-2">Anchors 속성</span><a href="#anchors-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="image-component"><span class="mr-2">Image Component</span><a href="#image-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="simple"><span class="mr-2">Simple</span><a href="#simple" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="sliced"><span class="mr-2">Sliced</span><a href="#sliced" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="tiled"><span class="mr-2">Tiled</span><a href="#tiled" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="텍스처의-wrap-mode"><span class="mr-2">텍스처의 Wrap Mode</span><a href="#텍스처의-wrap-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="filled"><span class="mr-2">Filled</span><a href="#filled" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="rawimage-component"><span class="mr-2">RawImage Component</span><a href="#rawimage-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="button-component"><span class="mr-2">Button Component</span><a href="#button-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="transition-속성"><span class="mr-2">Transition 속성</span><a href="#transition-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="navigation"><span class="mr-2">Navigation</span><a href="#navigation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="button-event"><span class="mr-2">Button Event</span><a href="#button-event" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="text-component"><span class="mr-2">Text Component</span><a href="#text-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="스크립트에서-버튼-이벤트-처리하기"><span class="mr-2">스크립트에서 버튼 이벤트 처리하기</span><a href="#스크립트에서-버튼-이벤트-처리하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="람다식"><span class="mr-2">람다식</span><a href="#람다식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="textmesh-pro"><span class="mr-2">TextMesh Pro</span><a href="#textmesh-pro" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="textmesh-pro의-필수-리소스-설치"><span class="mr-2">TextMesh Pro의 필수 리소스 설치</span><a href="#textmesh-pro의-필수-리소스-설치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="text---textmesh-pro"><span class="mr-2">Text - TextMesh Pro</span><a href="#text---textmesh-pro" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="textmesh-pro의-한글-처리"><span class="mr-2">TextMesh Pro의 한글 처리</span><a href="#textmesh-pro의-한글-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="ks-x-1001-규격의-한글-2350자"><span class="mr-2">KS X 1001 규격의 한글 2350자</span><a href="#ks-x-1001-규격의-한글-2350자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="생명-게이지-구현"><span class="mr-2">생명 게이지 구현</span><a href="#생명-게이지-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="정리-5"><span class="mr-2">정리</span><a href="#정리-5" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><br /></p><hr /><h1 id="-08장--게임-매니저">※ 08장 : 게임 매니저</h1><h2 id="적-캐릭터의-출현-로직"><span class="mr-2">적 캐릭터의 출현 로직</span><a href="#적-캐릭터의-출현-로직" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="spawnpointgroup-생성"><span class="mr-2">SpawnPointGroup 생성</span><a href="#spawnpointgroup-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="gamemanager-객체-생성"><span class="mr-2">GameManager 객체 생성</span><a href="#gamemanager-객체-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="invoke-invokerepeate-함수"><span class="mr-2">Invoke, InvokeRepeate 함수</span><a href="#invoke-invokerepeate-함수" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="싱글턴-디자인-패턴"><span class="mr-2">싱글턴 디자인 패턴</span><a href="#싱글턴-디자인-패턴" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="오브젝트-풀링"><span class="mr-2">오브젝트 풀링</span><a href="#오브젝트-풀링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="스코어-ui-구현"><span class="mr-2">스코어 UI 구현</span><a href="#스코어-ui-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="playerprefs를-활용한-스코어-저장"><span class="mr-2">Playerprefs를 활용한 스코어 저장</span><a href="#playerprefs를-활용한-스코어-저장" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="정리-6"><span class="mr-2">정리</span><a href="#정리-6" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><br /></p><hr /><h1 id="-09장--레이캐스트-활용">※ 09장 : 레이캐스트 활용</h1><h2 id="레이캐스트"><span class="mr-2">레이캐스트</span><a href="#레이캐스트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="drawray"><span class="mr-2">DrawRay</span><a href="#drawray" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="raycast-raycasthit"><span class="mr-2">Raycast, RaycastHit</span><a href="#raycast-raycasthit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="정리-7"><span class="mr-2">정리</span><a href="#정리-7" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><br /></p><hr /><h1 id="-10장--내비게이션-고급-기법">※ 10장 : 내비게이션 고급 기법</h1><h2 id="동적-장애물"><span class="mr-2">동적 장애물</span><a href="#동적-장애물" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="navmeshobstacle-component"><span class="mr-2">NavMeshObstacle Component</span><a href="#navmeshobstacle-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="off-mesh-link-generation"><span class="mr-2">Off Mesh Link Generation</span><a href="#off-mesh-link-generation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="사용자-정의-off-mesh-link"><span class="mr-2">사용자 정의 Off Mesh Link</span><a href="#사용자-정의-off-mesh-link" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="자연스러운-회전-처리"><span class="mr-2">자연스러운 회전 처리</span><a href="#자연스러운-회전-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="area-mask의-활용"><span class="mr-2">Area Mask의 활용</span><a href="#area-mask의-활용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="경로의-가중치"><span class="mr-2">경로의 가중치</span><a href="#경로의-가중치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="정리-8"><span class="mr-2">정리</span><a href="#정리-8" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><br /></p><hr /><h1 id="-11장--라이트매핑-및-라이트-프로브">※ 11장 : 라이트매핑 및 라이트 프로브</h1><h2 id="전역-조명"><span class="mr-2">전역 조명</span><a href="#전역-조명" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="조명-모드"><span class="mr-2">조명 모드</span><a href="#조명-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="realtime-모드"><span class="mr-2">Realtime 모드</span><a href="#realtime-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="mixed-모드"><span class="mr-2">Mixed 모드</span><a href="#mixed-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="baked-모드"><span class="mr-2">Baked 모드</span><a href="#baked-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="라이트매핑"><span class="mr-2">라이트매핑</span><a href="#라이트매핑" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="generate-lightmap-uvs-option"><span class="mr-2">Generate Lightmap UVs Option</span><a href="#generate-lightmap-uvs-option" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="lightmap-static-플래그"><span class="mr-2">Lightmap Static 플래그</span><a href="#lightmap-static-플래그" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="라이팅-뷰"><span class="mr-2">라이팅 뷰</span><a href="#라이팅-뷰" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="progressive-라이트매퍼"><span class="mr-2">Progressive 라이트매퍼</span><a href="#progressive-라이트매퍼" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="라이팅-뷰의-environment"><span class="mr-2">라이팅 뷰의 Environment</span><a href="#라이팅-뷰의-environment" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="baked-라이트매핑"><span class="mr-2">Baked 라이트매핑</span><a href="#baked-라이트매핑" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="라이트맵-베이크"><span class="mr-2">라이트맵 베이크</span><a href="#라이트맵-베이크" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="area-light-1"><span class="mr-2">Area Light</span><a href="#area-light-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="라이트-프로브"><span class="mr-2">라이트 프로브</span><a href="#라이트-프로브" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="light-probe-group"><span class="mr-2">Light Probe Group</span><a href="#light-probe-group" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="anchor-override"><span class="mr-2">Anchor Override</span><a href="#anchor-override" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="정리-9"><span class="mr-2">정리</span><a href="#정리-9" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><br /></p><hr /><h1 id="-12장--씬-관리">※ 12장 : 씬 관리</h1><h2 id="scene-분리"><span class="mr-2">Scene 분리</span><a href="#scene-분리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="scene-병합"><span class="mr-2">Scene 병합</span><a href="#scene-병합" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="multi-scene-edit"><span class="mr-2">Multi Scene Edit</span><a href="#multi-scene-edit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="정리-10"><span class="mr-2">정리</span><a href="#정리-10" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><br /></p><hr /><h1 id="-13장--오클루전-컬링">※ 13장 : 오클루전 컬링</h1><h2 id="컬링-방식"><span class="mr-2">컬링 방식</span><a href="#컬링-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="프리스텀-컬링"><span class="mr-2">프리스텀 컬링</span><a href="#프리스텀-컬링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="거리-비례에-의한-컬링"><span class="mr-2">거리 비례에 의한 컬링</span><a href="#거리-비례에-의한-컬링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="오클루전-컬링"><span class="mr-2">오클루전 컬링</span><a href="#오클루전-컬링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="오클루전-컬링-실습"><span class="mr-2">오클루전 컬링 실습</span><a href="#오클루전-컬링-실습" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="occluder-static-occludee-static"><span class="mr-2">Occluder Static, Occludee Static</span><a href="#occluder-static-occludee-static" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="정리-11"><span class="mr-2">정리</span><a href="#정리-11" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><br /></p><hr /><h1 id="-14장--input-system">※ 14장 : Input System</h1><h2 id="레거시-input-클래스"><span class="mr-2">레거시 Input 클래스</span><a href="#레거시-input-클래스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="새로운-input-system의-특징"><span class="mr-2">새로운 Input System의 특징</span><a href="#새로운-input-system의-특징" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="input-system의-구조"><span class="mr-2">Input System의 구조</span><a href="#input-system의-구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="input-system의-환경-설정"><span class="mr-2">Input System의 환경 설정</span><a href="#input-system의-환경-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="input-system-패키지-설치"><span class="mr-2">Input System 패키지 설치</span><a href="#input-system-패키지-설치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="active-input-handling"><span class="mr-2">Active Input Handling</span><a href="#active-input-handling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="테스트-환경-제작"><span class="mr-2">테스트 환경 제작</span><a href="#테스트-환경-제작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="input-action-에셋"><span class="mr-2">Input Action 에셋</span><a href="#input-action-에셋" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="control-schemes"><span class="mr-2">Control Schemes</span><a href="#control-schemes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="action-map-및-action-생성"><span class="mr-2">Action Map 및 Action 생성</span><a href="#action-map-및-action-생성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="바인딩-속성-설정"><span class="mr-2">바인딩 속성 설정</span><a href="#바인딩-속성-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="이동-동작의-바인딩-추가"><span class="mr-2">이동 동작의 바인딩 추가</span><a href="#이동-동작의-바인딩-추가" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="공격-동작의-액션과-바인딩-추가"><span class="mr-2">공격 동작의 액션과 바인딩 추가</span><a href="#공격-동작의-액션과-바인딩-추가" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="player-input-component"><span class="mr-2">Player Input Component</span><a href="#player-input-component" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="action-속성"><span class="mr-2">Action 속성</span><a href="#action-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="behavior-속성"><span class="mr-2">Behavior 속성</span><a href="#behavior-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="behavior---send-messages-option"><span class="mr-2">Behavior - Send Messages Option</span><a href="#behavior---send-messages-option" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="behavior---invoke-unity-events-option"><span class="mr-2">Behavior - Invoke Unity Events Option</span><a href="#behavior---invoke-unity-events-option" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="behavior---invoke-c-sharp-events"><span class="mr-2">Behavior - Invoke C Sharp Events</span><a href="#behavior---invoke-c-sharp-events" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="direct-binding"><span class="mr-2">Direct Binding</span><a href="#direct-binding" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="input-debug"><span class="mr-2">Input Debug</span><a href="#input-debug" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="정리-12"><span class="mr-2">정리</span><a href="#정리-12" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><br /></p><hr /><h1 id="-15장--포톤-클라우드를-활용한-네트워크-게임">※ 15장 : 포톤 클라우드를 활용한 네트워크 게임</h1></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/unity/'>Unity</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/unity/" class="post-tag no-text-decoration" >Unity</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%EC%9C%84%ED%82%A4%EB%B6%81%EC%8A%A4+%EC%A0%88%EB%8C%80%EA%B0%95%EC%A2%8C%21+%EC%9C%A0%EB%8B%88%ED%8B%B0+%EC%B1%85+%EB%94%B0%EB%9D%BC%EA%B0%80%EA%B8%B0+-+Ugee%27s+Tech+Blog&url=https%3A%2F%2Fugee0810.github.io%2F%2Fposts%2FUnity-SpaceShooter%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%EC%9C%84%ED%82%A4%EB%B6%81%EC%8A%A4+%EC%A0%88%EB%8C%80%EA%B0%95%EC%A2%8C%21+%EC%9C%A0%EB%8B%88%ED%8B%B0+%EC%B1%85+%EB%94%B0%EB%9D%BC%EA%B0%80%EA%B8%B0+-+Ugee%27s+Tech+Blog&u=https%3A%2F%2Fugee0810.github.io%2F%2Fposts%2FUnity-SpaceShooter%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fugee0810.github.io%2F%2Fposts%2FUnity-SpaceShooter%2F&text=%EC%9C%84%ED%82%A4%EB%B6%81%EC%8A%A4+%EC%A0%88%EB%8C%80%EA%B0%95%EC%A2%8C%21+%EC%9C%A0%EB%8B%88%ED%8B%B0+%EC%B1%85+%EB%94%B0%EB%9D%BC%EA%B0%80%EA%B8%B0+-+Ugee%27s+Tech+Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div><script src="https://utteranc.es/client.js" repo="Ugee0810/Ugee0810.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Algorithm-2/">Algorithm#02 | 버블 정렬(Bubble Sort)</a><li><a href="/posts/Algorithm-3/">Algorithm#03 | 삽입 정렬(Insertion Sort)</a><li><a href="/posts/Algorithm-1/">Algorithm#01 | 선택 정렬(Selection Sort)</a><li><a href="/posts/Algorithm-4/">Algorithm#04 | 퀵 정렬(Quick Sort)</a><li><a href="/posts/Unity-Event-2-Action/">Unity Event 2 - Action</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/diary/">Diary</a> <a class="post-tag" href="/tags/unity/">Unity</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a> <a class="post-tag" href="/tags/grammar/">Grammar</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/object-oriented-programming/">Object Oriented Programming</a> <a class="post-tag" href="/tags/sorting/">Sorting</a> <a class="post-tag" href="/tags/boj/">BOJ</a> <a class="post-tag" href="/tags/cordingtest/">CordingTest</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Data-Structure-01/"><div class="card-body"> <em class="small" data-ts="1662476400" data-df="ll" > Sep 7, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C# Data Structure#01 | Collections 자료구조 정리</h3><div class="text-muted small"><p> 자료구조의 중요성 자료구조는 데이터를 메모리에 저장하는것입니다. 데이터량이 많을 때 목적에 맞는 자료구조를 사용하지 않으면 엄청난 비용(속도, 메모리 낭비)의 손실을 가져오거나 심지어 프로그램, 서버가 다운될 수도 있습니다. 데이터가 빈번하게 추가되거나 선입선출 등의 우선순위가 있거나 특정 값(Key)로 데이터를 뽑아올 경우가 있거나 등의 목적에 ...</p></div></div></a></div><div class="card"> <a href="/posts/Grammar-01/"><div class="card-body"> <em class="small" data-ts="1662562800" data-df="ll" > Sep 8, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C# Grammar#01 | Switch</h3><div class="text-muted small"><p> Switch if - else 반복 줄임 가독성 높임 switch(n) 인수로는 기본적으로 정수와 문자를 넣을 수 있음 최근 C# 에서는 다른 타입의 객체도 넣을 수 있게끔 개선됐다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int choice = 0; switch(...</p></div></div></a></div><div class="card"> <a href="/posts/Grammar-02/"><div class="card-body"> <em class="small" data-ts="1662562800" data-df="ll" > Sep 8, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C# Grammar#02 | enum</h3><div class="text-muted small"><p> enum 열거형 -&amp;gt; 같은 종류의 상수 모음 상수나 변수를 사용하는 이유 상수 리터럴을 통한 하드 코딩은 그 의미를 알기 쉽지 않고 리팩토링이 어렵기 때문에. enum 열거형을 사용하는 이유 상수이므로 의미를 알기 쉽다. 연관된 것들을 하나의 enum 으로 묶기 때...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Diary-220903/" class="btn btn-outline-primary" prompt="Older"><p>22-09-03(토)</p></a> <a href="/posts/Diary-220904/" class="btn btn-outline-primary" prompt="Newer"><p>22-09-04(일)</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Ugee0810">송환욱(Song HwanUK)</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/diary/">Diary</a> <a class="post-tag" href="/tags/unity/">Unity</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a> <a class="post-tag" href="/tags/grammar/">Grammar</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/object-oriented-programming/">Object Oriented Programming</a> <a class="post-tag" href="/tags/sorting/">Sorting</a> <a class="post-tag" href="/tags/boj/">BOJ</a> <a class="post-tag" href="/tags/cordingtest/">CordingTest</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-5PMP919232"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-5PMP919232'); }); </script>
