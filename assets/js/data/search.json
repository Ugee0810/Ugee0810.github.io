[ { "title": "23-01-01(일)", "url": "/posts/Diary-230101/", "categories": "Diary, 2023.01", "tags": "Diary", "date": "2023-01-01 00:00:00 +0900", "snippet": "📝 오늘 할 일 Algorithm 알고리즘의 개요 Selection Sort Bubble Sort Insertion Sort Quick Sort ", "content": "📝 오늘 할 일 Algorithm 알고리즘의 개요 Selection Sort Bubble Sort Insertion Sort Quick Sort " }, { "title": "Algorithm#04 | 퀵 정렬(Quick Sort)", "url": "/posts/Algorithm-4/", "categories": "Algorithm, Sorting", "tags": "Algorithm, Sorting", "date": "2023-01-01 00:00:00 +0900", "snippet": " 🎓 동빈나님의 강의 실전 알고리즘 강좌 (Algorithm Programming Tutorial)를 듣고 정리한 내용입니다. 강의 보러 가기 💻 알고리즘퀵 정렬(Quick Sort) “특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누면 어떨까?” 퀵 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할하는 식으로 빠르게 정렬합니다. 더...", "content": " 🎓 동빈나님의 강의 실전 알고리즘 강좌 (Algorithm Programming Tutorial)를 듣고 정리한 내용입니다. 강의 보러 가기 💻 알고리즘퀵 정렬(Quick Sort) “특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누면 어떨까?” 퀵 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할하는 식으로 빠르게 정렬합니다. 더 쉽게 말하자면 특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤에 배열을 반으로 나눕니다. 퀵 정렬은 대표적인 ‘분할 정복’ 알고리즘으로 평균 속도가 O(N * logN)입니다.바로 한 번 예시를 통해서 살펴보도록 합시다. 일반적으로 퀵 정렬에서는 기준 값이 있습니다. 이를 피벗(Pivot)이라고도 하는데, 보통 첫 번째 원소를 피벗 값으로 설정하고 사용합니다. 다음과 같이 1이라는 값이 먼저 피벗 값으로 설정이 되었다고 생각해봅시다.(1) 10 5 8 7 6 4 3 2 9이 경우 1보다 큰 숫자를 왼쪽부터 찾고, 1보다 작은 숫자를 오른쪽부터 찾습니다. 이 때 1보다 큰 숫자로는 바로 10을 찾을 수 있고, 1보다 작은 숫자는 찾지 못해서 결국 1까지 도달합니다. 이 때 작은 값의 인덱스가 큰 값의 인덱스보다 작으므로 피벗 값과 작은 값의 위치를 바꿉니다. 즉, 1과 1을 교환하므로 제자리 걸음입니다.1 10 5 8 7 6 4 3 2 9따라서 위와 같이 구성되고, 이 때 피벗 값이었던 1의 왼쪽에는 1보다 작은 값이 존재하며 오른쪽에는 1보다 큰 값이 존재합니다. 이제 이어서 왼쪽과 오른쪽에서 퀵 정렬을 순환적으로 수행하는 겁니다.1 (10) 5 8 7 6 4 3 2 9이 때 왼쪽은 없으므로 무시하고, 오른쪽에서는 피벗 값으로 10이 채택됩니다. 10보다 큰 값을 왼쪽부터 찾고, 10보다 작은 값을 오른쪽부터 찾습니다. 큰 값은 찾지 못하게 되며 작은 값으로는 바로 9를 찾을 수 있습니다. 이 때 작은 값의 인덱스가 큰 값의 인덱스보다 작으므로 9와 10을 교환합니다.1 5 8 7 6 4 3 2 10따라서 위와 같이 구성되고, 이 때 피벗 값이었던 10의 왼쪽에는 10보다 작은 값이 존재하며 오른쪽에는 10보다 큰 값이 존재합니다. 이제 이어서 왼쪽과 오른쪽에서 퀵 정렬을 순환적으로 수행합니다.1 (5) 8 7 6 4 3 2 10이 때 오른쪽은 없으므로 무시하고, 왼쪽에서는 피벗 값으로 5가 채택됩니다. 5보다 큰 값을 왼쪽부터 찾고, 5보다 작은 값을 오른쪽부터 찾습니다. 큰 값으로는 8이 선택되고, 작은 값으로는 2가 선택됩니다. 이 때 작은 값의 인덱스가 큰 값의 인덱스보다 크므로 8과 2를 교환합니다.1 (5) 2 7 6 4 3 8 10이어서 큰 값과 작은 값을 바꾸어 다음과 같이 바뀝니다.1 (5) 2 3 6 4 7 8 10이어서 큰 값과 작은 값을 바꾸어 다음과 같이 바뀝니다.1 (5) 2 3 4 6 7 8 10이제 큰 값과 작은 값을 선택하면 각각 6과 4인데 작은 값의 인덱스가 큰 값의 인덱스보다 작으므로 피벗 값과 작은 값을 교환합니다. 따라서 다음과 같습니다.1 4 2 3 5 6 7 8 10이제 5를 기준으로 하여 5보다 작은 값은 왼쪽에 있고, 5보다 큰 값은 오른쪽에 있습니다. 이제 5의 왼쪽과 오른쪽에서 추가적으로 퀵 정렬을 수행합니다. 바로 다음과 같이 피벗값이 설정됩니다.1 (4) 2 3 5 (6) 7 8 10위와 같이 퀵 정렬을 순환적으로 수행하면 반으로 쪼개 들어가면서 분할 정복식으로 정렬이 완료됩니다. 이게 왜 빠른지 이해가 안 가시는 분은 직관적으로 다음과 같이 생각해보세요. 10 * 10은 100이지만 이를 전부 1개씩 나누게 되면 1 * 1을 10번 더한 값인 10에 불과합니다.1 2 3 4 5 6 7 8 9 10📝 문제다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.1 10 5 8 7 6 4 3 2 9✏️ 소스 코드#include &lt;stdio.h&gt;int number = 10;int data[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};void QuickSort(int * data, int start, int end){\tif (start &gt;= end)\t{ // 원소가 1개인 이유 \t\treturn;\t}\t\t// 키는 첫 번째 원소\tint key = start;\tint i = start + 1;\tint j = end;\tint temp;\t\twhile (i &lt;= j)\t{ // 엇갈릴 때 까지 반복 \t\twhile (data[i] &lt;= data[key])\t\t{ // 키 값보다 큰 값을 만날 때 까지 반복 \t\t\ti++;\t\t}\t\t\t\twhile (data[j] &gt;= data[key] &amp;&amp; j &gt; start)\t\t{ // 키 값보다 작은 값을 만날 때 까지 반복\t\t // &amp;&amp; 엇갈렸을 때 교체하게 되는데 왼쪽에 있는 값과 키 값을 교체해주기 때문에 start 이상으로 넘어오지 않게 한다. \t\t\tj--;\t\t}\t\t\t\tif (i &gt; j)\t\t{ // 현재 엇갈린 상태면 왼쪽 값과 키 값 변경 \t\t\t// Swaping\t\t\ttemp = data[j];\t\t\tdata[j] = data[key];\t\t\tdata[key] = temp;\t\t}\t\telse // 현재 엇갈린 상태가 아니라면 큰 값과 작은 값을 서로 변경 \t\t{\t\t\ttemp = data[j];\t\t\tdata[j] = data[i];\t\t\tdata[i] = temp;\t\t}\t\t\t\t// 똑같은 함수 안에 똑같은 함수를 호출함(재귀적 함수 구현) \t\t// 왼쪽 \t\tQuickSort(data, start, j - 1);\t\t// 오른쪽 \t\tQuickSort(data, j + 1, end);\t}}int main(void){\tQuickSort(data, 0, number - 1);\t\tfor (int i = 0; i &lt; number; i++)\t{\t\tprintf(\"%d \", data[i]);\t}}⏳ 시간 복잡도퀵 정렬의 시간 복잡도는 O(N * logN)입니다.위 소스코드를 보시면 ‘키 값보다 작은 값을 만날 때까지’ 반복하는 부분에서 j가 start보다 클 때에 한해서만 반복문이 수행되도록 처리되어 있습니다. 이는 항상 왼쪽에 있는 값과 피벗 값을 교환하기 때문입니다. 오른쪽에 있는 값은 피벗 값과 교환되지 않으므로 처리해 줄 필요가 없습니다. 퀵 정렬 알고리즘은 기본적으로 N번씩 탐색하되 반으로 쪼개 들어간다는 점에서 log N을 곱한 복잡도를 가집니다.하지만 퀵 정렬의 최악 시간 복잡도는 어떻게 될까요? 바로 O(N^2)입니다.흔히 알고리즘 대회에서 복잡도 O(N * logN)을 요구하는 경우 퀵 정렬을 이용하면 틀리기도 합니다. 도대체 왜 최악의 경우 시간 복잡도가 O(N^2)일까요? 이는 다음의 경우를 생각해보세요.📝 문제다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.1 2 3 4 5 6 7 8 9 10위와 같이 이미 정렬이 되어 있는 경우 퀵 정렬의 시간 복잡도는 O(N^2)에 가깝습니다. 반면에 이전 시간에 다루었던 삽입 정렬의 경우 위 문제를 매우 빠르게 풀어낼 수 있습니다. 즉 정렬할 데이터의 특성에 따라서 적절한 정렬 알고리즘을 사용하는 것이 중요하다는 것입니다.📚 참고 사이트 동빈나 블로그 동빈나 - 실전 알고리즘 강좌 (Algorithm Programming Tutorial)" }, { "title": "Algorithm#03 | 삽입 정렬(Insertion Sort)", "url": "/posts/Algorithm-3/", "categories": "Algorithm, Sorting", "tags": "Algorithm, Sorting", "date": "2023-01-01 00:00:00 +0900", "snippet": " 🎓 동빈나님의 강의 실전 알고리즘 강좌 (Algorithm Programming Tutorial)를 듣고 정리한 내용입니다. 강의 보러 가기 💻 알고리즘삽입 정렬(Insertion Sort) “각 숫자를 적절한 위치에 삽입하면 어떨까?” 삽입 정렬은 각 숫자를 적절한 위치에 삽입하는 방법으로 문제를 해결합니다. 다른 정렬 방식들은 무...", "content": " 🎓 동빈나님의 강의 실전 알고리즘 강좌 (Algorithm Programming Tutorial)를 듣고 정리한 내용입니다. 강의 보러 가기 💻 알고리즘삽입 정렬(Insertion Sort) “각 숫자를 적절한 위치에 삽입하면 어떨까?” 삽입 정렬은 각 숫자를 적절한 위치에 삽입하는 방법으로 문제를 해결합니다. 다른 정렬 방식들은 무조건 위치를 바꾸는 방식이었다면 삽입 정렬은 ‘필요할 때만’ 위치를 바꾸게 됩니다. 삽입 정렬은 비교적 느린 정렬 알고리즘에 속하지만 쉽게 생각할 수 없는, 조금은 복잡한 구조를 가지고 있습니다. 만약 데이터가 위와 같이 ‘거의 정렬된’ 상태라면 어떤 알고리즘이 가장 효율적일까요? 바로 지금 우리가 공부하고 있는 삽입 정렬입니다. 삽입 정렬은 필요할 때에 한해서만 삽입을 진행하기 때문에 데이터가 이미 거의 정렬된 상태에 한해서는 어떤 알고리즘보다도 빠르다는 특징을 가지고 있습니다.📝 문제다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.1 10 5 8 7 6 4 3 2 9✏️ 소스 코드#include &lt;stdio.h&gt;int main(void){\tint i, j, temp;\tint array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};\tfor (i = 0; i &lt; 9; i++)\t{// 첫 번째 원소는 이동하지 않으므로 총 원소 갯수의 -1만큼 반복\t\t// 정렬할 원소를 선택 적절한 위치에 삽입할 수 있도록 한다. \t\tj = i;\t\twhile (array[j] &gt; array[j + 1])\t\t{// j는 1씩 빼 나가면서 오른쪽 값과 비교해 왼쪽 값이 더 크다면 \t\t\t// Swaping\t\t\ttemp = array[j];\t\t\tarray[j] = array[j + 1];\t\t\tarray[j + 1] = temp;\t\t\tj--;\t\t}\t}\t\tfor(i = 0; i &lt; 10; i++)\t{\t\tprintf(\"%d \", array[i]);\t}\treturn 0;}⏳ 시간 복잡도삽입 정렬의 시간 복잡도는 O(N^2)입니다.삽입 정렬은 기본적으로 ‘정렬이 되어있다고 가정’을 한다는 점에서 특정한 경우에 따라 굉장히 빠른 속도를 자랑합니다.일단 소스코드상 반복문이 두 번 들어가있다는 점에서 복잡도는 O(N^2)입니다.📚 참고 사이트 동빈나 블로그 동빈나 - 실전 알고리즘 강좌 (Algorithm Programming Tutorial)" }, { "title": "Algorithm#02 | 버블 정렬(Bubble Sort)", "url": "/posts/Algorithm-2/", "categories": "Algorithm, Sorting", "tags": "Algorithm, Sorting", "date": "2023-01-01 00:00:00 +0900", "snippet": " 🎓 동빈나님의 강의 실전 알고리즘 강좌 (Algorithm Programming Tutorial)를 듣고 정리한 내용입니다. 강의 보러 가기 💻 알고리즘버블 정렬(Bubble Sort) “옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내면 어떨까?” 버블 정렬 또한 선택 정렬과 같이 몹시 직관적인 해결 방법입니다. 바로 가까이에 있...", "content": " 🎓 동빈나님의 강의 실전 알고리즘 강좌 (Algorithm Programming Tutorial)를 듣고 정리한 내용입니다. 강의 보러 가기 💻 알고리즘버블 정렬(Bubble Sort) “옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내면 어떨까?” 버블 정렬 또한 선택 정렬과 같이 몹시 직관적인 해결 방법입니다. 바로 가까이에 있는 두 숫자끼리 비교를 해서 당장 더 작은 숫자를 앞으로 보내주는 것을 반복하는 겁니다. 옆에 있는 값과 비교하여 더 작은 값을 반복적으로 앞으로 보내는 정렬 방법입니다. 구현은 가장 쉽지만 가장 비효율적인 알고리즘📝 문제다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.1 10 5 8 7 6 4 3 2 9✏️ 소스 코드#include &lt;stdio.h&gt;int main(void){\tint i, j, temp;\tint array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};\t\tfor (i = 0; i &lt; 10; i++)\t{// 원소의 개수만큼 반복\t\tfor(j = 0; j &lt; 9 - i; j++)\t\t{// 조건식이 \"&lt; 9 - i\"인 이유 -&gt; 반복마다 뒤에서부터 집합의 원소를 하나 씩 지우기 때문 \t\t\tif(array[j] &gt; array[j + 1])\t\t\t{ // 반복할 때 마다 당장 옆의 값과 비교하여 왼쪽의 값이 오른쪽의 값보다 크다면 \t\t\t\t// Swaping\t\t\t\ttemp = array[j];\t\t\t\tarray[j] = array[j + 1];\t\t\t\tarray[j + 1] = temp;\t\t\t}\t\t}\t}\t\tfor(i = 0; i &lt; 10; i++)\t{\t\tprintf(\"%d \", array[i]);\t}\treturn 0;}⏳ 시간 복잡도버블 정렬의 시간 복잡도는 O(N^2)입니다.📚 참고 사이트 동빈나 블로그 동빈나 - 실전 알고리즘 강좌 (Algorithm Programming Tutorial)" }, { "title": "Unity Lobby(유니티 로비 서비스, 멀티 플레이어)", "url": "/posts/Unity-Lobby/", "categories": "Unity", "tags": "Unity", "date": "2022-11-24 00:00:00 +0900", "snippet": "※ Practical Environment Unity Editor Version - 2021.3.14f1※ Intro유니티 로비 서비스(Unity Lobby service)로비 서비스를 사용하면 게임 세션 전이나 도중에 플레이어를 공개 또는 비공개 로비와 연결할 수 있습니다. 로비 서비스를 사용하여 게임 세션을 시작하기 전에 로비에서 플레이어를 함께...", "content": "※ Practical Environment Unity Editor Version - 2021.3.14f1※ Intro유니티 로비 서비스(Unity Lobby service)로비 서비스를 사용하면 게임 세션 전이나 도중에 플레이어를 공개 또는 비공개 로비와 연결할 수 있습니다. 로비 서비스를 사용하여 게임 세션을 시작하기 전에 로비에서 플레이어를 함께 그룹화하거나 호스트 플레이어를 사용할 수 없는 경우 연결 손실을 방지할 수 있습니다.로비는 플레이어가 게임 세션을 만들고 찾을 수 있도록 공개 로비 와 비공개 로비 를 사용하는 두 가지 주요 흐름을 제공 합니다. 다음은 각각의 기능입니다.   Public lobbies Private lobbies Discoverable via Query쿼리를 통해 검색 가능 Yes No Joinable by Quick Join빠른 참여로 참여 가능 Yes No Joinable by Id아이디로 가입 가능 Yes Yes Joinable by lobby code로비 코드로 가입 가능 Yes Yes 공공 로비(Public lobby)공개 로비를 사용하면 플레이어가 검색 매개변수에 맞는 공개 로비를 생성, 검색 및 참여할 수 있습니다.프라이빗 로비(Private lobby)비공개 로비에서는 플레이어가 로비 코드를 전송하여 다른 플레이어를 초대할 수 있습니다.빠른 가입(Quick Join)빠른 참여를 통해 플레이어는 최대한 빨리 게임 세션에 참여할 수 있습니다. 플레이어가 요구 사항을 지정하면 일치하는 로비(사용 가능한 경우)에 즉시 참가합니다. 또한 이 방법을 사용하여 간단한 매치메이킹을 구현하거나 플레이어가 진행 중인 게임에 참여하도록 할 수 있습니다.※ Apply로비 SDK 설치Lobby 서비스에 온보딩한 후 다음 단계는 Lobby SDK를 설치하여 에디터에서 사용할 수 있도록 하는 것입니다. com.unity.services.lobby 라는 Unity 패키지로 제공됩니다.Unity용 최신 Lobby 패키지를 설치하려면 Unity에서 Window &gt; Package Manager 로 이동합니다.Package Manager 에서 com.unity.services.lobby 를 검색 하거나 Unity Registry 를 스크롤하여 Lobby 패키지를 찾습니다.패키지를 선택하고 설치를 클릭합니다.인증(Authentication)로비 서비스를 사용하려면 Unity 인증 을 사용하여 본인 인증을 하십시오. Lobby SDK를 사용하여 호출하기 전에 인증 서비스를 초기화 하고 로그인해야 합니다. 많은 로그인 방법이 있지만 시작하는 가장 쉬운 방법은 익명 로그인입니다. 시작하려면 Unity 인증 익명 로그인 가이드 를 참조하세요.속도 제한(Rate limits)로비 서비스는 속도 제한을 사용하여 주어진 시간 내에 API가 수신하는 요청 수를 제한함으로써 네트워크 트래픽을 제어하는 ​​데 도움을 줍니다. 다음 표는 플레이어 및 서비스에 대한 로비 서비스의 각 요청 유형에 대한 속도 제한을 보여줍니다. 서비스는 훨씬 더 많은 제어가 허용되고 한 번에 여러 로비를 관리할 가능성이 높기 때문에 속도 제한이 더 완화됩니다. 요청 유형 속도 제한 서비스 속도 제한 Query for lobbies로비 쿼리 초당 요청 1개 초당 요청 100개 Create lobbies로비 만들기 6초당 요청 2개 6초당 요청 200개 Join lobbies로비에 참여 6초당 요청 2개 6초당 요청 200개 Quick Join lobbies빠른 참여 로비 10초당 요청 1개 10초당 요청 100개 Get lobbies로비 받기 초당 요청 1개 초당 요청 100개 Get joined lobbies로비에 참여하기 30초당 요청 1개 30초당 요청 1개 Get hosted lobbies호스팅 로비 받기 10초당 요청 1개 10초당 요청 1개 Delete lobbies대기실 삭제 초당 요청 2개 초당 요청 200개 Update lobbies로비 업데이트 5초당 요청 5개 5초당 요청 500개 Bulk update lobbies대량 로비 업데이트 해당 없음(금지됨) 초당 요청 1개 Leave lobbies or remove players로비를 나가거나 플레이어 제거 시 초당 5개 요청 초당 요청 500개 Update players플레이어 업데이트 5초당 요청 5개 5초당 요청 500개 Heartbeat lobbies하트비트 로비 30초당 요청 5개 30초당 요청 500개 Reconnect to lobby로비에 다시 연결 6초당 요청 2개 6초당 요청 200개 로비 관리(Manage lobbies) Unity Lobby Documentation로비 만들기, 로비 업데이트 등은 위의 문서 참조※ Reference Site Unity Lobby Documentation" }, { "title": "22-11-22(화)", "url": "/posts/Diary-221122/", "categories": "Diary, 2022.11", "tags": "Diary", "date": "2022-11-22 00:00:00 +0900", "snippet": "📝오늘 할 일 사람인 인적성검사 경주 RS232 가이드 만들어서 버스 가이드랑 합치기 신규 프로젝트 노션 일정, 프로필 정리 깃허브 연결 1차 팀 회의 개발 규칙(스크립팅, 버전 등) 역할 분류 ", "content": "📝오늘 할 일 사람인 인적성검사 경주 RS232 가이드 만들어서 버스 가이드랑 합치기 신규 프로젝트 노션 일정, 프로필 정리 깃허브 연결 1차 팀 회의 개발 규칙(스크립팅, 버전 등) 역할 분류 " }, { "title": "Unity AR Vuforia Model Target", "url": "/posts/Unity-AR-Vuforia-Model-Target/", "categories": "Unity", "tags": "Unity", "date": "2022-11-10 00:00:00 +0900", "snippet": "※ Practical Environment Unity Editor Version - 2021.3.11f1 Packages Vuforia Engine AR(10.11.3) ※ Intro※ Apply※ Vuforia SDK 다운로드 Vuforia SDK Download위 사이트에 들어가 회원가입 하고 유니티 SDK...", "content": "※ Practical Environment Unity Editor Version - 2021.3.11f1 Packages Vuforia Engine AR(10.11.3) ※ Intro※ Apply※ Vuforia SDK 다운로드 Vuforia SDK Download위 사이트에 들어가 회원가입 하고 유니티 SDK를 내려 받는다.※ 라이센스 추가뷰포리아 라이센스 키를 등록하지 않으면 어플리케이션 구동 시 타겟을 인식못하거나 아예 카메라가 구동하지 않을 수 있다고 합니다. Vuforia Licenses Page위 사이트 들어가서 새로운 프로젝트를 만들고 키 값 복사하기유니티 앱을 열어 Vuforia SDK를 설치했다면 아래의 사진처럼 나올 것이다. AR 카메라를 꺼낸다.이후 아래의 사진 따라 홈페이지에 있는 키 값을 붙여넣는다.이로써 기본 세팅은 완료 !※ 모델 타겟 생성 프로그램 설치 Vuforia Model Target Generator Download위 사이트에 들어가 알맞은 플랫폼 설치설치 후 로그인하면 위와 같은 화면이다. 체크해둔 곳을 클릭해 생성하거나 불러온다.이후 사용법은 아래의 링크 참고 Vuforia Developer Library - How to Create a Model Target※ 유니티로 타겟 모델링 가져오기먼저 유니티 프로젝트 상단에서 아래의 사진처럼 찾아가 임포트한다.생성기 프로그램에서 타겟을 생성했다면 Target Name/dataset 폴더에 유니티 패키지가 있을 것이다. 이를 임포트 한다.큐브를 생성하여 실제 사물과 트래킹 됐을 때 바운딩 될 수 있도록 테스트한다.실물 테스트가 끝났다면 바운딩 하려고 준비해둔 모델링 파일을 유니티에 가져온다.큐브 대신 들어가고 사이즈를 적절하게 조절하기이제 플랫폼을 변경해서 테스트해보면 성공할 것이다.혹시 고급 타겟 뷰를 사용하려면 아래의 문서를 참조하면 알 수 있다. 고급 모델 대상 데이터베이스※ Reference Site Augmented Startups - Vuforia Model Targets Tutorial in Unity 2020.1 - Iron Man AR Car Detection [Unity] 뷰포리아(Vuforia) SDK (1) - 설치 / 라이센스 키 등록" }, { "title": "22-11-07(월)", "url": "/posts/Diary-221107/", "categories": "Diary, 2022.11", "tags": "Diary", "date": "2022-11-07 00:00:00 +0900", "snippet": "📝오늘 할 일 Unity C# RS232 Serial 수신 후 TCP 송신 구현 // 수신 이벤트가 발생하면 이 부분이 실행void DataReceived(object sender, SerialDataReceivedEventArgs e){ //----- RS232 수신부 int RecvSize = m_RS23...", "content": "📝오늘 할 일 Unity C# RS232 Serial 수신 후 TCP 송신 구현 // 수신 이벤트가 발생하면 이 부분이 실행void DataReceived(object sender, SerialDataReceivedEventArgs e){ //----- RS232 수신부 int RecvSize = m_RS232Port/*PORT NAME*/.BytesToRead; string RecvStr = string.Empty; tmp_ReceivedData.text = string.Empty; // Recv Data가 있는 경우 if (RecvSize != 0) { byte[] buff = new byte[RecvSize]; // Size 만큼 Read m_RS232Port/*PORT NAME*/.Read(buff, 0, RecvSize); for (int i = 0; i &lt; RecvSize; i++) { // Hex 변환 RecvStr += \" \" + buff[i].ToString(\"X2\"); } tmp_ReceivedData.text += RecvStr; } //----- TCP 송신부 if (tmp_ReceivedData.text != string.Empty) { }} 코드 리뷰 내용 정리 Manager Singleton.cs(Design Pattern) GameManager.cs(UI, Event, Reset) ComboManager.cs(InGame) PanelManager.cs(InGame) TutorialManager.cs(Tutorial) AudioVizualization PlayHeadControls.cs(InGame) Firebase FirebaseAuthManager.cs(Account) LoginSystem.cs(Account) Keyboard ColorDataStore.cs(Keyboard) InputManager.cs(Keyboard) KeyboardButtonController.cs(Keyboard) KeyboardController.cs(Keyboard) KeyBoardSetManager.cs(Keyboard) Panel PanelCtrl.cs(InGame) PanelDestroyOnHover.cs(XRI) PanelEndLineDestroy.cs(Collider) PanelQuizObstacleTrigger.cs(Collider) QuizPanelA.cs(InGame, Quiz) QuizPanelQ.cs(InGame, Quiz) Prefabs MusicElements.cs(Prefab, Music List) ResultElements.cs(Prefab, Result List) G-Star Project 코드 Summary 설정 Bulid Test Algorithm 복습 - Selection Sort 학습 - Bubble Sort 학습 - Insertion Sort Blog 자기 소개란 수정 " }, { "title": "백준(BOJ) | 막대기(⚪️Ⅴ/1094)", "url": "/posts/S5-1094/", "categories": "CordingTest", "tags": "CordingTest, BOJ", "date": "2022-11-01 00:00:00 +0900", "snippet": "※ 문제 문제 링크 : 바로가기※ 풀이", "content": "※ 문제 문제 링크 : 바로가기※ 풀이" }, { "title": "C# Object Oriented Programming#04 | 은닉성(=캡슐화) + 프로퍼티와 get/set, 레코드, 무명형식", "url": "/posts/Object-Oriented-Programming-04/", "categories": "C#, 02.Object Oriented Programming", "tags": "C#, Object Oriented Programming", "date": "2022-11-01 00:00:00 +0900", "snippet": "※ 은닉성(=캡슐화) 클래스를 사용자에게 필요한 최소의 기능만 노출하고 내부를 감추는 것캡슐화가 잘 된 클래스의 특징 클래스의 이름만으로 제공하는 기능을 대략적으로 파악 가능 외부로 제공해야 할 기능만 노출접근 제한자 public : 클래스 안/밖 접근가능 protected : 클래스 안에서 접근가능. 파생 클래스에서는 접근 가능 priva...", "content": "※ 은닉성(=캡슐화) 클래스를 사용자에게 필요한 최소의 기능만 노출하고 내부를 감추는 것캡슐화가 잘 된 클래스의 특징 클래스의 이름만으로 제공하는 기능을 대략적으로 파악 가능 외부로 제공해야 할 기능만 노출접근 제한자 public : 클래스 안/밖 접근가능 protected : 클래스 안에서 접근가능. 파생 클래스에서는 접근 가능 private : 클래스 안에서 접근가능 internal : 같은 어셈블리에 있는 코드에서 public, 다른 어셈블리에 대해 private protected internal : 같은 어셈블리에 있는 코드에서 protected, 다른 어셈블리에 대해 private private protected : 같은 어셈블리에 있는 클래스에서 상속받은 클래스 내부에서만 접근가능이하 접근 제한자로 수식하지 않은 멤버는 private로 지정됨(생략 가능).NET에서의 어셈블리 : EXE 또는 DLL 형식의 C#파일.일반적으로 1개의 파일 (EXE/DLL모듈)로 구성된 어셈블리 사용.getter / setter일반적으로 필드는 public으로 설정하지 않음. 대신 getter, setter를 통해 접근아래 코드는 메소드로 선언된 형태의 getter와 setter를 보인다.namespace FirstProgram { class Something { private int a = 5; public int getA() { return a; } public void setA(int a) { this.a = a; } } class Program { static void Main(string[] args) { Something some = new Something(); Console.WriteLine(some.getA()); // 5 some.setA(10); Console.WriteLine(some.getA()); // 10 } }}※ 프로퍼티(property)프로퍼티를 활용한 getter, setter의 재정의아래 코드는 property문법을 활용한 getter와 setter를 보인다.namespace FirstProgram { class Something { private int a = 5; public int A { get { return a; } set { a = value; } // 암묵적으로 매개변수를 value로 정함 } } class Program { static void Main(string[] args) { Something some = new Something(); Console.WriteLine(some.A); // get / 출력 5 some.A = 53; Console.WriteLine(some.A); // get / 출력 53 } }}자동구현 프로퍼티아래 코드는 위 코드의 class Something과 동일한 내용이다. class Something { public int A { get; set; } = 5; }프로퍼티를 활용한 초기화객체 생성시 프로퍼티 문법으로 초기화할 수 있다.namespace FirstProgram { class Something { public int A { get; set; } = 0; } /* 자동구현 프로퍼티가 아닌 프로퍼티에도 동작함 class Something { private int a = 0; public int A { get { return a; } set { a = value; } } } */ class Program { static void Main(string[] args) { // Something some = new Something &lt;-- 생성자 명시적호출 안해도 된다. Something some = new Something() { A = 535353 }; Console.WriteLine(some.A); // 535353 some.A = 53; Console.WriteLine(some.A); // 53 } }}초기화 전용 자동 구현 프로퍼티어떤 프로퍼티가 초기화 이후 값이 변경되지 않도록 설정할 수 있다.set 대신 init이 들어간 경우, set 하려고 하면 컴파일에러 발생오류 CS8852 초기값 전용 속성 또는 인덱서 'Something.Strstr'은(는) 개체 이니셜라이저 또는 인스턴스 생성자나 'init' 접근자의 'this' 또는 'base'에만 할당할 수 있습니다.namespace Program { class Something { public string Strstr { get; init; } public int Intint { get; init; } } class Program { static void Main(string[] args) { Something some1 = new Something() { Strstr = \"one\", Intint = 1 }; Something some2 = new Something() { Strstr = \"two\", Intint = 2 }; Something some3 = new Something() { Strstr = \"three\", Intint = 3 }; Console.WriteLine($\"{some1.Strstr,-10} {some1.Intint}\"); // one 1 Console.WriteLine($\"{some2.Strstr,-10} {some2.Intint}\"); // two 2 Console.WriteLine($\"{some3.Strstr,-10} {some3.Intint}\"); // three 3 // compile error occurs // some1.Strstr = \"set set\"; } }}※ 레코드(record) class와 비슷하게 생긴 것으로 record가 있다. 값을 담는 용도의 클래스처럼 활용할 수 있다. 컴파일 시에 복사, 비교, 출력을 위한 기본 생성 코드(메소드)가 추가된다.record를 .Equals로 비교하면 값을 비교한다.with {}로 일부 프로퍼티의 값을 바꾸어 깊은복사할 수 있다.namespace Program { class ClassSomething { public string Strstr { get; init; } public int Intint { get; init; } } record RecordSomething { public string Strstr { get; init; } public int Intint { get; init; } } class Program { static void Main(string[] args) { ClassSomething c1 = new ClassSomething() { Strstr = \"one\", Intint = 1 }; ClassSomething c2 = new ClassSomething() { Strstr = \"one\", Intint = 1 }; Console.WriteLine($\" {\"class\",-10} {c1.Strstr,-10} {c1.Intint}\");// class one 1 Console.WriteLine($\" {\"class\",-10} {c2.Strstr,-10} {c2.Intint}\"); // class one 1 Console.WriteLine(c1.Equals(c2)); // False : 주소값 비교 RecordSomething r1 = new RecordSomething() { Strstr = \"two\", Intint = 2 }; RecordSomething r2 = new RecordSomething() { Strstr = \"two\", Intint = 2 }; Console.WriteLine($\" {\"record\", -10} {r1.Strstr,-10} {r1.Intint}\");// record two 2 Console.WriteLine($\" {\"record\",-10} {r2.Strstr,-10} {r2.Intint}\"); // record two 2 Console.WriteLine(r1.Equals(r2)); // True : 프로퍼티 값 비교 RecordSomething r3 = r1; RecordSomething r4 = r1 with { Strstr = \"another\" }; // r1을 깊은복사하고 Strstr값을 바꿈 Console.WriteLine($\" {\"record\",-10} {r1.Strstr,-10} {r1.Intint}\");// record two 2 Console.WriteLine($\" {\"record\",-10} {r3.Strstr,-10} {r3.Intint}\");// record two 2 Console.WriteLine($\" {\"record\",-10} {r4.Strstr,-10} {r4.Intint}\");// record another 2 } }}※ 무명형식형식의 선언과 동시에 객체를 할당한다.무명형식의 프로퍼티에 할당된 값은 읽기전용이다.namespace Program { class Program { static void Main(string[] args) { var anonymous = new { Name = \"wonjin\", Jobs = new string[] { \"Student\", \"Labeler\", \"Developer\" } }; Console.WriteLine($\"{anonymous.Name} {anonymous.Jobs}\"); // wonjin System.String[] foreach (var job in anonymous.Jobs) { Console.Write($\"{job} \"); // Student Labeler Developer } } }}※ 참고 사이트 공부하는 식빵맘 yiwonjin - C#프로그래밍 07 : 은닉성(캡슐화) + 프로퍼티, 레코드 어셈블리의 뜻과 접근제한자에 대한 설명 C# 프로퍼티 사용하는 이유 개체 이니셜라이저를 사용하여 생성자 명시적호출 없이 프로퍼티 초기화 Class의 Equals() 메소드가 참조를 비교한다고 판단한 근거 C# 9 record에 대한 토론" }, { "title": "C# Object Oriented Programming#03 | 상속성, sealed 키워드, 부모/자식 클래스 형식변환, is/as 연산자, object", "url": "/posts/Object-Oriented-Programming-03/", "categories": "C#, 02.Object Oriented Programming", "tags": "C#, Object Oriented Programming", "date": "2022-11-01 00:00:00 +0900", "snippet": "※ 상속클래스는 다른 하나의 클래스로부터 유산을 물려받을 수 있음 (=상속받을 수 있음)다중상속은 지원하지 않는다. (동시에 2개 이상의 클래스를 상속받는 것) 부모 클래스(기반 클래스) : 상속해주는 클래스 자식 클래스(파생 클래스) : 상속 받는 클래스namespace Program { public class Person { ...", "content": "※ 상속클래스는 다른 하나의 클래스로부터 유산을 물려받을 수 있음 (=상속받을 수 있음)다중상속은 지원하지 않는다. (동시에 2개 이상의 클래스를 상속받는 것) 부모 클래스(기반 클래스) : 상속해주는 클래스 자식 클래스(파생 클래스) : 상속 받는 클래스namespace Program { public class Person { public string Gender { get; set; } = \"Unknown\"; public string doubleStr (string str) { return $\"{str}{str}\"; } } public class Student : Person // Person클래스를 상속 { public string Dept { get; set; } = \"Unknown\"; public int Grade { get; set; } = 0; } class Program { static void Main(string[] args) { Person person = new Person() { Gender = \"female\" }; Console.WriteLine(person.Gender); // female Console.WriteLine(person.doubleStr(person.Gender)); // femalefemale Student student = new Student() { Gender = \"male\", Dept = \"CE\", Grade = 2 }; Console.WriteLine(student.Gender); // male Console.WriteLine(student.doubleStr(student.Dept)); // CECE Console.WriteLine(student.Grade); // 2 } }}※ sealed 키워드sealed 키워드를 붙여 클래스가 상속되지 않도록 하거나, 메소드가 자식클래스에서 오버라이드 되지 않도록 할 수 있다.클래스 상속 제한아래 코드는 sealed설정된 클래스를 상속하려고 해 오류가 발생한다.오류 CS0509 'Wonjin': sealed 형식 'Student'에서 파생될 수 없습니다.public class Person{ public string Gender { get; set; } = \"Unknown\"; public string doubleStr (string str) { return $\"{str}{str}\"; }}public sealed class Student : Person // Person클래스를 상속{ public string Dept { get; set; } = \"Unknown\";}class Wonjin : Student // &lt;-- 컴파일오류 CS0509{ // something}메소드 오버라이드 제한virtual 메소드를 오버라이드한 메소드의 오버라이드를 제한할 수 있다.아래 코드는 sealed 설정된 메소드를 오버라이드 하려 시도해 컴파일 오류가 발생한다.CS0239 'Wonjin.SaySomething(string)': 상속된 'Student.SaySomething(string)' 멤버는 봉인되어 있으므로 재정의할 수 없습니다.※ 부모/자식 클래스 형식변환 부모에 자식 대입 (암시적변환) 자식에 부모 대입 (명시적변환) : 런타임에러 발생 가능암시적 형변환암시적 형변환은 메소드 오버로드의 대안으로 사용할 수 있다.이 때, 부모 클래스의 배열은 자식 클래스를 원소로 가질수 있다.namespace Program{ class SayMachine { public void SayGender(Person obj) { obj.SaySomething(obj.Gender); } } class Person { public string Gender { get; set; } = \"Unknown\"; public void SaySomething(string str) { Console.WriteLine(str); } } class Student : Person { public string Dept { get; set; } = \"CE\"; } class Wonjin : Student { public string Name { get; set; } = \"wonjinLee\"; } class Program { static void Main(string[] args) { Student student = new Student() { Gender = \"female\" }; Wonjin wonjin = new Wonjin() { Gender = \"male\" }; Person[] persons = new Person[] { student, wonjin }; SayMachine sayMachine = new SayMachine(); foreach (Person person in persons) { sayMachine.SayGender(person); // female // male } } }}※ is, as 연산자as 연산자형식변환 연산자와 동일하게 동작하나, 변환 실패 시 런타임 에러가 발생하지 않음. 대신 객체 참조에 null 대입.is 연산자객체가 해당 형식이 맞는지 검사하여 true, false 반환class Person { public string Gender { get; set; } = \"Unknown\";}class Student : Person { public string Dept { get; set; } = \"Unknown\";}class Wonjin : Student { public string Name { get; set; } = \"Unknown\";}class Program { static void Main(string[] args) { Person person1 = new Person(); Person person2 = new Student(); Student student = new Student(); Wonjin wonjin = new Wonjin(); // as연산자 student = person1 as Student; // person1객체를 Student클래스로 형변환 if(student != null) { /* 여긴 올일이없다*/ } else { Console.WriteLine(\"student는 null\"); // 출력됨 } student = person2 as Student; // person2객체를 Student클래스로 형변환 if (student != null) { Console.WriteLine(\"student는 person2\"); // 출력됨 } else { /* 여긴 올일이없다*/ } // is연산자 if (person2 is Wonjin) { /* 여긴 올일이없다*/ } if (wonjin is Person) { Console.WriteLine(\"wonjin은 Person\"); // 출력됨 } }}※ 부모/자식 클래스 생성자, 종료자자식클래스를 생성한 경우, 아래 순서로 실행된다. 부모클래스의 생성자 실행 자식클래스의 생성자 실행 자식클래스의 종료자 실행 부모클래스의 종료자 실행class Person{ public Person (int a) { Console.WriteLine($\"Person 생성자, 매개변수 a = {a}\"); } ~Person () { Console.WriteLine(\"Person 종료자\"); }}class Student : Person{ public Student(int a, int b) : base(a) { Console.WriteLine($\"Student 생성자, 매개변수 b = {b}\"); } ~Student() { Console.WriteLine(\"Student 종료자\"); }}class Program{ static void Test() { Student student = new Student(53, 53535353); } static void Main(string[] args) { Test(); GC.Collect(); GC.WaitForPendingFinalizers(); /* Person 생성자, 매개변수 a = 53 Student 생성자, 매개변수 b = 53535353 Student 종료자 Person 종료자 */ }}※ objectobject 클래스는 모든 클래스의 부모이다.아래 코드와 같이 Object클래스로 정의되어있다.public class Object{ public virtual bool Equals(); public virtual int GetHashCode(); public Type GetType(); public virtual string ToString();}※ 참고 사이트 yiwonjin - C#프로그래밍 08 : 상속성" }, { "title": "C# Object Oriented Programming#02 | 생성자, static", "url": "/posts/Object-Oriented-Programming-02/", "categories": "C#, 02.Object Oriented Programming", "tags": "C#, Object Oriented Programming", "date": "2022-11-01 00:00:00 +0900", "snippet": "※ 생성자 객체를 new로 생성함과 동시에 멤버 값들을 원하는대로 초기화하고 싶을 때 생성자 호출 클래스 이름과 같아야 함 리턴타입, 매개변수 ❌ 접근 제한자 ⭕public Knight(){ hp = 100; attack = 10;}public Knight(int hp) : this(){ this.hp = hp;} 생성자 이름...", "content": "※ 생성자 객체를 new로 생성함과 동시에 멤버 값들을 원하는대로 초기화하고 싶을 때 생성자 호출 클래스 이름과 같아야 함 리턴타입, 매개변수 ❌ 접근 제한자 ⭕public Knight(){ hp = 100; attack = 10;}public Knight(int hp) : this(){ this.hp = hp;} 생성자 이름 옆에 : this() 붙여 ‘디폴트 생성자 호출해줘’ 라는 의미 this.hp = hp를 실행하기 전에 Knight()를 호출하여 hp = 100와 attack = 10 를 먼저 실행하게 된다. 자연스럽게 Knight(int hp) 생성자에서 hp 값만 설정헀어도 attack = 10 으로 설정이 미리 된다. ※ staticstatic 이 아닌 일반 멤버들 종속된 객체 인스턴스들 마다 메모리가 별개다. 같은 클래스 타입이라도 객체들은 서로 속성값도 다를 수 있으며 별개의 존재이다. static 이 아닌 일반 멤버 변수, 함수들은 객체에 종속된다. static 멤버 변수, 멤버 함수 static인 멤버 메모리를 같은 타입의 모든 객체들이 공유 한다. 따라서 오직 해당 멤버가 전체 메모리 상에서 단 1 개만 존재한다. 객체에 종속되지 않는다. 따라서 객체 생성 후 객체 이름으로 호출하는 것이 아닌 클래스 이름으로 호출한다. 객체 생성할 필요가 없다. static 함수 내에선 특정 일반 객체 멤버를 사용할 수 없다. 공용 함수니까 애당초 어떤 객체의 멤버를 사용해야 하는지 알 수 없기 때문에 그렇다고 아예 못 쓴다는 것은 아니고 함수 바깥의 어떤 특정 일반 객체 멤버를 사용할 수 없다는 것 뿐이다. 예를 들면 this같이… 예를 들어 static함수 내부에서 아예 새롭게 객체를 만들고 이를 리턴하는 작업은 가능하다. static public void Test(){ this.id = 23; // ❌ 에러! 특정 객체 멤버는 사용할 수 없음 hp = 100; // ❌ 에러! 특정 객체 멤버는 사용할 수 없음}static public Knight CreateKnight() // 문제 없음. 가능. ⭕{ Knight knight = new Knight(); knight.hp = 100; knight.attack = 1; return knight;} static 함수 내에선 일반 멤버는 사용할 수 없고 static 멤버 변수만 사용할 수 있다. Console 클래스에 있는 static 함수인 WriteLine() -&gt; Console.WriteLine(\"a\"); ※ 참고 사이트 공부하는 식빵맘" }, { "title": "C# Object Oriented Programming#01 | 객체 지향, 복사와 참조, 스택과 힙", "url": "/posts/Object-Oriented-Programming-01/", "categories": "C#, 02.Object Oriented Programming", "tags": "C#, Object Oriented Programming", "date": "2022-11-01 00:00:00 +0900", "snippet": "※ 객체 지향의 특징 및 절차 지향과 차이점 절차 지향 - 코드가 전부 함수로 구성. 프로그램 규모가 커지면 복잡해진다.(유지 보수 면에서 불리) 함수 호출 순서에 종속적이기 때문에 호출 순서 타고타고 올라가 보며 코드를 읽어보아야 해서 불편하다. 함수를 계속 새로 만들...", "content": "※ 객체 지향의 특징 및 절차 지향과 차이점 절차 지향 - 코드가 전부 함수로 구성. 프로그램 규모가 커지면 복잡해진다.(유지 보수 면에서 불리) 함수 호출 순서에 종속적이기 때문에 호출 순서 타고타고 올라가 보며 코드를 읽어보아야 해서 불편하다. 함수를 계속 새로 만들고 만들고 해야해서 복잡하다. 같은 Fight 이라도 플레이어 vs 플레이어, 보스 vs 플레이어 등등 많은 버전이 있어야 하므로 오버로딩을 많이 해야 해서 복잡해진다. 객체 지향 - 모든 것을 객체 위주로 생각. 속성(멤버 변수)와 기능(멤버 함수)로 나뉜다. ‘플레이어’의 이름, 공격력, HP, 직업 같은 속성들과 Fight 같은 기능을 추상화 하여 Player라는 이름의 클래스로 묶는다. 이 클래스(붕어빵틀, 설계도)를 가지고 세상에 존재하는 객체(실제 붕어빵)로 찍어낼 수 있다. class Knight{ public int hp; public int attack; public void Move() { Console.Write(\"Kight Move\"); } public void Attack() { Console.Write(\"Kight Attack\"); }}class Program{ static void Main(string [] args) { Knight knight = new Knight(); knight.hp = 100; knight.attack = 10; knight.Move(); knight.Attack(); }} Knight 클래스 = 설계도 속성 : hp, attack -&gt; 실존하는 모든 Knight 타입 객체들은 이 속성을 가진다. 기능 : Move(), Attack() -&gt; 실존하는 모든 Knight 타입 객체들은 이 기능을 가진다. 클래스는 단순 설계도일 뿐 이 클래스로 찍어낸 Knight 객체들은 속성 값이 제각각 다를 수 있다. new C++과 달리 C# 에선 객체 생성시 new를 사용하여 생성해야 한다. Kignt knight만으로는 메모리 할당이 되어 있지 않아 객체 생성이 안됨 ※ 복사와 참조구조체와 클래스의 차이구조체(Struct) -&gt; Call by Value 방식으로 작업한다. (복사) 예를 들어 이름이 mage인 Mage타입의 구조체(Struct)가 있다면 Mage mage2 = mage 하여도 mage와 mage2는 별개의 메모리다. mage2는 mage의 값들을 깊은 복사해 온 사본일 뿐이다. 객체와 달리 구조체는 Mage mage; 만 해도 메모리가 할당이 된다.클래스(Class) -&gt; Call by Reference 방식으로 작업한다. (참조) 예를 들어 이름이 knight인 Knight 클래스 타입의 객체가 있다면 Knight knight2 = knight 하면 knight2와 knight는 동일한 메모리를 참조하게 된다. 즉 이 둘은 동일한 객체를 접근하다. 데이터를 복사해준 것이 아닌 얕은 복사하여 동일한 객체에 대한 주소를 내부적으로 복사해준 것 뿐이다. C++로 따지면 두 변수가 동일한 메모리에 소유권을 모두 가지도록 shared_ptr를 만들고 리턴해준 상황과 같다. C#에선 Knight knight;만으로는 메모리 할당이 되지 않는다. new를 사용하여야 메모리가 할당이 된다.(=실존하게 된다.) new를 사용하여 할당했다는 것은 힙 메모리에 동적으로 할당 받았다는 것이다. C# 에서 클래스 객체는 C++과 달리 무조건 힙 메모리에 올라간다. C++은 구조체나 클래스 객체나 다 스택, 힙 양쪽 다 사용이 가능하다. 힙과 다르게 스택 메모리는 유효 범위가 계속 달라지므로 스택의 주소를 참조하는건 좀 위험한 일이다. 객체 복사시 참조가 아닌 깊은 복사를 하고 싶다면새로운 별개의 객체를 생성하여 자기 자신의 속성 값들을 복사하고 이를 리턴하는 함수 Clone()을 만든다. 직접 Call by Value (복사)를 구현하는 방식.class Knight { public int hp; public int attack; public Knight Clone() { Knight knight = new Knight(); knight.hp = hp; knight.attack = attack; return knight; } public void Move() { Console.Write(\"Kight Move\"); } public void Attack() { Console.Write(\"Kight Attack\"); } } ... // knight을 깊은 복사하여 knight2을 만든다. 두 객체는 별개의 객체이다. Knight knight2 = knight.Clone();※ 스택과 힙스택(Stack) 메모리 불완전하고 일시적으로 사용하는 메모리(=메모장) 함수 내부에서만 살아 있다가 함수 끝나면 사라지는 지역 변수, 연쇄적인 함수들의 호출 위치 등등 잠깐 있다 사라질 것들은 스택 메모리에 올라온다. 스택 자료구조처럼 쌓이는 구조고 가장 나중에 쌓인게 가장 먼저 빠진다.(=FIFO, 선입선출) 반면에 객체와 같은 Call by Reference 는 스택 메모리에 그 데이터 자체가 아닌 그 데이터가 있는 주소가 올라간다. 실제 데이터는 힙 메모리에 있다. 즉 스택 메모리에 저장되는건 본체 데이터가 위치한 힙 메모리의 주소다. 힙(Heap) 메모리 new 등등 프로그램 실행 中 실시간으로 할당 된 것들이 올라간다. 실행 전부터 메모리를 잡고 실행하는 것이 아니라 프로그램 실행 중에 그때 그때 필요한 메모리를 할당할 땐 힙 메모리에서 가져다 쓴다. 특별히 해제해주는 작업이 없다면 프로그램 내내 힙 메모리에 안정적으로 남아있게 된다. C++ 에선 개발자가 반드시 직접 delete 로 일일이 해제 해주어 힙 메모리 누수를 막아야 했었다. C# 에선 아무도 참조하지 않고 자리만 차지하는 힙 메모리는 C# 시스템 자체의 GC(가비지 콜렉터)가 알아서 해제해준다. Call by Reference 를 실현하는 ref 변수가 참조하는 데이터는 스택 메모리일 수도 있다. ref int a 에서 참조하는 메모리는 스택 메모리 일 수도 있는 것. a엔 참조 중인 스택 메모리의 주소가 스택 메모리에 속한 a에 올라가게 된다. Call by Reference 라고 해서 무조건 힙에 저장되는건 아니라는 것이다. 착각하지 말기! ※ 참고 사이트 공부하는 식빵맘" }, { "title": "Algorithm#01 | 선택 정렬(Selection Sort)", "url": "/posts/Algorithm-1/", "categories": "Algorithm, Sorting", "tags": "Algorithm, Sorting", "date": "2022-11-01 00:00:00 +0900", "snippet": " 🎓 동빈나님의 강의 실전 알고리즘 강좌 (Algorithm Programming Tutorial)를 듣고 정리한 내용입니다. 강의 보러 가기 💻 알고리즘선택 정렬(Selection Sort) “가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘” 가장 원시적이고 기초적인 방법 중 하나📝 문제다음의 숫자들을 오름차순으로 정렬하는 프로...", "content": " 🎓 동빈나님의 강의 실전 알고리즘 강좌 (Algorithm Programming Tutorial)를 듣고 정리한 내용입니다. 강의 보러 가기 💻 알고리즘선택 정렬(Selection Sort) “가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘” 가장 원시적이고 기초적인 방법 중 하나📝 문제다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.1 10 5 8 7 6 4 3 2 9✏️ 소스 코드#include &lt;stdio.h&gt;int main(void){\tint\ti, j, /*배열에 있는 원소를 반복적으로 탐색하기 위한 필드*/\tmin, /*최솟값(가장 작은 원소를 선택하기 위한 필드)*/\tindex, /*가장 작은 원소가 존재하는 위치*/\ttemp; /*특정한 두 숫자를 서로 바꾸기 위한 필드*/\t// 탐색할 원소 배열\tint array[10] = { 1, 10, 5, 8, 7, 6, 4, 3, 2, 9 };\tfor (i = 0; i &lt; 10; i++)\t{\t\t// 아주 큰 값을 넣는 이유 : 항상 최솟값을 선택하기 위해 탐색할 모든 원소들 보다 커야한다.\t\tmin = 9999;\t\tfor (j = i; j &lt; 10; j++)\t\t{\t\t\t// 최솟값 고르기\t\t\tif (min &gt; array[j])\t\t\t{\t\t\t\tmin = array[j];\t\t\t\tindex = j;\t\t\t}\t\t}\t\t// 스와핑을 한다.\t\ttemp = array[i];\t\tarray[i] = array[index];\t\tarray[index] = temp;\t}\t// 정렬 확인\tfor (i = 0; i &lt; 10; i++)\t{\t\tprintf(\"%d \", array[i]);\t}}⏳ 시간 복잡도선택 정렬의 시간 복잡도는 O(N^2)입니다.중요한 것은 데이터의 갯수가 N개일 때 총 몇 번의 비교 연산을 해야 되는지입니다. 선택 정렬은 대략 N * (N + 1) / 2 번 가량의 연산을 수행해야 합니다. 이를 컴퓨터에서는 가장 큰 차수인 N^2만 보고 O(N^2)이라고 표현하곤 합니다.1 2 3 4 5 6 7 8 9 1010 + 9 + 8 + 7 + ... + 1=&gt; 10 * (10 + 1) / 2 = 55=&gt; N = (N + 1) / 2 &lt;--- 일반적으로 컴퓨터에선 N이 매우 크다는 가정 하에 간단하게 나누거나 더하는 연산들은 무시합니다.=&gt; N * N=&gt; O(N * N)(=O(N^2))다시 말해 정렬해야 할 데이터의 갯수가 10,000 개라면 대략 일 억 번 정도 계산을 한다고 가정을 하겠다는 의미입니다. 실제로 이 정도의 시간 복잡도를 가지는 선택 정렬이 효율적인지, 그리고 현실 세계의 정렬 상황에서 효과적으로 사용될 수 있을지 고민해보는 시간을 가져봅시다.📚 참고 사이트 동빈나 블로그 동빈나 - 실전 알고리즘 강좌 (Algorithm Programming Tutorial)" }, { "title": "Algorithm#00 | 알고리즘의 개요 및 실습 환경 설치하기", "url": "/posts/Algorithm-0/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-11-01 00:00:00 +0900", "snippet": " 🎓 동빈나님의 강의 실전 알고리즘 강좌 (Algorithm Programming Tutorial)를 듣고 정리한 내용입니다. 강의 보러 가기 알고리즘의 개요 알고리즘이란 ‘문제를 해결하는 절차’입니다. 알고리즘은 입력, 출력, 유한성, 명백성, 효과성을 만족해야 합니다. 알고리즘은 분석을 통해 좋고 나쁨을 평가할 수 있습...", "content": " 🎓 동빈나님의 강의 실전 알고리즘 강좌 (Algorithm Programming Tutorial)를 듣고 정리한 내용입니다. 강의 보러 가기 알고리즘의 개요 알고리즘이란 ‘문제를 해결하는 절차’입니다. 알고리즘은 입력, 출력, 유한성, 명백성, 효과성을 만족해야 합니다. 알고리즘은 분석을 통해 좋고 나쁨을 평가할 수 있습니다. 알고리즘은 기초 프로그래밍과 자료구조를 공부한 이후에 배우면 좋습니다. 알고리즘은 논리이며 수학이고 실질적인 개발에 적용되는 기초적인 아이디어입니다. 알고리즘은 실제 개발의 전체 과정에서 사용됩니다. 실제 프로그램을 개발할 때 효율적인 알고리즘을 적용함으로써 원하는 결과를 도출해야 합니다. 스케줄 관리 프로그램 : 달력에서 특정한 달에 해당하는 일 수는 어떻게 구할까? 내비게이션 프로그램 : 여러 개의 중간 지점을 거쳐서 특정 지점으로 갈 때 가장 빠른 길은 무엇일까? 게시판 프로그램 : 한 페이지당 게시글을 10개씩 출력해야 하는데 어떻게 출력할까? 알고리즘은 프로그래머에게 피할 수 없는 숙명입니다. 세계적으로 알고리즘과 관련한 대회 및 기관은 정말 수없이 많습니다. 대표적으로 ACM-ICPC, 구글 코드잼, 코드포스, 정보올림피아드 등이 존재합니다. 아이러니하게도 일반적인 개발을 할 때는 고난이도의 알고리즘이 거의 사용되지 않습니다. 그럼에도 불구하고 기업 채용이나 각종 대회에서는 문제 해결 능력을 보기 위해서 어려운 알고리즘 문제를 제시합니다. 알고리즘 문제는 종합적인 개발 역량을 평가하기에 좋은 용도이기 때문입니다. 실습 환경Dev C++은 가볍게 알고리즘 문제를 풀기에는 가장 좋은 저용량 개발 환경입니다.컴파일 및 실행 버튼 단축키는 ‘F11’입니다.아래 사이트에 접속 후 다운로드(Download) 버튼을 클릭합니다. Dev-C++ 다운로드 경로📚 참고 사이트 동빈나 블로그 동빈나 - 실전 알고리즘 강좌 (Algorithm Programming Tutorial)" }, { "title": "Unity Mathf.Lerp, Slerp, Tween, SmoothStep(유니티 선형 보간, 구면 선형 보간의 정확한 사용법, Tween과 SmoothStep)", "url": "/posts/Unity-Lerp-SmoothStep-Tween/", "categories": "Unity", "tags": "Unity", "date": "2022-10-31 00:00:00 +0900", "snippet": "※ Practical Environment Unity Editor Version - 2021.3.11f1※ Intro유니티의 Vector3 에는 Lerp, Slerp라는 함수가 있다.두 함수 모두 선형보간을 해서 두 지점사이의 위치를 계산하는 함수지만 두 함수 사이에는 큰 차이가 있다.그리고 이 차이를 이해하려면 우선 선형 보간과 구면 선형 보간의 ...", "content": "※ Practical Environment Unity Editor Version - 2021.3.11f1※ Intro유니티의 Vector3 에는 Lerp, Slerp라는 함수가 있다.두 함수 모두 선형보간을 해서 두 지점사이의 위치를 계산하는 함수지만 두 함수 사이에는 큰 차이가 있다.그리고 이 차이를 이해하려면 우선 선형 보간과 구면 선형 보간의 차이를 이해해야 한다.선형 보간 (Linear interpolate)두 지점을 선형으로 연결해서 두 지점사이의 위치를 파악하는 방법이다.유니티에서 사용할 때는 a와 b 지점 사이의 길이를 1로 두고, f값에 따라 그에 비례한 위치를 Vector3로 반환한다고 생각하면 된다.구면 선형 보간 (Spherically interpolate)구면 선형 보간은 두 지점 사이의 위치를 파악한다는 것은 같지만, 곡선으로 파악하기 때문에 선형 보간보다 조금 더 어렵다.사실 아까 보았던 선형보간을 벡터로 설명하자면 이런 그림이다.이러한 보간 방법은 평면 위에서는 정확하게 작동하지만, 만약 a와 b가 평평한 면이 아닌, 곡면 위의 점이라면 이야기가 달라진다.우리의 키가 수천Km로 커지거나, 지구의 반경이 매우 작아져서 어린왕자의 별같이 변했다고 가정해보자.a는 서울이고, b는 런던이다. 우리는 서울부터 런던까지의 길이를 선형보간 해서 3등분을 하고, 걸어가기로 했다.그렇다면 우리는 첫 날과 마지막 날은 쉬엄쉬엄 간다고 해도 두 번째 날 하루종일 걸어도 계획한 거리만큼 걸어갈 수 없을지도 모른다. 왜냐하면 우리는 곡면위에 있기 때문에 선형적인 보간으로는 실제 거리를 정확하게 나눌 수 없기 때문이다.그래서 등장한 개념이 구면 선형 보간이다.단순히 a와 b 두 점 사이의 거리를 나눠서 위치를 얻는 것이 아닌, a와 b가 구체평면 위에 위치한다고 가정한 후, 호의 거리를 선형적으로 보간해서 위치를 얻어내는 것이다.그러므로 구면 선형 보간을 하는 경우, a와 b사이의 직선 거리를 보간하지 않고, a와 b사이에 포물선이 만들어진 후 그 포물선 위를 보간하는 것이다.정리 선형 보간 =&gt; 평평한 면 위 구면 선형 보간 =&gt; 구면 위※ Apply많은 사람들이 UI등의 부드러운 움직임을 위해 Lerp를 제대로 사용하지 않고 있다.using UnityEngine;public class FollowCamera : MonoBehaviour{ public Transform startPosition; public Transform endPosition; private void Start() { this.transform.position = startPosition.position; } private void Update() { this.transform.position = Vector3.Lerp(this.transform.position, endPosition.position, 10 * Time.deltaTime); }}보통의 사람들은 이런 식으로 Time.deltaTime 등을 사용해 UI를 목표 지점까지 도달하게 한다.그러나 만약 정확히 0.5초가 경과했을 때 지정된 위치에 도달하게 하려면 어떻게 해야할까?위의 코드를 통해 수정하려면 겨우겨우 여러 조건문을 사용하여 맞추어야 할 것이다. 하지만 결국 그 마저도 정확하지 않고 미세한 오차가 있을 수 밖에 없다.또한 수정할 때마다 또 계산하는데 그 만큼 소요 시간이 증가한다.그래서 요즘은 대부분 에셋스토어에서 ‘Tween’을 검색하면 나오는 에셋들로 편하게 선형 보간을 사용하고 있다.그럼 이제부터 Vector3를 통해 Lerp를 살펴본다.인자의 1, 2번째인 시작 좌표를 0, 끝 좌표를 1로 취급하고 3번째 인자인 보간 값 0~1에 따라 위치 값을 결정한다.아래의 사진은 3번째 인자를 0.5로 두었을 때의 예시이다. 정확하게 절반의 위치를 알 수 있다.using UnityEngine;public class FollowCamera : MonoBehaviour{ public Transform startPosition; public Transform endPosition; private void Start() { this.transform.position = startPosition.position; } private void Update() { this.transform.position = Vector3.Lerp(this.transform.position, endPosition.position, 10 * Time.deltaTime); }}그럼 다시 이 코드를 이해하면 Time.dletaTime(기본 값 0.02f)에 10을 곱해 0.2f가 됩니다. 이것부터 사실 문제가 됩니다.두 번재 문제는 시작 좌표가 고정된 좌표가 아닌 단순한 현재 위치를 값으로 넣었기 때문에 시작 좌표가 매번 달라지게 됩니다.위 사진처럼 한 프레임에서 0.2f 위치로 보간되었을 때 시작 좌표가 변경되게 되는 것입니다. 그럼 다음 프레임에선 사진의 0좌표를 시작 좌표의 기준이 되어 또 부정확한 0.2f의 거리를 보간하게 됩니다.따라서 정확한 계산을 위해 코드를 수정해야합니다. 먼저 시작 좌표를 변경합니다. 지금의 위치가 아닌 고정된 위치(startPosition.position)로 변경합니다. 이 시작 좌표는 항사 변하지 않도록 하는 게 중요합니다.위의 코딩에선 start와 end 게임 오브젝트를 만들어주어 public으로 할당해주었습니다.두 번째로 보간 값을 수정합니다.using UnityEngine;public class FollowCamera : MonoBehaviour{ public Transform startPosition; public Transform endPosition; // 진행될 총 시간 (public으로 접근을 설정해 에디터에서 수정하도록 함) public float lerpTime = 0.5f; // 경과 카운트 float currentTime = 0f; private void Start() { this.transform.position = startPosition.position; } private void Update() { currentTime += Time.deltaTime; if (currentTime &gt;= lerpTime) { currentTime = lerpTime; } // currentTime / lerpTime &lt;--- 프레임마다 0부터 1까지 서서히 증가하는 형태 this.transform.position = Vector3.Lerp(startPosition.position, endPosition.position, currentTime / lerpTime); }}아까 전 코드는 시작 지점이 현재 위치였고, Time.dletaTime을 이용해 보간하다 보니 도착 지점에 가까워질 수록 서서히 느려졌었습니다. 이젠 고정된 좌표에서 보간값이 항상 일정하기 때문에 일정한 등속을 유지합니다.만약 아까 전 처럼 도착 지점에 가까워질 수록 느려지게 하고 싶다면 어떻게 해야할까요?여기선 SmoothStep이라는 수학적인 원리를 사용합니다. 아래의 주소에 들어가서 수식을 참고할 수 있습니다.※ SmoothStep How to Lerp like a pro노란색으로 표시한 부분을 복사하여 사용해줍니다.빨간 줄로 표시되어 있는 부분부터 시작 좌표입니다.using UnityEngine;public class FollowCamera : MonoBehaviour{ public Transform startPosition; public Transform endPosition; // 진행될 총 시간 float lerpTime = 0.5f; // 경과 카운트 float currentTime = 0f; private void Start() { this.transform.position = startPosition.position; } private void Update() { currentTime += Time.deltaTime; if (currentTime &gt;= lerpTime) currentTime = lerpTime; float t = currentTime / lerpTime; t = t * t * t * (t * (6f * t - 15f) + 10f); this.transform.position = Vector3.Lerp(startPosition.position, endPosition.position, t); }}float형 t를 생성하여 기존 보간값을 저장하고 SmoothStep을 전개한 t를 보간 값에 적용합니다.using System.Collections;using UnityEngine;using UnityEngine.UI;public class FollowCamera : MonoBehaviour{ public Transform startPosition; public Transform endPosition; Button btn; // 진행될 총 시간 float lerpTime = 0.5f; // 경과 카운트 float currentTime = 0f; private void Start() { this.transform.position = startPosition.position; // OnClick() Lambda btn.onClick.AddListener(() =&gt; { StartCoroutine(LerpTest()); }); } IEnumerator LerpTest() { currentTime += Time.deltaTime; if (currentTime &gt;= lerpTime) currentTime = lerpTime; float t = currentTime / lerpTime; t = t * t * t * (t * (6f * t - 15f) + 10f); this.transform.position = Vector3.Lerp(startPosition.position, endPosition.position, t); yield return null; }}최종 코드입니다. Update()에서 매 프레임마다 돌려주는 것 보다 코루틴으로 만들어 특정 이벤트에 의해 실행해주는 방식이 선호되기 때문에 이 코드에선 Button 컴포넌트의 OnClick() 리스너에 람다식으로 매핑해주었습니다.※ Reference Site 오늘코딩 - [유니티] Lerp를 프로처럼 사용하는 방법 [유니티] Lerp 와 Slerp 의 차이 - 선형 보간, 구면 선형 보간 How to Lerp like a pro" }, { "title": "Unity Event 2 - Action", "url": "/posts/Unity-Event-2-Action/", "categories": "Unity", "tags": "Unity", "date": "2022-10-31 00:00:00 +0900", "snippet": "※ Practical Environment Unity Editor Version - 2021.3.11f1※ IntroAction 입력, 리턴 값이 없는 델리게이트 타입코딩을 하다보면 “리턴값이 void 이고 입력값이 없는 함수형”을 델리게이트로 사용할 일이 많습니다.그래서 처음부터 이런 타입을 Using System 내부에 만들어 놓았는데 이것을 ...", "content": "※ Practical Environment Unity Editor Version - 2021.3.11f1※ IntroAction 입력, 리턴 값이 없는 델리게이트 타입코딩을 하다보면 “리턴값이 void 이고 입력값이 없는 함수형”을 델리게이트로 사용할 일이 많습니다.그래서 처음부터 이런 타입을 Using System 내부에 만들어 놓았는데 이것을 Action이라고 합니다.즉 단순히 델리게이트를 편하게 사용하기 위한 단축키 라고 생각하시면 되겠네요.※ Apply1번째 방법(대리자)using System.Collections;using System.Collections.Generic;using UnityEngine;using System; // &lt;--- Action 클래스를 사용하기 위해 필수 선언public class Action : MonoBehaviour{ // delegate void Action(); --&gt; 이 부분이 using System 내부에 구현되어 있습니다. Action work; void Start () { // MoveBricks() 라고 하면 함수가 실행되는 것이므로 MoveBricks 라고 적습니다. work += MoveBricks; work += DigIn; } private void Update() { if (Input.GetKeyDown(KeyCode.Space)) work(); } void MoveBricks() { Debug.Log(\"벽돌을 옮겼다.\"); } void DigIn() { Debug.Log(\"땅을 팠다.\"); }}2번째 방법(람다식) &lt;— 추천using System // &lt;--- 역시 Action 클래스를 사용하기 위해 필수 선언using System.Collections;using System.Collections.Generic;using UnityEngine;public class Target : MonoBehaviour // &lt;--- 오리진 클래스에서 실행될 타겟 클래스{ public static Action target; // &lt;--- 액션 클래스 필드 선언 void Awake() { target = () =&gt; { }; // &lt;--- 람다식 사용 target = () =&gt; { Mission(); Text(); }; } public void Mission() { Debug.Log(\"미션 성공\"); } public void Text() { Debug.Log(\"여러 개도 가능~!\"); }}※ Reference Site 유니티 이벤트 완벽하게 이해하기 4 - 액션과 람다 함수 오늘코딩 - [유니티꿀팁] 다른 스크립트의 함수를 쉽게 가져오는 방법" }, { "title": "Unity Event 1 - Button Onclick Listener Scripting + Lambda(유니티 이벤트 1 - 버튼 스크립트로 매핑하기 (온클릭 리스너) + 람다식)", "url": "/posts/Unity-Event-1-Button-Onclick-Listener-Scripting-Lambda/", "categories": "Unity", "tags": "Unity", "date": "2022-10-31 00:00:00 +0900", "snippet": "※ Practical Environment Unity Editor Version - 2021.3.11f1※ Intro버튼에 이벤트 할당하기유니티에서 UI에 동작을 할당 할 때는 간편하게 인스펙터에서버튼 컴포넌트에 노출되어있는 UnityEvent에 할당하는 방법이 있다.쉽고 간편해서 많은 유니티 튜토리얼에서 사용되는 방법이지만,이 방법은 두 가지 단점...", "content": "※ Practical Environment Unity Editor Version - 2021.3.11f1※ Intro버튼에 이벤트 할당하기유니티에서 UI에 동작을 할당 할 때는 간편하게 인스펙터에서버튼 컴포넌트에 노출되어있는 UnityEvent에 할당하는 방법이 있다.쉽고 간편해서 많은 유니티 튜토리얼에서 사용되는 방법이지만,이 방법은 두 가지 단점이 있다. 할당된 메서드가 visual studio에서 레퍼런스 참조가 안되며, 미리 할당해놔야하기 때문에 동적으로 버튼의 동작을 바꿀 수 없다. ※ ApplyAddListener로 버튼에 이벤트 할당하기때문에 이를 해결하기 위해 Button에 onClick.AddListener(델리게이트) 형식으로 메서드를 할당하는 방법이 있다.인자가 없는 메서드 예시void Awake(){ // 인자가 없는경우 바로 메소드 이름으로 넘겨주면됨. button.onClick.AddListener(PressBtnClose);} void PressBtnClose() // 인자가 없는 메소드{}인자가 있는 메서드 예시void Awake(){ // 인자가 있는 경우 람다 식이나 델리게이트를 사용 button.onClick.AddListener(() =&gt; OpenTab(0)); button.onClick.AddListener(delegate { OpenTab(0); });}void PressBtnTab(int tabIndex) // 인자가 있는 메소드{}※ 주의사항for 문 루프 + 람다식으로 Add Listener를 할 경우, 클로저 문제가 발생하여 제대로 할당이 되지 않을 우려가 있다.* 문제는 무엇인가?버튼을 배열로 선언해놓고for문에서 AddListener로 할당하려고 했는데,모두 마지막 값으로 초기화되는 현상이 있었다.for (int i = 0; i &lt; Btns.Length; i++){ Btns[i].onClick.AddListener(() =&gt; PressBtnSelectGame(i));}0, 1, 2 .. 순서대로 초기화되는 것이 아니다.* Closure Problem람다식은 실제 실행되기 전에는 참조형태로 가지고있는데,for문을 돌리면서 같은 변수인 i를 계속 줬기 때문에 마지막 값으로 통일된 것.이를 closure problem이라고 부른다.* 해결방법아래와 같이 수정하면 된다. (혹은 각각을 직접 숫자를 넣어 하드코딩으로 써주자)for (int i = 0; i &lt; Btns.Length; i++){ int temp = i; // Closure 문제때문에 복사해서 사용한다. Btns[temp].onClick.AddListener(() =&gt; PressBtnSelectGame(temp));}※ 후기나 또한 진행중인 프로젝트에서 for문으로 람다식을 돌리려고 했지만 모두 마지막 버튼 이벤트로만 매핑이 되는 것이었다.(클로저)그래서 나의 해결 방법으로는 int 인자를 받는 함수를 만들어 람다식을 만들어주고 그 함수를 for문으로 돌렸더니 정상적으로 되는 것이었다. // Btn Mode - Panel Speed, Music Length, Obstacle void BtnModes(int i) { btnModes[i].onClick.AddListener(() =&gt; OnClick_Mode(btnModes[i], btnModes, infoImages, infoTmp_Text, sFX[0])); } for (int i = 0; i &lt; btnModes.Length; i++) BtnModes(i);※ Reference Site Unity UI Button onClick.AddListener 활용하기 for 문에서 AddListener 람다식은 주의해야한다. (AddListener for loop)" }, { "title": "Unity URP-Based Water Shader(Feat.Boat Attack) (유니티 URP 모바일 최적화 물 셰이더 간단 적용)", "url": "/posts/Unity-URP-Based-Water-Shader-Feat.Boat-Attack/", "categories": "Unity", "tags": "Unity", "date": "2022-10-28 00:00:00 +0900", "snippet": "※ Practical Environment Github Unity Editor Version - 2021.3.11f1 Package Universal RP(Ver 12.1.7) ※ Intro※ Boat Attack 프로젝트 특징 Unity Universal RP 사용 모바일 최적화, 낮은 폴리, LOD C# 작업 부...", "content": "※ Practical Environment Github Unity Editor Version - 2021.3.11f1 Package Universal RP(Ver 12.1.7) ※ Intro※ Boat Attack 프로젝트 특징 Unity Universal RP 사용 모바일 최적화, 낮은 폴리, LOD C# 작업 부력 시스템 시네머신 카메라 설정 셰이더 그래프 사용 볼륨 블렌딩을 사용한 포스트 프로세싱 v3 SRP 콜백 을 통한 평면 반사를 위한 맞춤형 범용 RP 렌더링 WaterFX 및 Caustics에 대한 사용자 지정 SciptableRenderPass 사용 현지 패키지(WIP)의 Gerstner 기반 물 시스템 데모 영상 보기※ Unity Korea - [튜토리얼] Boat Attack Water System 재생목록 바로가기작동 원리와 물 셰이더 프로그래밍, 코드 해석의 도움을 받을 수 있습니다.※ Apply적용 방법은 매우매우 쉽습니다. Boat Attack Project https://github.com/Verasl/BoatAttack 위의 URL에 접속하여 프로젝트를 Fork합니다. Github Desktop Fork한 프로젝트를 Clone해줍니다. Packages Folder Clone한 프로젝트의 패키지 폴더에 진입하면 ‘com.verasl.water-system’ 폴더가 있습니다. 이것이 물 셰이더를 사용할 수 있도록 별도로 커스텀 패키징한 폴더입니다. 이 폴더를 적용할 프로젝트의 Packages 폴더에 복사하고 유니터 에디터로 돌아갑니다. 패키지 설치 확인 Error 적용 했을 때 이런 에러가 발생한다면 Dependencies 아래의 요구되는 3개의 내장 패키지가 설치되어 있는지 확인 후 설치합니다. 보통 URP 템플릿으로 프로젝트를 실행하면 오류는 뜨지 않습니다. Mathematics Burst Render-Pipelines Universal(Universal RP) 적용 방법 1 (추천) Packages -&gt; Boat Attack Water System -&gt; SeaVisual 프리팹을 하이어라키로 드래그 &amp; 드랍 적용 방법 2 빈 오브젝트를 생성한 뒤 ‘water’ 스크립트를 컴포넌트에 추가해줍니다. 혹시 씬 뷰에 적용되지 않았다면 오브젝트를 재활성화 해줍니다. 주의 : 셰이더는 y가 0기준으로 정상 작동하므로 이 기준에 맞추어 오브젝트들의 y값을 조정해야합니다. Unity Korea - 내 URP 프로젝트로 물 시스템 가져오기. 모바일 플랫폼을 위한 물 표현 (6/6) 추가 설정이나 사용법은 위의 영상 4분15초부터 보시는걸 추천드립니다.마지막으로 위 사진의 ‘Always Refresh를 체크하면 씬 뷰를 실시간으로 새로고침 해줍니다.※ Reference Site Github Unity-Technologies / Boat Attack Project Universal Render Pipeline (7.1) Manual Unity Korea - 내 URP 프로젝트로 물 시스템 가져오기. 모바일 플랫폼을 위한 물 표현 (6/6)" }, { "title": "Unity Custom Hierarchy for Unity Ver1.2.0 (Feat.Febucci) (유니티 하이어라키 꾸미기)", "url": "/posts/Unity-Custom-Hierarchy-for-Unity-Ver1.2.0/", "categories": "Unity", "tags": "Unity", "date": "2022-10-28 00:00:00 +0900", "snippet": "※ Practical Environment Unity Editor Version - 2021.3.11f1※ Intro Preview 트리 뷰 “트리 뷰”는 부모와 자식의 중첩 수준을 이해하는 데 도움이 됩니다( 이 구문은 이 컨텍스트 외부에서 의미가 없습니다.) “가지”의 수와 모든 색상을 지정할 수 있습니다(...", "content": "※ Practical Environment Unity Editor Version - 2021.3.11f1※ Intro Preview 트리 뷰 “트리 뷰”는 부모와 자식의 중첩 수준을 이해하는 데 도움이 됩니다( 이 구문은 이 컨텍스트 외부에서 의미가 없습니다.) “가지”의 수와 모든 색상을 지정할 수 있습니다(배열이 끝나면 색상이 다시 반복됩니다.) 아이콘 게임오브젝트의 컴포넌트 아이콘은 스크립트 “기즈모”를 수정하지 않고도 계층에서 직접 시각화할 수 있습니다. ScriptableObject를 통해 스크립트에 텍스처를 할당하여 작동하며 상속된 클래스에서도 작동합니다. 게임 오브젝트의 장면 아이콘을 시각화할 수도 있습니다. 분리 기호 ‘EditorOnly’ 태그를 사용하여 씬의 계층 구조를 분리하고 색상을 지정할 수 있습니다. (빌드에서 제거되는 태그) 교대 라인 이 기능은 한 줄과 다음 줄을 구별하는 데 도움이 됩니다. 항상 그렇듯이 이 항목에서도 색상과 강도를 수정할 수 있습니다.※ Apply Package Manager Package Manager - Add package from git URL… Add package from git URL… https://github.com/febucci/unitypackage-custom-hierarchy.git 입력 후 Add하여 인스톨 설치된 모습 Plugin Create Project View ‘HierarchyData’가 제대로 생성되었고 이 곳에서 여러가지 커스텀이 가능하다. 간혹 프로젝트를 재설치하거나 이동한 후엔 커스텀 하이어라키 기능이 해제될 때가 있다. 그럴 땐 이 ‘HierarchyData’ 다시 클릭해주면 활성화된다. 적용된 사진 더 자세한 내용이 궁금하다면 문서 참조※ Reference Site febucci / unitypackage-custom-hierarchy Coco Code - Organise and colorise your hierarchy! - UNITY TIPS and ASSETS #1 Documentation Page" }, { "title": "Unity RS232 Serial(유니티 RS232 시리얼 통신)", "url": "/posts/Unity-RS232-Serial/", "categories": "Unity, RS232", "tags": "Unity, RS232", "date": "2022-10-24 00:00:00 +0900", "snippet": "※ Api Compatibility Level 설정Project Setting - Player - Other Settings - Configuration - Api Compatibility Level - .NET Framework※ DemoSerialCommuncation.csusing UnityEngine;using System;using Syste...", "content": "※ Api Compatibility Level 설정Project Setting - Player - Other Settings - Configuration - Api Compatibility Level - .NET Framework※ DemoSerialCommuncation.csusing UnityEngine;using System;using System.IO.Ports;public class DemoSerialCommuncation : MonoBehaviour { SerialPort m_SerialPort = new SerialPort(\"COM3\", 9600, Parity.None, 8, StopBits.One); string m_Data = null; void Start() { m_SerialPort.Open(); } private void Update() { try { if (m_SerialPort.IsOpen) { m_Data = m_SerialPort.ReadLine(); m_SerialPort.ReadTimeout = 30; } } catch (Exception e) { Debug.Log(e); } } void OnApplicationQuit() { m_SerialPort.Close(); } }※ 참고 사이트 코더 제로 - [유니티 시리얼통신] RS232 시리얼 통신" }, { "title": "Unity Arduino Serial(유니티 아두이노 시리얼 통신)", "url": "/posts/Unity-Arduino-Serial/", "categories": "Unity, Arduino", "tags": "Unity, Arduino", "date": "2022-10-21 00:00:00 +0900", "snippet": "※ 닷넷 4.0 이상 설정하기System.IO.Ports 네임스페이스를 사용하기 위해 변경 해주어야 한다.※ 스크립트아래의 스크립트는 피에조 스피커의 프리퀀시를 8개로 받고 유니티 앱에서 지정된 키보드에 따라 계이름 소리를 출력한다./// [UNITY]Arduino.csusing UnityEngine;/// using System.IO.Ports 선언...", "content": "※ 닷넷 4.0 이상 설정하기System.IO.Ports 네임스페이스를 사용하기 위해 변경 해주어야 한다.※ 스크립트아래의 스크립트는 피에조 스피커의 프리퀀시를 8개로 받고 유니티 앱에서 지정된 키보드에 따라 계이름 소리를 출력한다./// [UNITY]Arduino.csusing UnityEngine;/// using System.IO.Ports 선언using System.IO.Ports;public class Arduino : MonoBehaviour{ /// 시리얼 포트 생성 /// 포트 번호, 비트레이트를 맞춰준다. 뒷 부분은 우노 기준의 설정 SerialPort SerialPort1 = new SerialPort(\"COM4\", 9600, Parity.None, 8, StopBits.One); void Start() { /// 시리얼 포트 연결 시도 SerialPort1.Open(); } /// 인풋 받은 문자열에 따라 연결된 시리얼 포트에게 문자열로 송신한다. void Update() { switch (Input.inputString) { case \"A\": case \"a\": Debug.Log(\"press A\"); SerialPort1.WriteLine(\"A\"); break; case \"S\": case \"s\": Debug.Log(\"press S\"); SerialPort1.WriteLine(\"S\"); break; case \"D\": case \"d\": Debug.Log(\"press D\"); SerialPort1.WriteLine(\"D\"); break; case \"F\": case \"f\": Debug.Log(\"press F\"); SerialPort1.WriteLine(\"F\"); break; case \"G\": case \"g\": Debug.Log(\"press G\"); SerialPort1.WriteLine(\"G\"); break; case \"H\": case \"h\": Debug.Log(\"press G\"); SerialPort1.WriteLine(\"H\"); break; case \"J\": case \"j\": Debug.Log(\"press J\"); SerialPort1.WriteLine(\"J\"); break; case \"K\": case \"k\": Debug.Log(\"press K\"); SerialPort1.WriteLine(\"K\"); break; } } /// 앱이 종료되면 시리얼 통신도 종료 void OnApplicationQuit() { SerialPort1.Close(); }}/// [Arduino]/// 피에조 스피커 핀 식별자 지정int piezo_pin = 3;/// 멜로디 프리퀀시int melody_freq[8] = { 262, 294, 330, 349, 392, 440, 494, 523 };void setup() { /// 시리얼 통신 시작 Serial.begin(9600); pinMode(3, OUTPUT);}void loop(){ while(Serial.available()) { char data = Serial.read(); switch(data) { case 'A': C_(0); break; case 'S': D_(0); break; case 'D': E_(0); break; case 'F': F_(0); break; case 'G': G_(0); break; case 'H': A_(0); break; case 'J': B_(0); break; case 'K': CC_(0); break; } }}void C_(int ms){ tone(piezo_pin, melody_freq[0], 200); delay(ms);}void D_(int ms){ tone(piezo_pin, melody_freq[1], 200); delay(ms);}void E_(int ms){ tone(piezo_pin, melody_freq[2], 200); delay(ms);}void F_(int ms){ tone(piezo_pin, melody_freq[3], 200); delay(ms);}void G_(int ms){ tone(piezo_pin, melody_freq[4], 200); delay(ms);}void A_(int ms){ tone(piezo_pin, melody_freq[5], 200); delay(ms);}void B_(int ms){ tone(piezo_pin, melody_freq[6], 200); delay(ms);}void CC_(int ms){ tone(piezo_pin, melody_freq[7], 200); delay(ms);}버튼의 경우 나는 OnClick()에 직접 매핑하지 않고, 이벤트 리스너로 받아 처리했다." }, { "title": "22-10-18(화)", "url": "/posts/Diary-221018/", "categories": "Diary, 2022.10", "tags": "Diary", "date": "2022-10-18 00:00:00 +0900", "snippet": "프로젝트※ 해결 목록＃스크립트 리팩토링＃인게임 텍스트 크기, 출력 수정＃버튼 이벤트 스크립트 할당참고 사이트 Unity UI Button onClick.AddListener 활용하기＃※ 하이러키 뷰＃생성 ＃수정 UI Ingame -&gt; Score Canvas -&gt; Just Text Score 컴포넌트 변경 Text -&g...", "content": "프로젝트※ 해결 목록＃스크립트 리팩토링＃인게임 텍스트 크기, 출력 수정＃버튼 이벤트 스크립트 할당참고 사이트 Unity UI Button onClick.AddListener 활용하기＃※ 하이러키 뷰＃생성 ＃수정 UI Ingame -&gt; Score Canvas -&gt; Just Text Score 컴포넌트 변경 Text -&gt; TMP text UI Ingame -&gt; Score Canvas -&gt; Just Text Kcal 컴포넌트 변경 Text -&gt; TMP text＃삭제 ※ 프로젝트 뷰＃생성 ＃수정 ＃삭제 ※ 스크립트 GameManager.cs 헤더 수정(가독성) LevelDesign(Button[]) - 함수 생성, 리팩토링 레벨에 따른 속도, 퀴즈 쿨타임 조절 MusicInfoUI(Button[], TMP_Text[]) - 함수 생성, 리팩토링 모드 선택에 따른 안내 문구 변경 ControllerModeChange() - 함수 수정, 리팩토링 RayControllerMode(bool)로 변경 인자에 따른 Ray Controller 표시 유무 변경 IEnumerator Increase() - 코루틴 수정, 리팩토링 public void SetScore(int score) - 함수 수정, 리팩토링 public void SetKcal(float kcal) - 함수 수정, 리팩토링 public void EndResetEvent() - 함수 생성, 리팩토링 일시정지 –&gt; 로비, 엔드 이벤트 공통으로 포함되는 코드 정리 ScoreManaged.cs 게임 매니저에서 관리하던 스코어, 칼로리 등의 함수들을 직렬화된 정적 클래스에서 관리 [Serializable]public static class ScoreManaged{// [Coroutine] 스코어 칼로리 증가public static IEnumerator Increase(){ // Score if /*x1*/ (0 &lt;= ComboManager.instance.combo &amp;&amp; ComboManager.instance.combo &lt; 5) SetScore(GameManager.instance.score += 1000); else if /*x2*/ (5 &lt;= ComboManager.instance.combo &amp;&amp; ComboManager.instance.combo &lt; 10) SetScore(GameManager.instance.score += 2000); else if /*x4*/ (10 &lt;= ComboManager.instance.combo &amp;&amp; ComboManager.instance.combo &lt; 15) SetScore(GameManager.instance.score += 4000); else if /*x8*/ (15 &lt;= ComboManager.instance.combo) SetScore(GameManager.instance.score += 8000); // Kcal SetKcal(GameManager.instance.kcal += Random.Range(0.05f, 0.15f)); // Combo ComboManager.instance.IncreaseCombo(); yield break;}// [Event] 스코어 증감 인게임 반영public static void SetScore(int score){ GameManager.instance.textIngameScore.text = score.ToString();}// [Event] 칼로리 증감 인게임 반영public static void SetKcal(float kcal){ GameManager.instance.textIngameKcal.text = kcal.ToString(\"F2\");}} ResultElements.cs GameManager.cs의 키 값 변수들을 배열로 만들면서 수정```c#/// &lt;summary&gt;/// ResultElements.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (V-Light Studio)/// This software is released under the GPL-2.0 license/// /// 동적 프리팹 각 오브젝트의 TMP_Text 컴포넌트에 곡이 끝난 결과를 키 값으로 저장/// &lt;/summary&gt; using TMPro;using UnityEngine;public class ResultElements : MonoBehaviour{ private void Start() { /Title/ gameObject.transform.GetChild(0).gameObject.GetComponent().text = GameManager.instance.textKeys[0].text; /*Level*/ gameObject.transform.GetChild(1).gameObject.GetComponent().text = GameManager.instance.textKeys[1].text; /*Score*/ gameObject.transform.GetChild(2).gameObject.GetComponent().text = GameManager.instance.textKeys[2].text; /* Kcal*/ gameObject.transform.GetChild(3).gameObject.GetComponent().text = GameManager.instance.textKeys[3].text; }}```" }, { "title": "Unity XR | Android Build Setting(유니티 XR 안드로이드 최적화)", "url": "/posts/Unity-Android-Build/", "categories": "Unity, XR Interaction Toolkit", "tags": "Unity, XR Interaction Toolkit", "date": "2022-10-14 00:00:00 +0900", "snippet": "※ 유니티 모바일 텍스쳐 압축연구 ETC2, PVRTC, ASTC 맨텀※ Compute SkinningMeshskinning.SkinOnGPU렌더링 전 버텍스당 스키닝을 각 프레임마다 재계산하는데, 이 폴리곤이 많아지면 연산부담도 증가하게 됨.이 연산은 CPU에서 처리하는데 Unity에서 옵션값을 통해 GPU에게 할당할 수도 있음Player Sett...", "content": "※ 유니티 모바일 텍스쳐 압축연구 ETC2, PVRTC, ASTC 맨텀※ Compute SkinningMeshskinning.SkinOnGPU렌더링 전 버텍스당 스키닝을 각 프레임마다 재계산하는데, 이 폴리곤이 많아지면 연산부담도 증가하게 됨.이 연산은 CPU에서 처리하는데 Unity에서 옵션값을 통해 GPU에게 할당할 수도 있음Player Settings &gt; Player &gt; Other Settings &gt; Compute Skinning해당 값이 활성 &gt; GPU 연산, 비활성 &gt; CPU 연산언뜻 보면 GPU에게 맡기면 빠를거 같지만 모바일 환경은 GPU 사양이 제한되어 있어, 병목 원인에 따라 선택해야 함CPU로 연산하면 SIMD라는 아키텍처를 이용해 고속연산을 수행하기 때문에 모바일 환경이라면 비활성 하는게 이득하지만 프레임 드랍의 원인이 CPU라면 GPU에게 처리하도록 하는게 더 나은 방법*단, GPU 스키닝 연산은 OpenGL ES2에서는 지원되지 않음. DX11과 OpenGL ES3에서만 유효 (지원여부는 바뀔수있다)※ 점진적 가비지 수집(incremental garbage collection)유니티의 가비지콜렉터는 Boehm–Demers–Weiser garbage collector를 사용한다.https://www.hboehm.info/gc/가비지콜렉터가 가비지 수집을 수행할때 프로그램 코드 실행 및 CPU 메인스레드를 중지하며 전체 힙을 검사한다(stop-the world garbage collection) 힙의 모든 오브젝트를 처리한 이후에 어플리케이션 실행을 재개함으로 성능에 영향을 미치는 gc 스파이크(중단으로 인해 프로파일러 윈도우의 그래프에서 나타나는 큰 스파이크)가 발생한다.incremental mode는 가비지콜렉터가 힙의 모든 오브젝트들을 처리하기 위해 긴 중단을 한번만 수행하는 대신에 작업부하를 여러 프레임으로 분할하여 어플리케이션 실행을 더 짧게 중단하는것을 의미한다.유니티에서 incremental mode는 기본적으로 활성화되어있으며 project settings의 player configuration에서 활성화 및 비활성화할수있다.가비지수집을 더 빠르게 만들지않지만 여러 프레임에 작업부하를 분산하기때문에 gc 스파이크 및 gc 관련 성능 스파이크를 줄일수있다.참고 사이트 흔적남기기 창작블로그 맨텀" }, { "title": "22-10-12(수)", "url": "/posts/Diary-221012/", "categories": "Diary, 2022.10", "tags": "Diary", "date": "2022-10-12 00:00:00 +0900", "snippet": "프로젝트※ 해결 목록＃UI 디자인＃앨범 이미지 로드 삭제＃초기화 버튼 오류 해결＃튜토리얼 수정 및 개편(문구, (Vector3, Vector2, Quaternion) XR_TutoCanvasSize(), 절차 함수)＃선택한 노래 부분 수정(꾸미기, 선택한 모드 확인 등)※ 하이러키 뷰＃생성 UI 일부 수정＃수정 UI 일부 수정＃삭제 UI 일부 수...", "content": "프로젝트※ 해결 목록＃UI 디자인＃앨범 이미지 로드 삭제＃초기화 버튼 오류 해결＃튜토리얼 수정 및 개편(문구, (Vector3, Vector2, Quaternion) XR_TutoCanvasSize(), 절차 함수)＃선택한 노래 부분 수정(꾸미기, 선택한 모드 확인 등)※ 하이러키 뷰＃생성 UI 일부 수정＃수정 UI 일부 수정＃삭제 UI 일부 수정※ 프로젝트 뷰＃스크립트＃생성 Sleek essential UI pack Asset 추가(UI 디자인 팩)＃수정 Music Element 동적 프리팹 UI 디자인(앨범 이미지 삭제, BPM 추가)" }, { "title": "백준(BOJ) | 다리 놓기(⚪️Ⅴ/1010)", "url": "/posts/S5-1010/", "categories": "CordingTest", "tags": "CordingTest, BOJ", "date": "2022-10-11 00:00:00 +0900", "snippet": "※ 문제 문제 링크 : 바로가기※ 풀이확률과 통계의 조합(combination)과 이항 정리 공식 활용 문제", "content": "※ 문제 문제 링크 : 바로가기※ 풀이확률과 통계의 조합(combination)과 이항 정리 공식 활용 문제" }, { "title": "22-10-08(토)", "url": "/posts/Diary-221008/", "categories": "Diary, 2022.10", "tags": "Diary", "date": "2022-10-08 00:00:00 +0900", "snippet": "프로젝트※ 해결 목록 컨트롤러 - 패널 트래킹 퀴즈, 장애물 패널 판정, 소리 키 조절 일시정지 상태 Ray 컨트롤러 활성화※ 하이러키 뷰 생성 Direct Interactor Left(게임 진행 트리거) Direct Interactor Right(게임 진행 트리거) 수정 Camera Of...", "content": "프로젝트※ 해결 목록 컨트롤러 - 패널 트래킹 퀴즈, 장애물 패널 판정, 소리 키 조절 일시정지 상태 Ray 컨트롤러 활성화※ 하이러키 뷰 생성 Direct Interactor Left(게임 진행 트리거) Direct Interactor Right(게임 진행 트리거) 수정 Camera Offset(Camera Offset.cs 삽입) Slider Height(On Value Changed Camera Offset.cs의 Camera Y Offset으로 변경) 삭제※ 프로젝트 뷰 스크립트 생성 수정 GameManager.cs HeightInc(), HeightDec() if문 조건 수정(키 조절 관련) XRI_InGamePause(), BtnInGameUnPause() Ray 컨트롤러 활성화/비활성화(일시정지 관련) PanelSensor.cs —&gt; PanelQuizObstacleTrigger.cs 클래스 이름 변경(가독성) 삭제 MongoDBCtrl(MongoDB 서버 데이터 관련) GameData(MongoDB 서버 데이터 관련) XRInputManager(XRI Device-Based Controller Binding 관련) ObjectPoolManager(ObjectPooling 관련) PoolObject(ObjectPooling 관련) PoolObjectData(ObjectPooling 관련) " }, { "title": "22-10-07(금)", "url": "/posts/Diary-221007/", "categories": "Diary, 2022.10", "tags": "Diary", "date": "2022-10-07 00:00:00 +0900", "snippet": "C# for Unity 수업Struct(구조체) 클래스보다 리소스 등 기능이 가벼우므로 메모리 확보에 용이 단순히 데이터만 주고 받을 때 사용 new가 없음 DB로 보낼 때(정보, 세이브 데이터) 등에 구조체로 선언하는 게 정석 네이티브 언어에선 class와 struct가 명확히 구분되지만, C#은 비교적 모호하다.ref, out참조 = Re...", "content": "C# for Unity 수업Struct(구조체) 클래스보다 리소스 등 기능이 가벼우므로 메모리 확보에 용이 단순히 데이터만 주고 받을 때 사용 new가 없음 DB로 보낼 때(정보, 세이브 데이터) 등에 구조체로 선언하는 게 정석 네이티브 언어에선 class와 struct가 명확히 구분되지만, C#은 비교적 모호하다.ref, out참조 = Refrence = Pointer(레퍼런스 언어 기준)Generic Awake(), Start()에서 사용 권장 Update()에선 리소스를 많이 차지하므로 권장하지 않음 Ex)GetComponent&lt;???&gt;(); 변수의 형태에 상관 없이 사용 가능하도록 해준다.Property(프로퍼티) - get, setCorutine과 Thread 코루틴의 return 값들은 CPU에게 제어권을 넘겨준다는 것이다.(WaitForSeconds()) 코루틴으로 진정한 쓰레드 기능은 못하지만 유사하게 병렬 처리를 할 수 있도록 구현할 수 있다." }, { "title": "XRI Input Action Custom Binding", "url": "/posts/Unity-XRI-InputSystem/", "categories": "Unity, XR Interaction Toolkit", "tags": "Unity, XR Interaction Toolkit", "date": "2022-10-06 00:00:00 +0900", "snippet": "XR Interaction Toolkit을 공부하면서, Action-Based와 Device-Based의 차이점 등을 공부하다 보니, Action-Based가 전반적으로 범용성이 크고 XRI 개발자들도 추천하고 있었다,그래서 현재 진행중인 프로젝트도 Action-Based Controller로 변경했다. 하지만 잘 사용하던 XRInputManager....", "content": "XR Interaction Toolkit을 공부하면서, Action-Based와 Device-Based의 차이점 등을 공부하다 보니, Action-Based가 전반적으로 범용성이 크고 XRI 개발자들도 추천하고 있었다,그래서 현재 진행중인 프로젝트도 Action-Based Controller로 변경했다. 하지만 잘 사용하던 XRInputManager.cs에서 액션 컨트롤러가 매핑되지 않던 것이다.알고 보니 XRController 클래스는 Device-Based에서만 사용이 가능했던 것이었다.. 당연히 XRStatics.GetFeature 메서드를 사용하는 부분도 문제가 있을 것이므로 버튼 매핑하는 부분을 Action-Based가 바인딩하는 방법인 Input System으로 바꿔준다.기존 바인딩 방법Device-based를 사용할 때 사용하던 코드이다. Will9371/Playcraft이 제작자의 바인딩 코드 모듈을 사용 했었다.using System;using UnityEngine;using UnityEngine.Events;using UnityEngine.XR;using UnityEngine.XR.Interaction.Toolkit;public class XRInputManager : MonoBehaviour{ [SerializeField] XRController controller; [SerializeField] XRBinding[] bindings; private void Update() { foreach (var binding in bindings) binding.Update(controller.inputDevice); }}[Serializable]public class XRBinding{ [SerializeField] XRButton button; [SerializeField] PressType pressType; [SerializeField] UnityEvent OnActive; bool isPressed; bool wasPressed; public void Update(InputDevice device) { device.TryGetFeatureValue(XRStatics.GetFeature(button), out isPressed); bool active = false; switch (pressType) { case PressType.Continuous: active = isPressed; break; case PressType.Begin: active = isPressed &amp;&amp; !wasPressed; break; case PressType.End: active = !isPressed &amp;&amp; wasPressed; break; } if (active) OnActive.Invoke(); wasPressed = isPressed; }}public enum XRButton{ Trigger, Grip, Primary, PrimaryTouch, Secondary, SecondaryTouch, Primary2DAxisClick, Primary2DAxisTouch}public enum PressType{ Begin, End, Continuous}public static class XRStatics{ public static InputFeatureUsage&lt;bool&gt; GetFeature(XRButton button) { switch (button) { case XRButton.Trigger: return CommonUsages.triggerButton; case XRButton.Grip: return CommonUsages.gripButton; case XRButton.Primary: return CommonUsages.primaryButton; case XRButton.PrimaryTouch: return CommonUsages.primaryTouch; case XRButton.Secondary: return CommonUsages.secondaryButton; case XRButton.SecondaryTouch: return CommonUsages.secondaryTouch; case XRButton.Primary2DAxisClick: return CommonUsages.primary2DAxisClick; case XRButton.Primary2DAxisTouch: return CommonUsages.primary2DAxisTouch; default: Debug.LogError(\"button \" + button + \" not found\"); return CommonUsages.triggerButton; } }}Action-Based먼저 XRI 기본 세팅 에셋의 ‘XRI Default Input Actions’ 오브젝트를 살펴보자. InputActionReference 클래스 구조로 Input System을 이용하는 것으로 보인다.새로운 Action Map을 만들어 준다. 이름은 Game이다. 그리고 하위의 액션으로 Pause라는 이름을 만들고 + 버튼을 눌러 바인딩을 추가한다.나는 오큘러스 퀘스트2 기준으로 A, X 버튼과 키보드 ‘P’로 바인딩을 추가했다.이제 이벤트 핸들러로 스크립트를 구성한다.나의 경우 기존에 GameManager.cs에서 인풋 바인드로 일시정지 함수를 실행 했으므로 이번에도 게임 매니저에서 스크립팅 한다. /// 필드에 선언 [Header(\"[InputActionReference]\")] public InputActionReference gamePause = null; ... // [Onclick] 로비 ---&gt; 인게임 public void BtnPlay() { if (!TutorialManager.instance.isTutorial) { isStart = true; isRayState = false; /// 여기서 XRI_InGamePause() 이벤트 핸들러를 켜준다. gamePause.action.started += XRI_InGamePause; } } ... /// 콜백 함수는 여기, 실행 전 조건을 걸어둠으로 인게임 중에만 작동한다. // [XRI Input Action Binding(Primary Buuton)] 인게임 ---&gt; 일시정지 public void XRI_InGamePause(InputAction.CallbackContext context) { if (isStart &amp;&amp; !isPause &amp;&amp; !TutorialManager.instance.isTutorial) { isPause = true; isRayState = true; // Music Paused UI On uiPause.SetActive(true); // 플레이 중 노래 일시 정지 Time.timeScale = 0; musicPlayed.Pause(); } } ... /// 콜백 함수 종료 시점 1 // [Onclick] 일시정지 ---&gt; 메인 public void BtnPauseBackLobby() { if (isStart &amp;&amp; isPause) { [중략...] gamePause.action.started -= XRI_InGamePause; } /// 콜백 함수 종료 시점 2 // [Event] 인게임 종료 public void InGameEnd() { [중략...] gamePause.action.started -= XRI_InGamePause; }게임 매니저에 만들어 둔 InputActionReference 잊지 않고 맵핑하기~결과참고 사이트 xr-controller-action-based/docs.unity3d.com Custom Input Actions for Unity XR" }, { "title": "22-10-06(목)", "url": "/posts/Diary-221006/", "categories": "Diary, 2022.10", "tags": "Diary", "date": "2022-10-06 00:00:00 +0900", "snippet": "프로젝트 컨트롤러 하나로 병합 키보드 동작 키 조절 최적화 파이어베이스 연동 회원가입, 로그인", "content": "프로젝트 컨트롤러 하나로 병합 키보드 동작 키 조절 최적화 파이어베이스 연동 회원가입, 로그인" }, { "title": "VR Keyboard | Unity Tutorial for Oculus Quest(유니티 XR 키보드 만들기)", "url": "/posts/Unity-VR-Keyboard/", "categories": "Unity, Unity VR", "tags": "Unity, Unity VR", "date": "2022-10-05 00:00:00 +0900", "snippet": "준비물 세팅아래의 패키지를 프로젝트에 임포트 Download VR Button Package레이어 지정아래 사진처럼 네 개의 레이어 지정Tags and Layers Hands Interactive Typing Hands KeyboardPhysics키보드 제작오브젝트 추가 빈 오브젝트(Keyboard) 3D Cube(Board...", "content": "준비물 세팅아래의 패키지를 프로젝트에 임포트 Download VR Button Package레이어 지정아래 사진처럼 네 개의 레이어 지정Tags and Layers Hands Interactive Typing Hands KeyboardPhysics키보드 제작오브젝트 추가 빈 오브젝트(Keyboard) 3D Cube(Board) 생성 후 포지션 (1, 0.05, 0.4) 지정, Gray 머티리얼 적용 빈 오브젝트(Buttons) 빈 오브젝트(Normal) 빈 오브젝트(Numbers) 프리팹(Square Button) —&gt; 포지션 y 0.03 / 언팩하기 / 이름 변경(KeyboardButton) 빈 오브젝트(Typing Area)KeyboardButton 자식으로 Text 생성캔버스와 텍스트 인스펙터 변경캔버스를 Press 하위로 이동Collider 오브젝트 컴포넌트에 기존 On Release() 이벤트 삭제 Keyboard.cs —&gt; Keyboard 오브젝트에 지정using UnityEngine;using TMPro;public class Keyboard : MonoBehaviour{ public TMP_InputField inputField; public GameObject normalButtons; public GameObject capsButtons; bool caps; private void Start() { caps = false; } public void InsertChar(string c) { inputField.text += c; } public void DeleteChar() { if (inputField.text.Length &gt; 0) { inputField.text = inputField.text.Substring(0, inputField.text.Length - 1); } } public void InsertSpace() { inputField.text += \" \"; } public void CapsPressed() { if (!caps) { normalButtons.SetActive(false); capsButtons.SetActive(true); caps = true; } else { normalButtons.SetActive(true); capsButtons.SetActive(false); caps = false; } }} KeyboardButton.cs —&gt; KeyboardButton 오브젝트에 지정using TMPro;using UnityEngine;public class KeyboardButton : MonoBehaviour{ Keyboard Keyboard; TextMeshProUGUI buttonText; private void Start() { Keyboard = GetComponentInParent&lt;Keyboard&gt;(); buttonText = GetComponentInChildren&lt;TextMeshProUGUI&gt;(); if (buttonText.text.Length == 1) { NameToButtonText(); GetComponentInChildren&lt;ButtonVR&gt;().onRelease.AddListener(delegate { Keyboard.InsertChar(buttonText.text); }); } } public void NameToButtonText() { buttonText.text = gameObject.name; }} TypingArea.cs —&gt; Typing Area 오브젝트에 지정using UnityEngine;public class TypingArea : MonoBehaviour{ public GameObject leftHand; public GameObject RightHand; public GameObject LeftTypingHand; public GameObject RightTypingHand; private void OnTriggerEnter(Collider c) { GameObject hand = c.gameObject; if (hand == null) return; if (hand == leftHand) LeftTypingHand.SetActive(true); else if (hand == RightHand) RightTypingHand.SetActive(true); } private void OnTriggerExit(Collider c) { GameObject hand = c.gameObject; if (hand == null) return; if (hand == leftHand) LeftTypingHand.SetActive(false); else if (hand == RightHand) RightTypingHand.SetActive(false); }}KeyboardButton 오브젝트 프리팹화숫자 자판 만들기아래의 1번 포지션부터 x -0.06씩 10번까지 생성문자 자판 만들기Numbers 오브젝트를 복사한 Letter 오브젝트 생성 후 빈 오브젝트(Row 1) 만들어서 버튼들을 하위로 넣는다.y -0.6씩 더해서 각각 이름을 변경한다.실행 화면normal 하위에 있던 numbers를 빼준다.대/소문자 변환 자판 만들기normal을 복사하고 복사한 오브젝트의 이름은 ‘Cpas’로 변경한다.이후 네임도 대문자로 변경 —&gt; 실행해본다.캡스락 변경 버튼을 만든다.프로젝트 뷰로 빼 두었던 ‘KeyboardButton’ 프리팹을 normal 하위에 불러오고 언팩한다.이름은 ‘Caps Button’으로 변경 후 포지션(-0.4, 0.03, 0.04) / 스케일 (2, 1, 1)로 변경한다.텍스트도 길어지므로 텍스트 스케일만 (0.5, 1, 1)로 변경해준다.그리고 하위 collider의 On Release() 이벤트에 KeyboardCapsPressed()를 매핑한다.Delete 자판 만들기대/소문자 변환 자판을 복사한다. 포지션은 (0.34, 0.03, 0.04) / 콜라이더에 Keyboard.DeleteChar()를 맵핑한다.Space 자판 만들기Delete 변환 자판을 복사한다. 포지션은 (-0.06, 0.03, -0.14) / 콜라이더에 Keyboard.InsertSpace()를 맵핑한다.지금까지의 최종 오브젝트의 모습과 Keyboard 매핑이다.타이핑 필드 만들기 Typing Area 3D Cube(Typing Collider)의 스케일은 Board의 스케일을 복사해서 붙여 넣어 준다. Typing Collider의 컴포넌트 중 메쉬 필터와 렌더러를 삭제하고 박스 콜라이더 사이즈가 5를 초과하지 않을 범위로 늘려준다. 그리고 isTrigger를 체크해준다.(사진에는 언체크 되어있음)이후 부모부터 키보드 레이어로 설정, 타이핑 에어리어 레이어는 인터렉티브로 설정모니터 만들기인풋필드가 중요하므로 UI 캔버스 / 이미지/ 인풋필드를 배치한 뒤 키보드의 스크립트에 매핑한다.매핑동영상에선 OVR SDK를 이용하지만 나는 XRI 기반 프로젝트를 제작하고 있으므로 이제부턴 다른 방법으로 진행한다.먼저 핸드 콘트롤러 부모에게 Hands 레이어를 지정한다.이후 빈 오브젝트를 핸드 콘트롤러 자식으로 만들고 콜라이더 지점을 만든 뒤 타이핑 핸드 레이어를 지정한다. 마지막으로 비활성화해준다.이후 매핑나머지 설정 Caps 오브젝트는 비활성화 해준다. Typing Area에 Rigidbody를 넣어주고 중력 언체크, 키네마틱 체크한다. 키보드 버튼 프리팹 내부에서 콜라이더를 그림과 같이 변경해준다.결과참고 사이트 VR Keyboard - Unity Tutorial for Oculus Quest" }, { "title": "Unity Firebase Error(유니티 파이어베이스 컴파일 에러)", "url": "/posts/Unity-Firebase-Error/", "categories": "Unity, Firebase", "tags": "Unity, Firebase", "date": "2022-10-05 00:00:00 +0900", "snippet": "유니티에 파이어베이스를 연동하고 실행하던 도중, 다음과 같은 에러가 발생했다. [ERROR]’Google.IOSResolver.dll’ [ERROR]’Firebase.Editor.dll’ will not not be loaded due to errors첫 번째 방법(구글 서비스 버전이 맞지 않을 때)Assets -&gt; External Depen...", "content": "유니티에 파이어베이스를 연동하고 실행하던 도중, 다음과 같은 에러가 발생했다. [ERROR]’Google.IOSResolver.dll’ [ERROR]’Firebase.Editor.dll’ will not not be loaded due to errors첫 번째 방법(구글 서비스 버전이 맞지 않을 때)Assets -&gt; External Dependency Manager -&gt; Version Handler -&gt; Update두 번째 방법빌드 세팅에서 안드로이드 플랫폼인지 확인 후 아니라면 스위치세 번째 방법Unity Hub에서 IOS를 설치참고 사이트 촙촙쓰 - 게임 개발중이오 Google.IOSResolver will not be loaded in 2021.1.11f1 and later" }, { "title": "22-10-05(수)", "url": "/posts/Diary-221005/", "categories": "Diary, 2022.10", "tags": "Diary", "date": "2022-10-05 00:00:00 +0900", "snippet": "프로젝트 VR Keyboard Unity Tutorial for Oculus Quest(유니티 XR 키보드 만들기)", "content": "프로젝트 VR Keyboard Unity Tutorial for Oculus Quest(유니티 XR 키보드 만들기)" }, { "title": "Unity Firebase Setting(유니티 파이어베이스 연동하기)", "url": "/posts/Unity-Firebase-Setting/", "categories": "Unity, Firebase", "tags": "Unity, Firebase", "date": "2022-10-04 00:00:00 +0900", "snippet": "파이어베이스 유니티 SDK 임포트준비물 파이어베이스 유니티 SDK 다운로드(1.7GB)링크에서 다운 받고 압축을 해제한다.유니티 2019버전 이상이라면 dotnet4의 폴더의 SDK를 사용한다.이 중에서 계정 인증을 사용하기 위해 ‘FirebaseAuth.unitypackage’ 을 프로젝트에 임포트한다.플랫폼 세팅Ctrl + Shift + B를 눌...", "content": "파이어베이스 유니티 SDK 임포트준비물 파이어베이스 유니티 SDK 다운로드(1.7GB)링크에서 다운 받고 압축을 해제한다.유니티 2019버전 이상이라면 dotnet4의 폴더의 SDK를 사용한다.이 중에서 계정 인증을 사용하기 위해 ‘FirebaseAuth.unitypackage’ 을 프로젝트에 임포트한다.플랫폼 세팅Ctrl + Shift + B를 눌러 빌드 세팅을 열어주고 안드로이드로 플랫폼 스위치해준다.식별자 확인파이어베이스 측에서 우리 프로젝트를 인식하려면 식별자가 필요하다.플레이어 세팅 —&gt; 안드로이드 설정에 패키지 네임을 홈페이지의 앱 등록란에 기입해준다.파이어베이스 측에서 신뢰할 수 있도록 앱 서명도 필요하다.※ 중요패스워드와 Alias 패스워드는 절대 잊으면 안됨!!프로젝트 생성홈페이지에 접속해 로그인 후 콘솔로 이동 Firebase Console 이동 프로젝트 추가 프로젝트 이름은 대/소 구분 안해도 된다. 구글 애널리틱스는 사용 안해도 된다. 프로젝트 내부에 접속하면 유니티 아이콘 클릭 앱 등록 과정에서 서비스할 플랫폼을 선택해준다. 이 과정은 나중에 다시 할 수 있으므로 한 플랫폼은 나중에 서비스 할 예정이라면 지금 안해도 된다.앱 등록 과정 이후파이어베이스에 접근하기 위한 인증 키, ID 등이 들어있는 .json 파일을 유니티 프로젝트에 임포트한다. SDK가 설치되어 있다면 이 .json파일을 자동으로 감지해서 변형해준다.이 과정은 이미 2단계 이전에 했으므로 다음으로 넘어간다.구글 파이어베이스 계정 인증 관련 서비스를 빌드하기 위해 다시 콘솔로 이동 후 아래의 사진으로 이동한다.이후 서비스 할 방법을 선택한다.그리고 파이어베이스가 신뢰 가능한 앱인지 확인할 수 있도록 디지털 지문을 기입해주어야 한다.디지털 지문을 추가하기 위해 윈도우의 경우 파워쉘, IOS는 터미널을 열어준다.경로는 본인이 지정한 .keystore로 한다.keytool -list -v -alias ugee -keystore ugee.keystore디지털 지문을 등록 후 최신 .json 파일을 다운받고 기존에 넣어 둔 파일을 지우고 교체한다.이후에 컬렉션이나 사용자를 생성하는 로직을 통해 관리한다.참고 사이트 유니티 멀티플레이어 네트워크 게임 한방에 만들기 (포톤 + 파이어베이스) 3/10" }, { "title": "22-10-04(화)", "url": "/posts/Diary-221004/", "categories": "Diary, 2022.10", "tags": "Diary", "date": "2022-10-04 00:00:00 +0900", "snippet": "프로젝트 플레이어 리깅 안됨 결과창 초기화 안됨 플레이어 키 조절 같이 움직이기 퀴즈 패널 정답 소리 안 들림 시연 영상 촬영", "content": "프로젝트 플레이어 리깅 안됨 결과창 초기화 안됨 플레이어 키 조절 같이 움직이기 퀴즈 패널 정답 소리 안 들림 시연 영상 촬영" }, { "title": "22-10-03(월)", "url": "/posts/Diary-221003/", "categories": "Diary, 2022.10", "tags": "Diary", "date": "2022-10-03 00:00:00 +0900", "snippet": "프로젝트 튜토리얼 완성/// &lt;summary&gt;/// TutorialManager.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (Eternal Light)/// This software is released under the GPL-2.0 license/// /// ...", "content": "프로젝트 튜토리얼 완성/// &lt;summary&gt;/// TutorialManager.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (Eternal Light)/// This software is released under the GPL-2.0 license/// /// - 튜토리얼 과정을 담당하는 스크립트입니다./// - TextAnimatorPlayer 클래스를 통해 Text Animation 에셋을 사용합니다./// - TutorialStart() 인터페이스에서 각 함수들이 yield return new WaitWhile(() =&gt; tutorialStep &lt; ?)의 제약동안 실행됩니다./// - Tuple방식(Vector3, Vector2, Quaternion)으로 리턴 값을 받는 XR_TutoCanvasSize() 메소드를 통해 캔버스 사이즈와 위치, 회전 값을 정의 했습니다./// &lt;/summary&gt;using Febucci.UI;using System.Collections;using UnityEngine;using UnityEngine.UI;public class TutorialManager : MonoBehaviour{ [Header(\"[UI]\")] public RectTransform xrTutoCanvas; public Button btnTutoNext; public TextAnimatorPlayer textAnimatorPlayer; [Header(\"[Message]\")] public int tutorialStep; public string[] textBox = { \"&lt;speed=0.5&gt;&lt;rainb f=0.2&gt;안녕하세요.&lt;/rainb&gt; 반갑습니다.\" + \"\\n지금부터 플레이 방법을 안내해드리겠습니다.\", \"&lt;speed=0.5&gt;아래의 &lt;rainb f=0.2&gt;[오리지널]&lt;/rainb&gt; 테마를 선택해주세요.\", \"&lt;speed=0.5&gt;노래&lt;rainb f=0.2&gt;[Cat Life]&lt;/rainb&gt;를 선택해주세요.\", \"&lt;speed=0.5&gt;난이도 &lt;rainb f=0.2&gt;[쉬움]&lt;/rainb&gt;을 선택해주세요.\", \"&lt;speed=0.5&gt;&lt;rainb f=0.2&gt;[플레이]&lt;/rainb&gt; 버튼을 눌러 게임을 시작합니다.\", \"&lt;speed=0.5&gt;&lt;size=7&gt;게임으로 진입했습니다.\" + \"\\n\\n좌측에는 획득한 &lt;bounce a=0.3 f=0.3&gt;점수&lt;/bounce&gt;와 &lt;bounce a=0.3 f=0.3&gt;소모된 칼로리&lt;/bounce&gt;가 표시됩니다.\" + \"\\n동작 또는 퀴즈에 성공하면 점수와 콤보가 오릅니다.\" + \"\\n동작에 성공하면 소모량이 오릅니다.\" + \"\\n\\n우측 하단에서 &lt;bounce a=0.3 f=0.3&gt;자신의 동작을 확인&lt;/bounce&gt;할 수 있습니다.\" + \"\\n\\n바닥에는 &lt;bounce a=0.3 f=0.3&gt;노래의 길이&lt;/bounce&gt;를 알 수 있습니다.\", \"&lt;speed=0.5&gt;모션 패널을 해결해보세요.\", \"&lt;speed=0.5&gt;장애물 패널이 나왔습니다.\" + \"\\n몸을 이동하여 피해주세요.\" + \"\\n피격 시 콤보와 점수를 잃습니다.\", \"&lt;speed=0.5&gt;퀴즈 패널이 나왔습니다.\" + \"\\n좌/우로 색상과 글귀를 제시 받습니다.\\n동작을 해결하면서 외워주세요.\", \"&lt;speed=0.5&gt;정답을 맞추는 패널입니다.\" + \"\\n외웠던 색상과 글귀가 일치하는 방향을 선택하세요.\", \"&lt;speed=0.5&gt;노래를 완수하게 되면 결과창이 표시됩니다.\" + \"\\n노래 제목/난이도/점수/소모된 칼로리를 알 수 있습니다.\" + \"\\n메인으로 돌아갑시다.\", \"&lt;speed=0.5&gt;밝기와 키 조절은 로비의 왼쪽에 있습니다.\" + \"\\n튜토리얼을 마치겠습니다.\" }; [Header(\"[Panel]\")] public GameObject[] tutoPanels; public int tutoPanelSpawnCount; public int tutoPanelDestroyCount; public float tutoMoveSpeed = 2.0f; [Header(\"[Music]\")] public float tutoSecPerBeat = 3.5f; public float tutoPanelTimer; // BPM 계산 타이머 [Header(\"[플래그 변수]\")] public bool isTutorial; public bool isMotionClear; public bool isObstacleClear; public bool isMotionQuizClear; public bool isQuizClear; public static TutorialManager instance; private void Awake() { if (instance == null) instance = this; else Destroy(gameObject); // Reset tutorialStep = 0; isMotionClear = false; isObstacleClear = false; isMotionQuizClear = false; isQuizClear = false; UnityEngine.Assertions.Assert.IsNotNull(textAnimatorPlayer, $\"Text Animator Player component is null in {gameObject.name}\"); //textAnimatorPlayer.textAnimator.onEvent += OnEvent; } private void FixedUpdate() { // 모션 패널 시작 했을 때 if (tutorialStep == 7 &amp;&amp; !isMotionClear) { PanelSpawn(); if (tutoPanelDestroyCount == 3) tutorialStep++; } // 장애물 패널 시작했을 때 else if (tutorialStep == 9 &amp;&amp; !isObstacleClear) { PanelSpawn(); if (tutoPanelDestroyCount == 4) tutorialStep++; } // 모션 퀴즈 패널 시작했을 때 else if (tutorialStep == 11 &amp;&amp; !isMotionQuizClear) { PanelSpawn(); if (tutoPanelDestroyCount == 5) tutorialStep++; } // 퀴즈 패널 시작했을 때 else if (tutorialStep == 13 &amp;&amp; !isQuizClear) { PanelSpawn(); if (tutoPanelDestroyCount == 6) tutorialStep++; } } public IEnumerator TutorialStart() { Step1(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 1); Step2(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 2); Step3(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 3); Step4(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 4); Step5(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 5); Step6(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 6); Step7(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 7); Step8(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 8); Step9(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 9); Step10(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 10); Step11(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 11); Step12(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 12); Step13(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 13); Step14(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 14); Step15(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 15); Step16(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 16); Step17(); yield return new WaitWhile(() =&gt; tutorialStep &lt; 17); } public (Vector3, Vector2, Quaternion) XR_TutoCanvasSize() { if (tutorialStep == 0) return (new Vector3(0f, 2f, 1f), new Vector2(200f, 50f), Quaternion.Euler(10f, 0f, 0f)); else if (tutorialStep == 1) return (new Vector3(0f, 2.65f, 1f), new Vector2(150f, 20f), Quaternion.Euler(0f, 0f, 0f)); else if (tutorialStep == 5) return (new Vector3(0f, 2.25f, 1f), new Vector2(200f, 110f), Quaternion.Euler(0f, 0f, 0f)); else if (tutorialStep == 14) return (new Vector3(0f, 2.9f, 0.9f), new Vector2(220f, 70f), Quaternion.Euler(-15f, 0f, 0f)); else if (tutorialStep == 15) return (new Vector3(0f, 2.7f, 1f), new Vector2(180f, 40f), Quaternion.Euler(-10f, 0f, 0f)); else return (new Vector3(0f, 0f, 0f), new Vector2(0f, 0f), Quaternion.identity); } // 튜토리얼 시작 안내 void Step1() { GameManager.instance.uiTutorial.SetActive(true); GameManager.instance.uiLobby.SetActive(false); (xrTutoCanvas.transform.position, xrTutoCanvas.sizeDelta, xrTutoCanvas.transform.rotation) = XR_TutoCanvasSize(); textAnimatorPlayer.ShowText(textBox[0]); } // Theme(Original) 선택 void Step2() { // Tutorial Button OFF btnTutoNext.interactable = false; // UI Lobby ON GameManager.instance.uiLobby.SetActive(true); // UI Option(Lobby Left UI) OFF GameManager.instance.option.SetActive(false); // UI Result(Lobby Right UI) OFF GameManager.instance.result.SetActive(false); // Original Theme Select ON GameManager.instance.btnOriginal.interactable = true; // Custom Theme Select OFF GameManager.instance.btnCustom.interactable = false; // Easy OFF GameManager.instance.btnEasy.interactable = false; // Normal OFF GameManager.instance.btnNormal.interactable = false; // Hard OFF GameManager.instance.btnHard.interactable = false; // Play OFF GameManager.instance.btnPlay.interactable = false; foreach (Transform item in GameManager.instance.contentOriginal.transform) Destroy(item.gameObject); (xrTutoCanvas.transform.position, xrTutoCanvas.sizeDelta, xrTutoCanvas.transform.rotation) = XR_TutoCanvasSize(); textAnimatorPlayer.ShowText(textBox[1]); } // Music(Cat Life) 선택 void Step3() { // Custom Theme Select OFF GameManager.instance.btnCustom.interactable = false; textAnimatorPlayer.ShowText(textBox[2]); } // Level(Easy) 선택 void Step4() { // Easy ON GameManager.instance.btnEasy.interactable = true; // Normal OFF GameManager.instance.btnNormal.interactable = false; // Hard OFF GameManager.instance.btnHard.interactable = false; // Music Element OFF GameManager.instance.contentOriginal.transform.GetChild(0).GetComponent&lt;Button&gt;().interactable = false; textAnimatorPlayer.ShowText(textBox[3]); } // Play 버튼 안내 void Step5() { // Easy OFF GameManager.instance.btnEasy.interactable = false; // Normal OFF GameManager.instance.btnNormal.interactable = false; // Hard OFF GameManager.instance.btnHard.interactable = false; textAnimatorPlayer.ShowText(textBox[4]); } // 인게임 요소 설명 void Step6() { // Tutorial Button ON btnTutoNext.interactable = true; // TimeStop, HandChange StartCoroutine(TimeStop()); (xrTutoCanvas.transform.position, xrTutoCanvas.sizeDelta, xrTutoCanvas.transform.rotation) = XR_TutoCanvasSize(); textAnimatorPlayer.ShowText(textBox[5]); } // 모션 패널 안내 void Step7() { textAnimatorPlayer.ShowText(textBox[6]); } // 모션 패널 시작 void Step8() { // UI Tutorial OFF GameManager.instance.uiTutorial.SetActive(false); // TimeStart, HandChange StartCoroutine(TimeStart()); } // 장애물 패널 안내 void Step9() { // 모션 패널 클리어 isMotionClear = true; // UI Tutorial ON GameManager.instance.uiTutorial.SetActive(true); // TimeStop, HandChange StartCoroutine(TimeStop()); textAnimatorPlayer.ShowText(textBox[7]); } // 장애물 패널 시작 void Step10() { // UI Tutorial OFF GameManager.instance.uiTutorial.SetActive(false); // TimeStart, HandChange StartCoroutine(TimeStart()); } // 모션 퀴즈 패널 안내 void Step11() { // 장애물 패널 클리어 isObstacleClear = true; // UI Tutorial ON GameManager.instance.uiTutorial.SetActive(true); // TimeStop, HandChange StartCoroutine(TimeStop()); textAnimatorPlayer.ShowText(textBox[8]); } // 모션 퀴즈 패널 시작 void Step12() { // UI Tutorial OFF GameManager.instance.uiTutorial.SetActive(false); // TimeStart, HandChange StartCoroutine(TimeStart()); } // 퀴즈 패널 안내 void Step13() { // 모션 퀴즈 패널 클리어 isMotionQuizClear = true; // UI Tutorial ON GameManager.instance.uiTutorial.SetActive(true); // TimeStop, HandChange StartCoroutine(TimeStop()); textAnimatorPlayer.ShowText(textBox[9]); } // 퀴즈 패널 시작 void Step14() { // UI Tutorial OFF GameManager.instance.uiTutorial.SetActive(false); // TimeStart, HandChange StartCoroutine(TimeStart()); } // 결과창 출력 void Step15() { (xrTutoCanvas.transform.position, xrTutoCanvas.sizeDelta, xrTutoCanvas.transform.rotation) = XR_TutoCanvasSize(); // 퀴즈 패널 클리어 isQuizClear = true; // Tutorial Button OFF btnTutoNext.interactable = false; // UI Tutorial ON GameManager.instance.uiTutorial.SetActive(true); // TimeStop, HandChange StartCoroutine(TimeStop()); textAnimatorPlayer.ShowText(textBox[10]); GameManager.instance.InGameEnd(); foreach (Transform item in GameManager.instance.contentOriginal.transform) Destroy(item.gameObject); } // 옵션 안내 후 종료 void Step16() { (xrTutoCanvas.transform.position, xrTutoCanvas.sizeDelta, xrTutoCanvas.transform.rotation) = XR_TutoCanvasSize(); // Tutorial Button ON btnTutoNext.interactable = true; textAnimatorPlayer.ShowText(textBox[11]); } // 초기화 및 로비 void Step17() { Time.timeScale = 1; // UI Tutorial OFF GameManager.instance.uiTutorial.SetActive(false); // UI Option(Lobby Left UI) ON GameManager.instance.option.SetActive(true); // UI Result(Lobby Right UI) ON GameManager.instance.result.SetActive(true); // Original Theme Select ON GameManager.instance.btnOriginal.interactable = true; // Custom Theme Select ON GameManager.instance.btnCustom.interactable = true; tutorialStep = 0; tutoPanelSpawnCount = 0; tutoPanelDestroyCount = 0; tutoPanelTimer = 0; isMotionClear = false; isObstacleClear = false; isMotionQuizClear = false; isQuizClear = false; isTutorial = false; StopCoroutine(TutorialStart()); } // [OnClick] tutorialStep++ public void TutorialStep() { if (isTutorial) tutorialStep++; } // [OnClick] 로비 ---&gt; 튜토리얼 버튼 public void BtnTuto() { isTutorial = true; GameManager.instance.musicBackGround.UnPause(); GameManager.instance.musicSelected.Stop(); StartCoroutine(TutorialStart()); } // [Onclick] 오리지널 버튼 클릭 public void TutorialListRenewal() { if (isTutorial) { foreach (Transform item in GameManager.instance.contentOriginal.transform) Destroy(item.gameObject); object tutorialMusic = Resources.Load&lt;AudioClip&gt;(\"Original Music/Cat life\"); GameObject tutorialMusicElementPrefab = tutorialMusic as GameObject; tutorialMusicElementPrefab = Instantiate(GameManager.instance.musicElement, GameManager.instance.contentOriginal.transform.position, GameManager.instance.contentOriginal.transform.rotation); tutorialMusicElementPrefab.name = \"Tutorial Music Element\"; tutorialMusicElementPrefab.transform.parent = GameManager.instance.contentOriginal.transform; tutorialMusicElementPrefab.transform.localScale = Vector3.one; // AudioSource.clip ← Resources-Custom Musics.AudioClip tutorialMusicElementPrefab.transform.GetChild(3).gameObject.GetComponent&lt;AudioSource&gt;().clip = (AudioClip)tutorialMusic; // (float)MusicLength to (string)PlayTime tutorialMusicElementPrefab.transform.GetChild(2).gameObject.GetComponent&lt;Text&gt;().text = GameManager.instance.TimeFormatter(tutorialMusicElementPrefab.transform.GetChild(3).gameObject.GetComponent&lt;AudioSource&gt;().clip.length, false); // textTitle.text ← customMusicElements.AudioSource.text tutorialMusicElementPrefab.transform.GetChild(1).gameObject.GetComponent&lt;Text&gt;().text = tutorialMusicElementPrefab.transform.GetChild(3).gameObject.GetComponent&lt;AudioSource&gt;().clip.name; } } public IEnumerator TimeStart() { Time.timeScale = 1; GameManager.instance.musicPlayed.UnPause(); GameManager.instance.isHandChange = true; GameManager.instance.ControllerModeChange(); yield return null; } public IEnumerator TimeStop() { Time.timeScale = 0; GameManager.instance.musicPlayed.Pause(); GameManager.instance.isHandChange = false; GameManager.instance.ControllerModeChange(); yield return null; } public void PanelSpawn() { PanelManager.instance.PanelCheck(); tutoPanelTimer += Time.deltaTime; if (tutoPanelTimer &gt; tutoSecPerBeat) { tutoPanelTimer -= tutoSecPerBeat; if (tutoPanelSpawnCount == 0) { GameObject _motion = Instantiate(tutoPanels[0], PanelManager.instance.panelSpawnPoint); _motion.name = \"MOTION\"; tutoPanelSpawnCount++; } else if (tutoPanelSpawnCount == 1) { GameObject _motion = Instantiate(tutoPanels[1], PanelManager.instance.panelSpawnPoint); _motion.name = \"MOTION\"; tutoPanelSpawnCount++; } else if (tutoPanelSpawnCount == 2) { GameObject _motion = Instantiate(tutoPanels[2], PanelManager.instance.panelSpawnPoint); _motion.name = \"MOTION\"; tutoPanelSpawnCount++; } else if (tutoPanelSpawnCount == 3) { GameObject _block = Instantiate(tutoPanels[3], PanelManager.instance.panelSpawnPoint); _block.name = \"BLOCK\"; tutoPanelSpawnCount++; } else if (tutoPanelSpawnCount == 4) { GameObject _motion = Instantiate(tutoPanels[4], PanelManager.instance.panelSpawnPoint); _motion.name = \"MOTION\"; _motion.transform.GetChild(4).gameObject.SetActive(true); tutoPanelSpawnCount++; } else if (tutoPanelSpawnCount == 5) { Debug.Log(\"퀴즈 패널 생성\"); GameObject _quiz = Instantiate(tutoPanels[5], PanelManager.instance.panelSpawnPoint); _quiz.name = \"QUIZ\"; tutoPanelSpawnCount++; } } }}결과참고 사이트 유니티로 튜토리얼 화면 구현해 보기 Unity C# – Coroutine 알아보기 Unity Chapter 8-5. C# 프로그래밍 [고급] : 람다 함수" }, { "title": "22-09-29(목)", "url": "/posts/Diary-220929/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-29 00:00:00 +0900", "snippet": "프로젝트 [ ~ 10/06] 튜토리얼 형태 사진 必(1.장애물 피하기, 2.퀴즈 하기, 3.모션 하기) 위의 튜토리얼과 아바타가 들어간 Play 영상 촬영 [ ~ 10/11] UI(기본X, 실제 서비스 중인 게임처럼 보이도록 디테일 올릴 것) 튜토리얼 완성 플레이어 아바타 VR 리깅자신의 동작을 확인할 수 있는 카...", "content": "프로젝트 [ ~ 10/06] 튜토리얼 형태 사진 必(1.장애물 피하기, 2.퀴즈 하기, 3.모션 하기) 위의 튜토리얼과 아바타가 들어간 Play 영상 촬영 [ ~ 10/11] UI(기본X, 실제 서비스 중인 게임처럼 보이도록 디테일 올릴 것) 튜토리얼 완성 플레이어 아바타 VR 리깅자신의 동작을 확인할 수 있는 카메라와 UI 제작참고 사이트 FPS Microgame) FPS Mod: CCTV live in-game camera feed튜토리얼 내용플레이에 흥미를 먼저 느낄 수 있도록 하기 위해 게임 이후에 옵션 세팅에 대해 안내한다.Do Play・ Select Music Theme・ Select to Music in Music List・ Select to Level・ Score, Kcal, SubCamera, PlayTimeBar Info・ Motion Panel(x3)・ Obstacle Panel・ Motion Quiz Panel・ Quiz Answer Panel・ Result Info・ End(Bright, Height Setting Info)Text Animator for Unity / 텍스트 애니메이션 구매 Documentation Text Animator for Unity / 텍스트 애니메이션" }, { "title": "Unity VR Making Body(바디 리깅 구현하기)", "url": "/posts/Unity-VR-Making-Body/", "categories": "Unity, Unity VR", "tags": "Unity, Unity VR", "date": "2022-09-28 00:00:00 +0900", "snippet": "통상적으로 모든 3D 캐릭터에게 적용이 가능함사용 중인 유니티 버전이 2019.2 버전 이상이어야 한다.프로젝트에 이용할 3D 캐릭터를 준비한다.예시에서는 ‘Space Robot Kyle’에셋을 사용한다.또 ‘Animation Rigging’패키지를 설치한다.3D 캐릭터의 메쉬 데이터와 골격, 애니메이션이 포함되어 있다.관절의 각 부위를 회전하는 건 ...", "content": "통상적으로 모든 3D 캐릭터에게 적용이 가능함사용 중인 유니티 버전이 2019.2 버전 이상이어야 한다.프로젝트에 이용할 3D 캐릭터를 준비한다.예시에서는 ‘Space Robot Kyle’에셋을 사용한다.또 ‘Animation Rigging’패키지를 설치한다.3D 캐릭터의 메쉬 데이터와 골격, 애니메이션이 포함되어 있다.관절의 각 부위를 회전하는 건 가능하다.하지만 애니메이션 리깅 패키지가 없다면 트랜스폼을 변경했을 때 관절이 분리되는 문제가 발생한다.모든 관절이 정상이라면 이제 최상위 부모로 돌아가 Rig Builder 스크립트를 가져온다.아래에 새로 생긴 애니메이터 컴포넌트를 이용하므로 애니메이션 컴포넌트는 삭제해준다.그리고 캐릭터의 뼈대 구조를 더 나은 방식으로 표시하는 Bone Renderer 스크립트를 컴포넌트로 불러온다.사용 방법은 아래의 트랜스폼 배열에 모든 관절들을 적용한다.이렇게 관절 구조가 연결되어 있는 모습을 확인할 수 있다.이후 최상위 부모에게 빈 오즈젝트를 VR Constraints(VR 제약조건)이라는 이름으로 생성해준다. 그리고 컴포넌트로 Rig 스크립트를 넣어주고, 부모의 Rig Builder 컴포넌트에 드래그&amp;드랍해준다.또, VR Constraints의 하위로 빈 오젝트를 만들어 아래와 같이 세팅해준다. 이것이 이동을 담당해주는 구서 요소가 된다.이제 컴포넌트에 하나씩 추가 해주는데, 좌물쇠를 걸어두고 씬 뷰에 표시된 관절선 중 필요한 관절을 클릭해서 확인한다.아래의 타겟과 힌트 트랜스폼이 남았다. 먼저 Right Arm IK의 하위로 빈 오브젝트 두 개를 생성해준다.타겟 개체를 선택하고 Shift를 누른 상태로 대상을 배치 할 뼈를 선택합니다.이젠 애니메이션 리깅 단계입니다. 아래의 속성을 클릭하면 타겟 게임 오브젝트와 손 뼈의 위치가 일치하는 것을 볼 수 있습니다. 힌트 게임 오브젝트도 오른쪽 팔꿈치와 같이 잡고 똑같은 작업을 해줍니다.이제 플레이 해봅니다. 타겟과 힌트의 트랜스폼을 변경하면 붙은 관절들이 같이 움직이는 걸 볼 수 있습니다.성공했다면 이제 왼쪽 팔도 동일하게 적용 하면 됩니다.이 단계에서 다리에도 동일한 작업을 수행하고 애니메이션을 사용할 수 있습니다.이번엔 머리를 구성할 차례입니다. 머리를 구성하게 된 다면 훨씬 자유로운 느낌을 줄 수 있습니다.VR Constraints의 하위로 Head Constraint 이름의 빈 오브젝트를 생성한 뒤 Multi Parent Constraint 스크립트를 컴포넌트로 추가해줍니다.마찬가지로 좌물쇠를 걸고 헤드를 찾아 제약 오브젝트에 걸어줍니다.Source Objects에는 자신(Head Constraint가 들어갑니다.)이후 Head와 같이 잡고 Align Transform 해줍니다.하지만 아직 머리가 한 없이 한 방향으로 돌아간다거나 팔 관절과 자연스러운 운동이 안되는 문제가 있습니다.부모에게 돌아가 VRRig스크립트를 생성해줍니다./// VRRig.csusing UnityEngine;public class VRRig : MonoBehaviour{ // Add Call Add 제약을 위한 두 개의 실행 가능한 필록 전송 변수 public Transform headConstraint; // 머리와 몸체 사이의 초기 위치 차이가 될 집합 변수 public Vector3 headBodyOffset; private void Start() { // 최초에 위치 변환을 해준다. headBodyOffset = transform.position - headConstraint.position; } private void Update() { // 머리 위치에 따라 몸체는 수시로 변화한다. // 머리의 위치에 오프셋을 추가한 포지션 값을 부모에게 전달한다. transform.position = headConstraint.position + headBodyOffset; // 이 부분은 3D 캐릭터의 헤드 축에 따라서 수시로 변경되어야 한다. // Robot Kyle의 경우 머리는 정면이 녹색(y)축이므로 걸음에 up을 넣어준다. transform.forward = Vector3.ProjectOnPlane(headConstraint.up, Vector3.up).normalized; }}스크립트를 적용하고 플레이 해봅니다.그렇게 되면 한없이 앞으로 달려가는 걸 볼 수 있습니다. 하지만 이 것이 정상적으로 완성된 모습입니다. 왜냐하면 머리와 함께 몸을 움직였기 때문입니다.앞으로 해결해야 할 부분은 항상 머리의 위치를 조정하고 나중에 컨트롤러와 플레이어 세트와 일치하도록 해야합니다.스크립트를 다음과 같이 변경합니다./// VRRig.csusing UnityEngine;// 직렬화를 통해 다른 클래스도 인스펙터창에서 확인[System.Serializable]public class VRMap{ // VR 타겟이라는 VR 변환을 위해 실행 가능한 클래스 4가지 public Transform vrTarget; public Transform rigTarget; public Vector3 trackingPositionOffset; public Vector3 trackingRotationOffset; public void Map() { rigTarget.position = vrTarget.TransformPoint(trackingPositionOffset); rigTarget.rotation = vrTarget.rotation * Quaternion.Euler(trackingRotationOffset); }}public class VRRig : MonoBehaviour{ public VRMap head; public VRMap leftHand; public VRMap rightHand; // Add Call Add 제약을 위한 두 개의 실행 가능한 필록 전송 변수 public Transform headConstraint; // 머리와 몸체 사이의 초기 위치 차이가 될 집합 변수 public Vector3 headBodyOffset; private void Start() { // 최초에 위치 변환을 해준다. headBodyOffset = transform.position - headConstraint.position; } private void Update() { // 머리 위치에 따라 몸체는 수시로 변화한다. // 머리의 위치에 오프셋을 추가한 포지션 값을 부모에게 전달한다. transform.position = headConstraint.position + headBodyOffset; // 이 부분은 3D 캐릭터의 헤드 축에 따라서 수시로 변경되어야 한다. // Robot Kyle의 경우 머리는 정면이 녹색(y)축이므로 걸음에 up을 넣어준다. transform.forward = Vector3.ProjectOnPlane(headConstraint.up, Vector3.up).normalized; head.Map(); leftHand.Map(); rightHand.Map(); }}이후 컴포넌트에서 연결해주고 나서 연결할 때 XRI 기준으로 아래와 같이 하면 될 거 같다. 나중엔 오프셋에 넣어서 만들면 될 거 같다.아래의 사진은 본체에 가려서 앞을 못 보는 것을 오프셋으로 조정하는 것이고, 또한 목이 돌아가 있는 부분도 모델 기준으로 회전값을 넣은 것이다. 그리고 손도 자연스럽게 보정해준 값이다.아직 개선할 부분으로 캐릭터 팔이 다 뻗을 수 있도록 실제 팔 길이와 캐릭터의 팔 길이를 맞춰주어야 합니다. 이는 캐릭터의 크기를 키우는 방법으로 해결할 수 있습니다. 스크립트를 아래와 같이 수정하면 더 자연스러운 결과를 볼 수 있습니다.using UnityEngine;// 직렬화를 통해 다른 클래스도 인스펙터창에서 확인[System.Serializable]public class VRMap{ // VR 타겟이라는 VR 변환을 위해 실행 가능한 클래스 4가지 public Transform vrTarget; public Transform rigTarget; public Vector3 trackingPositionOffset; public Vector3 trackingRotationOffset; public void Map() { rigTarget.position = vrTarget.TransformPoint(trackingPositionOffset); rigTarget.rotation = vrTarget.rotation * Quaternion.Euler(trackingRotationOffset); }}public class VRRig : MonoBehaviour{ public VRMap head; public VRMap leftHand; public VRMap rightHand; // Add Call Add 제약을 위한 두 개의 실행 가능한 필록 전송 변수 public Transform headConstraint; // 머리와 몸체 사이의 초기 위치 차이가 될 집합 변수 public Vector3 headBodyOffset; public int turnSmoothness; private void Start() { // 최초에 위치 변환을 해준다. headBodyOffset = transform.position - headConstraint.position; } private void Update() { // 머리 위치에 따라 몸체는 수시로 변화한다. // 머리의 위치에 오프셋을 추가한 포지션 값을 부모에게 전달한다. transform.position = headConstraint.position + headBodyOffset; // 이 부분은 3D 캐릭터의 헤드 축에 따라서 수시로 변경되어야 한다. // Robot Kyle의 경우 머리는 정면이 녹색(y)축이므로 걸음에 up을 넣어준다. transform.forward = Vector3.Lerp(transform.forward, Vector3.ProjectOnPlane(headConstraint.up, Vector3.up).normalized, Time.deltaTime * turnSmoothness); head.Map(); leftHand.Map(); rightHand.Map(); }}결과하체는 2부에서 제작할 예정 필요에 따라 할 수도~?참고 사이트 Valem - VR에서 바디를 만드는 방법 - 1부" }, { "title": "22-09-28(수)", "url": "/posts/Diary-220928/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-28 00:00:00 +0900", "snippet": "프로젝트 플레이어 애니메이션 추가 플레이어와 컨트롤러 결합 자신의 동작을 확인할 수 있는 카메라와 UI 제작 결제 시스템 추가", "content": "프로젝트 플레이어 애니메이션 추가 플레이어와 컨트롤러 결합 자신의 동작을 확인할 수 있는 카메라와 UI 제작 결제 시스템 추가" }, { "title": "22-09-27(화)", "url": "/posts/Diary-220927/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-27 00:00:00 +0900", "snippet": "프로젝트 인게임 플레이 타임 슬라이드 바 50% 적용/// PlayHeadControls.cs private void Awake() { GameManager.instance.inGameSlider.minValue = 0; GameManager.instance.inGameSlider.value = 0; } ...", "content": "프로젝트 인게임 플레이 타임 슬라이드 바 50% 적용/// PlayHeadControls.cs private void Awake() { GameManager.instance.inGameSlider.minValue = 0; GameManager.instance.inGameSlider.value = 0; } void FixedUpdate() { if (GameManager.instance.isStart) { if (!GameManager.instance.btnHalf.interactable) { GameManager.instance.inGameSlider.maxValue = (GameManager.instance.musicPlayed.clip.length * GameManager.instance.musicPlayed.clip.frequency * GameManager.instance.musicPlayed.clip.channels / 2) - 1; Event(); } else if (!GameManager.instance.btnAll.interactable) { GameManager.instance.inGameSlider.maxValue = (GameManager.instance.musicPlayed.clip.length * GameManager.instance.musicPlayed.clip.frequency * GameManager.instance.musicPlayed.clip.channels) - 1; Event(); } } }결과" }, { "title": "22-09-26(월)", "url": "/posts/Diary-220926/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-26 00:00:00 +0900", "snippet": "설문지 작성 목차 설문지의 개념 설문지 작성과정 설문지의 작성절차 설문지 작성시 고려사항 설문지 작성시의 기본 원칙 설문지의 형식 설문지의 구성 설문문항 배열의 원칙 ...", "content": "설문지 작성 목차 설문지의 개념 설문지 작성과정 설문지의 작성절차 설문지 작성시 고려사항 설문지 작성시의 기본 원칙 설문지의 형식 설문지의 구성 설문문항 배열의 원칙 설문지의 사전조사 설문지는 통계조사에 있어서 매우 중요한 역할을 한다. 설문지는 원칙적으로 스스로가 자신의 의견을 기입할 수 있도록 작성된 조사표라고 할 수 있다. 설문지를 이용한 조사는 사회조사, 여론조사, 교육연구조사 등에 있어서 매우 광범위하게 이용된다. 설문지는 연구조사과정에서 조사목적에 맞는 유용한 자료를 수집하는 수단이며, 이를 통해 얻어진 자료를 분석하여 조사의 결론에 도달하는 중요한 부분이다. 따라서 설문지를 작성할 때는 조사목적에 맞는 필요한 정보, 자료의 종류와 측정방법, 분석의 내용과 방법까지를 고려하여 신중히 작성되어야 한다. 여기에서는 설문지 작성과정, 설문지 작성시 기본원칙, 설문지 형식, 설문지의 예 등을 살펴보기로 한다.1.설문지의 개념사회조사의 대부분은 우리가 측정할 수 없는 개념을 설문지를 통해서 계량화함으로써 통계분석이 가능하게 된다. 질문지란 연구자가 조사하고자 하는 일련의 질문들을 체계적으로 담고 있는 작은 책자로서, 응답자에게 배포하여 스스로 기입하게 하는 것이다. 질문지라는 용어는 때로는 설문지, 질문서 등의 용어로도 사용되고 있다.질문지를 사용하는 가장 큰 목적은 모든 응답자들에게 동일한 형식으로 질문하게 함으로써 측정의 오차를 최소화하는 데 있다. 그리고 표준화된 질문지는 응답자로 하여금 빠른 시간 안에 쉽고 정확한 응답을 할 수 있게 한다. 질문지 작성은 조사의 성패를 좌우하는 중요한 요소로 질문지의 작성이 잘못되면 조사목적에 부합되는 자료를 얻을 수 없고, 분석결과 또한 잘못될 수밖에 없다.2.설문지 작성과정설문지는 아무리 뛰어난 전문가라 하더라도 한 번 작성된 초안으로 의도된 자료를 얻을 수는 없다. 설문지를 작성하기 위해서는 설문지를 작성하기 위한 단계를 정해놓고, 각 단계별로 수시로 문제점을 파악하여 수정 보완해 나가야 나중에 발생할 수 있는 문제점들을 미리 줄이거나 막을 수 있게 된다.설문지를 작성하기 위한 일반적인 단계는 다음과 같다.. ① 필요한 정보의 결정. ② 자료수집방법의 결정. ③ 개별항목의 내용결정. ④ 질문형태의 결정. ⑤ 개별문항의 완성. ⑥ 질문의 수와 순서결정. ⑦ 설문지의 외형결정. ⑧ 설문지의 사전조사. ⑨ 설문지 완성3.설문지의 작성 절차⑴ 연구 목적 및 주제, 시간과 비용, 조사인력 등을 신중히 검토하여 적합한 자료 수집 방법을 결정한다. 자료수집방법을 먼저 결정하는 것은 자료수집방법에 따라 질문지의 형태와 설명정도가 달라지기 때문이다.⑵ 얻고자 하는 내용에 따라 질문의 내용을 결정한다. 응답자의 사회경제적인 내용 : 성별, 나이, 혼인여부, 자녀, 교육수준, 직업, 소득, 가입단체 등 가치관, 만족도, 어떤 현상이나 사실에 대한 믿음, 태도, 느낌 등 ⑶ 자료수집방법과 질문의 내용에 따라 질문의 방법과 형식, 문항의 배열 순서에 대하여 생각한다. 대개 응답자의 사생활에 대한 질문은 어느 정도 대화 분위기가 조성된 이후에 하는 것이 좋다. 즉, 제일 뒷부분에 배치하는 것이 적합하다.⑷ 구체적인 질문문항들을 배열하여 질문지 초안을 만든다. 좋은 질문지는 몇 번의 검토작업을 통해서 얻어지게 된다. 따라서 질문지를 만드는데는 충분한 시간적 여유가 필요하다.⑸ 질문지가 일단 만들어지면 인사말과 응답요령을 준비한다.⑹ 질문내용을 검토 보완한 후 사전조사를 실시한 후 질문지를 재수정한다. 사전조사를 통하여 질문지의 내용의 타당성, 조사상의 문제점 등을 알아 볼 수 있다.⑺ 가능하면 부호화를 위한 지침이나 사전에 부호화의 틀을 마련하는 것이 좋다.⑻ 마지막으로 질문지를 보기 좋은 모양으로 인쇄한다. 인쇄를 할 때는 약 20%의 여유를 가지고 하는 것이 좋다.4.설문지 작성시 고려 사항⑴ 가치중립성질문을 만드는 데 있어서 가장 중요한 것은 조사자의 가치판단을 배제하고 중립적인 질문이 되도록 질문을 만드는 것이다.⑵ 균형성상반된 의견이 있을 수 있는 질문을 할 경우에는 어느 한 쪽으로 치우치지 않도록 같은 비중으로 다루어 주어야 한다. 예를 들면 “교사가 체벌하는 것은 곤란하다고 생각하십니까?”라는 이러한 질문은 균형성을 잃은 질문이다.이러한 질문은 “교사의 체벌에 대해 어떻게 생각하십니까?” 등으로 바뀌어야 한다.​⑶ 응답범주폐쇄형의 질문의 경우, 응답범주간의 거리가 동일하도록 해야 하며, 상반되는 응답간에는 균형이 유지되도록 보기를 주어야 한다.예를 들면 “아주 잘함, 잘함, 보통, 못함” 등으로 응답범주가 구성되어 있는 경우에는 균형을 잃고 있으므로 “아주 못함”이라는 응답범주를 추가해야 한다.일부 정치단체의 경우 불순한 목적아래 다음과 같은 항목을 만들어 조사하는 경우가 있다. 이러한 경우는 조사결과의 신뢰성이 매우 낮다고 볼 수 있다.​. 예) OO한 정책에 대해서 귀하는 어떻게 생각하십니까?. . 가. 매우 찬성 나. 일부 찬성 다. 중립 라. 반대. . * 찬성 응답범주가 2개인 반면, 반대 범주는 1개이므로 찬성을 유도하기 위한 질문이 된다.⑷ 질문은 간결하고 명료해야 한다. (간결성, 명료성)⑸ 질문은 응답자의 교육수준을 고려하여 사용하되 쉬운 단어를 사용해야 한다.⑹ 한 문항은 한 가지 내용만을 묻도록 하고, 복합적인 질문은 피해야 한다. 두 가지 이상의 질문을 한 문항으로 묶어서 하게 되면, 응답에 어려움을 느낄 뿐 아니라 분석에서도 혼란을 초래할 수 있다.⑺ 가정을 전제로 한 질문이나 규범적으로 분명한 정답이 있는 질문은 하지 않는 것이 좋다. 그리고 조사결과를 처리하기 편리하도록 각 응답지에 사전에 번호를 부여해 놓는 것이 편리하다.5.설문지 작성시의 기본 원칙설문지는 자료를 수집하기 위한 여러 개의 문항으로 구성되며 그 형태도 다양하다. 설문지를 작성하기 위해서는 조사목적에 맞도록 필요한 정보, 자료의 종류, 측정방법 등을 신중히 고려한 뒤에 설문지 문항의 작성에 들어가게 된다.설문지 작성에 있어서 가장 핵심이 되는 것은 언어 사용문제이다. 사용된 언어는 응답자의 반응에 큰 영향을 미치기 때문이다. 설문지의 작성에 있어서 지켜야 할 기본원칙과 주의해야 할 사항을 정리하면 다음과 같다.&lt; 지켜야 할 기본 원칙 &gt; 간단할 것 - 명료할 것 구체적일 것 - 평이한 용어를 사용할 것 친근한 문장일 것 등 &lt; 주의해야 할 사항 &gt; 신상에 관한 상세한 질문 - 답을 유도하거나 편견이 들어있는 질문 한 항목이 질문내용을 둘 이상 포함하는 경우 - 가정적인 질문 못마땅한 질문 - 너무 시시콜콜한 질문 전문용어의 사용 - 상투적인 용어 수량이나 정도를 표시하는 부사 주의해야 할 사항들 중에서 일부를 구체적으로 살펴보도록 하자.1) 신상에 관한 상세한 질문사람은 누구나 남에게 알리고 싶지 않은 비밀의 부분이 있게 마련이다. 신상에 관한 상세한 질문은 자칫 응답자의 감정을 건드려 정확한 답변을 얻기가 어렵다. 특히 한국사람은 사회적 지위나 학력은 사실보다 높이는 반면 수입은 줄이는 경향이 있음을 유의해야 한다.그러나 일반적으로 설문지에는 인적사항을 조사해야 하는 경우가 많다. 인적사항은 응답자의 성별, 나이, 주거지, 출신지, 교육수준, 직업, 소득수준 등을 말한다. 이러한 인적사항을 조사하는 이유로는 본 조사에서의 항목을 인적사항별로 분할하여 비교하고자 한다거나, 또는 조사된 표본이 모집단을 정말로 대표할 수 있는 지를 검토하고자 할 때 이용된다.인적사항에 관한 설문들은 설문지의 마지막 장에 두는 것이 좋다. 예를 들어 교육수준에 관한 설문은 저학력 응답자들을 기분 나쁘게 할 수 있는데, 만약 본조사 항목에 들어가기 전에 기분이 나빠진다면 응답오류 및 부실기제의 가능성이 높아지기 때문이다.인적사항중 소득수준과 같은 것은 신뢰적인 측정이 어렵다. 따라서 결과분석시에 꼭 필요한 사항이 아니라면 설문에 포함시키지 않는 편이 좋다. 만약 꼭 응답자의 소득을 알아야 하는 경우에는​. ◆ 월소득이 얼마입니까 ? ———만원​. . . 과 같이 직접 기입하도록 하는 것보다는​. ◆ 월소득이 다음의 범주중 어디에 속하십니까 ? ( )①100만원 이하 ②100-150만원 ③150-200만원 ④200-250만원 ⑤250만원 이상 과 같이 선택형으로 하는 것이 좋다.​2) 편견이 들어있는 질문설문 중에는 본의 아니게 편견이 들어가기가 쉽다. 설문내용이 일부응답의 한쪽 면만을 부각시키는 경우를 예를 들면,​. ◆ 일반시민 대다수를 위하여 지하철파업은 법적으로 금지되어야 한다고 생각하십니까?. . . 예( ) 아니오( )​와 같은 설문이다. 이는 지하철노조 파업을 법적으로 금지해야 한다는 응답을 유도하고 있기 때문이다. 그러나 다음과 같은 설문​. ◆ 지하철파업은 법적으로 금지되어야 한다고 생각하십니까?. . . 예( ) 아니오( )​에는 이러한 편견이 없다.​3) 수량이나 정도를 표시하는 부사‘종종’, ‘자주’, ‘가끔’, ‘대부분’, ‘일반적으로’, ‘항상’ 등의 용어는 설문지에서 애매모호한 정보를 준다고 할 수 있다. 예를 들어​. ◆ 당신은 한 달에 극장에 몇 번이나 갑니까?. . . 종종( ) 자주( ) 가끔( ) 거의( )​라고 할 경우 도대체 몇 번인지 알 수가 없다. 이러한 경우에는1-2회( ) 3-4회( ) 5-6회( ) 7-8회( ) 9회 이상( )​등과 같이 구분하여 정확한 숫자를 제시하는 것이 좋다. 이 외에도 설문지 문항이 적절하지 않은 예를 들어보자.​. ◆ 현 대통령이 장관의 인선시 무엇을 가장 중요시하고 있다고 생각합니까?1.행정경험 2.도덕성 3.인화력 4.개인적 신분 5.출신지역​이런 설문은 적절하지 않다. 왜냐하면 각료의 인선에서는 행정경험, 도덕성, 인화력, 개인적 신분, 출신지역 등 모든 것을 고려하여 안배할 것이기 때문이다. 따라서 이러한 항목에서 하나를 고르라고 하는 것은 지나친 단순화를 초래한다. 이와 같은 설문은 다음과 같이 바꿀 수 있다.. ◆ 현 대통령이 장관의 인선시, 다음 항목 각각에 대하여, 어느 정도 중요시하고 있다고 생각합니까?아주중요하게 중요하게 보통 중요하지않게 전혀 중요하지않게 행정경험 ① ② ③ ④ ⑤ 도 덕 성 ① ② ③ ④ ⑤ 인 화 력 ① ② ③ ④ ⑤ 개인적 신분 ① ② ③ ④ ⑤ 출신지역 ① ② ③ ④ ⑤ 6.설문지의 형식설문지의 문항은 크게 나누어서 자유응답식과 택일식으로 구분된다. 자유응답식은 응답자가 생각하는 바를 자유롭게 문장으로 표현하는 방법이고, 택일식은 이미 마련되어 있는 몇 개의 내용 중에서 선택하여 응답하도록 하는 방법이다. 설문지는 많은 경우에 택일식의 형식을 쓰고 있는데, 이는 응답률을 높이고 자료처리를 하는데 편하기 때문이다.그러나 이 경우에 있어서 선택항목들은 연구장의 주관이나 좁은 경험영역에 머무르기 쉬우므로 이를 타당하게 꾸미기 어렵다. 따라서 예비조사를 통하여 예상되는 선택 항목을 구상해야한다. 예를 들어 학생들의 편식에 대한 연구를 하는 경우에는 ‘네가 좋아하는 음식의 이름을 써라’, ‘네가 싫어하는 음식의 이름을 써라’와 같은 자유응답식 질문에 의하여 사전조사를 하고, 여기에 나타난 반응결과를 분석한 뒤 선택식 항목을 작성하는 것이 좋다.조사연구자가 질문의 형식은 조사의 종류와 비용과 시간에 따라 결정되게 된다. 일반적으로 질문의 형식은 폐쇄형과 개방형으로 구분되지만 많은 경우에 폐쇄형과 개방형의 절충방법이 사용되고 있다.설문지의 형식을 종류별로 살펴보도록 하자.(1) 자유응답식자유응답식은 제한 자유응답형과 무제한 자유응답형으로 구분된다. 제한 자유응답형의 예를 들면, ‘현 학제를 찬성하는 이유 중 가장 중요한 것 하나를 써주시오’ 또는 ‘두 가지만 써주시오’ 하는 식으로 제한되는 경우이고, 무제한 자유응답식은 ‘생각나는 대로 항목별로 써주시오’ 하는 방식이다. 이러한 자유응답식은 응답자가 대답하기도 어렵고 자료처리 하기도 어려운 단점을 가지고 있지만 경우에 따라서는 의견을 청취한다거나, 사전조사의 경우에 유용하게 이용될 수 있다. 장점 : 쟁점이 복잡하여 응답의 형태를 몇 개의 범주로 압축할 수 없는 경우에 적합하고, 특히 예비 조사에 유용하다. 단점 : 응답에 대한 부담이 커서 무응답이나 거절의 빈도가 많다. ​​(2) 택일식(택 2 택 3 포함)이는 여러 항목들에서 하나, 또는 둘 경우에 따라서는 셋을 선택하도록 한다. 예를 들어,​사범교육에 대한 개선방안은 어디에 중점을 두어야 한다고 생각하십니까?. ① 교직교육의 강화. ② 전공교과의 강화. ③ 일반 교양교육의 강화. ④ 교육행정 및 운영의 개선. ⑤ 기타( )​이러한 택일식은 항목에 응답자가 반응코자 하는 내용을 모두 포함토록 해야하나, 그렇지 못한 수가 있기 때문에 항목 다음에 기타를 두어 마땅한 항목이 없을 때는 문장으로 자기의 의견이나 사실을 기입하게 할 수도 있다.​ 장점 : 응답자의 부담을 줄일 수 있고, 소득이나 사생활과 같은 대답하기 민감한 문제에 대해 쉽게 응답할 수 있게 한다. 단점 : 응답자의 자발적인 자기 표현 기회를 제약함으로써, 얻을 수 있는 정보의 풍부함을 제한할 수 있다. ​​(3) 체크리스트체크리스트는 무제한으로 해당사항을 체크하게 하는 것을 말한다. 예를 들어​경제생활 영역에서 선생님의 문제는 어떤 것이 있습니까. 절실히 느끼는 것을 모두 체크하여 주십시오.. ① 교직보다 경제적으로 나은 것이 있지만 교직에 머물고 있다.. ② 가족을 부양하는 일 때문에 행동에 지장이 많다.. ③ 학생들 앞에 나서기가 부끄럽도록 의복이 남루하다.​이와 같은 항목이 20개가 있다면 이들 중에서 자기에게 해당되는 것은 모두 체크하도록 한다.​​​(4) 분류식분류식은 택일식의 일종으로 일정한 기준이나 표준에 따라서 설문항목을 분류하는 방법이다. 기준이나 표준으로서는 혐오, 찬부, 흥미, 태도가 된다. 예를 들면 다음과 같다.​◆다음에 여러 가지 형용사가 있다. 그것이 보다한국인을 적절히 표현하고 있는 것이면…………..A일본인을 적절히 표현하고 있는 것이면…………..B중국인을 적절히 표현하고 있는 것이면…………..C라고 ___에 써넣어라.​___재주있는 ___조직적인 ___인내심 있는___비열한 ___교활한 ___낙관적인___침착한 ___민주적인 ___건실한___독창적인 ___책임감 있는 ___매력있는___신뢰할 수 있는​​​(5) 척도식(scale method)이 방법은 조사대상자에게 미리 정해 놓은 척도에 따라 결정하도록 요구하는 방법이다. 척도에는 3, 5, 7, 9 단계 등이 있으나 가장 많이 사용되고 있는 것은 5단계이다. 내용으로는 ‘대단히 찬성한다’, ‘찬성한다’, ‘찬성도 아니고 반대도 아니다’, ‘반대한다’, ‘대단히 반대한다’ 와 같은 것 또는 ‘대단히 좋다’, ‘좋다’, ‘보통이다’, ‘나쁘다’, ‘대단히 나쁘다’ 등 여러 가지가 있을 수 있다. 질문은 다음 예들과 같이 두 가지로 만들 수 있다.​◆ 다음에 있는 질문마다 오른쪽에 있는 다섯가지의 답 중 당신의 기분에 가장 알맞은 것을 골라 ○표 하시오.매우 나쁘다 나쁘다 보통이다 좋다 매우 좋다 형제끼리 싸움을 한다 ——– ——– ——– ——— ——– 부모에게 말대답을 한다 ——– ——– ——– ——— ——– ​◆ 선생님은 현직교육강습을 통하여 배운 바가 교육현장에 가서 어느 정도 활용할 수 있으리라고 생각하십니까.___1. 매우 많이 활용할 것이다.___2. 다소 활용될 것이다.___3. 보통이다.___4. 별로 활용되지 않을 것이다.___5. 전혀 활용되지 않을 것이다.​​​(6) 등위식어떤 질문 내용을 일정한 기준에 따라 순위를 매기는 방법이다. 질문내용의 수가 적으면 1번부터 끝까지 매기게 할 수 있으나 많을 때에는 몇 개로 한정시키고 번호를 매기게 한다. 이러한 예는 다음과 같다.​..◆ 다음 여러나라 중 어느 나라가 가장 살기 좋다고 생각하십니까. 순서대로 번호를 기입하시오... ..( )이탈리아 ( )멕시코 ( )미국 ( )독일.. ..( )스위스 ( )영국 ( )일본 ( )프랑스​..◆ 다음 여러 과목들 중에서 당신이 가장 좋아하는 과목 다섯가지만 골라서 왼편___에 표를 하고 표가 된 것에 한.. .. 하여 좋아하는 순서에 따라 오른편( )에 번호를 기입하시오.​__국어( ) __사회( ) __영어( )__음악( ) __수학( ) __미술( )__생물( ) __체육( ) __물리( )__농업( ) __화학( ) __상업( )__역사( ) __공업( ) __지리( )7.설문지의 구성설문지의 구성은 대략 다음과 같은 세 부분으로 구성이 된다고 할 수 있다. 겉 장(조사에 관하여 배경을 설명하고 응답자의 협조를 바라는 조사주관자의 글) 본조사 항목 응답자의 인적사항 설문지에서 문항의 수와 순서는 적절한 언어의 사용과 함께 가장 중요한 문제라고 할 수 있다. 질문의 수에 관심을 갖게 되는 것은 우선 응답자로 하여금 많은 시간을 소모케 하여 권태를 느낌으로써 올바른 조사가 되지 않을 우려가 있기 때문이다. 이러한 점에서 질문 문항의 수는 30개 정도를 넘지 않는 것이 이상적이라 할 수 있다.그러나 조사의 성격에 따라 30개 정도로는 소기의 목적을 달성할 수 없는 경우도 많다. 심지어는 100개가 넘는 사례도 있을 수 있다. 문항의 수를 결정하는 것은 수 자체보다는 문항의 난이도에 따라 많은 질문이라도 쉬운 내용이면 빨리 끝날 수도 있으므로 소요시간에 따라 그 수를 정하는 것이 현명하다. 따라서 조사를 실시하기 전에 소요시간을 측정해보는 모의조사를 해보는 것이 일반적이며 이것은 보통 사전검사(pre-test)에서 이루어지기도 한다.​이와 같은 과정을 통하여 개별적인 질문문항이 결정된 후에는 이를 응답자에게 제시하는 순서를 결정하여야 한다. 순서를 결정할 때 고려해야 할 사항은 다음과 같다.​-첫 번째 질문은 가능한 한 쉽게 응답할 수 있고 흥미를 유발할 수 있는 것이어야 한다.-응답자와 관련된 인적사항에 대한 질문은 가능한 한 뒤에 하여야 한다.-질문항목들간의 관계를 고려한다.-응답자가 심각하게 고려하여 응답하여야 하는 성질의 질문은 위치선정에 주의하여야 한다.​​​8.설문문항 배열의 원칙다음으로 질문을 어떻게 배열하는냐 하는 것은 좋은 질문을 만드는 것만큼 중요하다. 질문을 배열하는 순서에 따라 자연스러운 면접분위기를 형성할 수도 있고, 반대로 거부감을 일으킬 수도 있다.(1) 질문을 배열할 때는 응답자의 흥미를 유발하거나 쉽게 대답할 수 있는 질문을 질문지의 앞부분에 놓는 것이.. . 좋다.(2) 질문은 주어진 조사 주제에 대한 개방형 질문에서 폐쇄형 질문으로, 전반적인 질문에서 구체적이거나 특수한.. . 질문으로 옮기는 것이 좋다.(3) 나이, 성별, 출신지, 교육수준, 직업, 소득 등 인구사회학적 특성에 대한 질문이나 개인의 사생활에 대한 질문,.. . 또는 민감한 질문은 가급적 질문지의 끝으로 보내는 것이 좋다.(4) 대화와 마찬가지로 질문들을 내용별로 묶어 주어야 하며, 자연스러우면서 논리적인 순서에 따라 이어지게 하.. . 는 것이 좋다.(5) 내용이 같거나 척도가 동일한 질문은 모아서 함께 묻는 것이 좋다.(6) 가능한 한 동일한 질문 및 응답범주는 동일한 면에 있도록 배열한다.​​9.설문지의 사전조사이상에서 열거한 여러 과정을 거쳐서 설문지가 완성되면 그대로 인쇄로 들어갈 것이 아니라 반드시 사전조사(pre-test)를 거쳐야 한다. 설문지에는 자체 결함이 있을 수 있으므로 본조사에 들어가기 전에 사전조사를 통하여 설문지에 내재된 문제점을 미리 발견하여 수정하고자 하는 것이다.​(1) 사전조사(pretest)질문지가 완성되면 본 조사를 실시하기 전에 질문지 내용의 실용성, 조사의 문제점 등을 검토해 보기 위하여 소수의 표본을 대상으로 실시하는 시험적인 조사를 말한다.​(2) 사전조사의 중요성질문지가 완성되면, 최종인쇄에 넘기기 전에 실제로 그 질문지를 사용하여 질문지의 타당성 여부를 시험해 보는 것이 좋다. 사전조사를 통하여 단어의 사용, 질문의 내용, 형식, 순서 등을 확인하고 수정한다. 필요한 경우에는 불필요한 질문을 삭제하거나 필요한 질문을 추가할 수 있다. 사전조사의 결과에 따라 전체 연구의 질이 달라질 수도 있으므로 다소 번거롭더라도 한번 이상 꼭 실시해야 한다.사전조사를 게을리한 연구자중 본조사 후 설문내용에 치명적인 결함이 뒤늦게 발견되어 막대한 비용과 시간을 다시 들여 재조사를 하는 경우가 종종 있다.​(3) 사전조사시 유의사항..- 사전조사는 본 조사의 표본과 비슷하지만 조사대상에 포함되지 않는 사람들에게 실시해야 한다...- 사전조사에 임하는 면접원은 각 면접당 소요되는 시간, 각 문항에서 문제가 되는 부분, 응답자가 당황해 하거나.. . 불쾌감을 나타낸 질문 등을 자세하게 적어 오도록 해야 한다...- 조사결과에 대한 백분비를 계산할 수 있도록, 조사대상자는 대개 20∼50명 정도로 한다...- 사전조사는 가능하면 직접면접을 통하여 실시한다. 그래야만 예상하지 못했던 여러 가지 문제점들을 파악할 수.. . 있게 된다...- 본 조사 방법을 전화나 우편 조사를 실시하는 경우에는, 예비조사도 전화나 우편조사를 통해서 할 수 있다.​사전조사는 설문조사를 실시할 모든 계층을 상대로 무작위로 추출된 응답자에게 실시하는 것이 원칙이며, 가급적 다양한 층의 사람들이 대표되도록 하는 것이 좋다. 또한 이러한 과정과 동시에 연구주제에 대해 전문적인 지식을 갖고 있는 전문가 집단의 의견을 들어보는 것도 좋을 것이다.​이러한 사전조사에서 검토되어야 할 사항은 각 설문문항의 구성과 내용이 응답자들에게 의도된 대로 잘 이해가 되었는지와 설문지의 작성에 총 몇 분 정도가 소요되었는지 등이다. 만약 사전조사를 통하여 문제점이 발견되면 다시 앞의 단계로 돌아가서 문제점들을 수정하는 작업을 반복해야 할 것이다.​설문지는 연구하고자 하는 내용에 따라 형태가 달라진다. 유형에 따른 설문지의 다양하고 많은 예가 류창하안춘옥(1992)의 「사회여론조사 설문모음집」(서울: 지식산업사), 고려대학교 부설 행동과학연구소(1999)의 「심리척도 핸드북」(학지사) 등에 실려있으니 이를 참조하기 바란다.결과참고 사이트 :: 설문지 작성법 :: [출처 세리포럼 권재진님글]" }, { "title": "22-09-23(금)", "url": "/posts/Diary-220923/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-23 00:00:00 +0900", "snippet": "＃프로젝트 키 1.0 줄이기 일시 정지 1절 노래 끝나면 인게임 노래 끄기 스크립트 경량화 / 버튼 이벤트예시 코드/// &lt;summary&gt;/// MusicElements.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (Eternal Light)/// This s...", "content": "＃프로젝트 키 1.0 줄이기 일시 정지 1절 노래 끝나면 인게임 노래 끄기 스크립트 경량화 / 버튼 이벤트예시 코드/// &lt;summary&gt;/// MusicElements.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (Eternal Light)/// This software is released under the GPL-2.0 license/// /// - 동적 프리팹 접근을 위해 자신(버튼)에게 Select()를 OnClick()으로 매핑합니다./// - EventSystem.current.currentSelectedGameObject을 이용하여 방금 클릭한 게임 오브젝트를 지정해줍니다./// - UniBpmAnalyzer.cs의 AnalyzeBpm() 함수로 선택한 오브젝트의 자식 오디오 소스의 BPM을 조사한 수치를 GameManager의 bpm에 선언합니다./// - 똑같은 방법으로 전체 길이, 절반 길이 등 필요한 값들을 받아옵니다./// - 소스 네임과 클립 등을 대칭화 해주고 선택된 곡의 샘플링 오디오를 재생합니다./// &lt;/summary&gt;using UnityEngine;using UnityEngine.UI;using UnityEngine.EventSystems;public class MusicElements : MonoBehaviour{ public void Select() { GameManager.instance.btnEasy.interactable = true; GameManager.instance.btnNormal.interactable = true; GameManager.instance.btnHard.interactable = true; GameManager.instance.btnPlay.interactable = false; // 방금 클릭한 게임 오브젝트를 가져 와 selectedElement에 저장 GameObject selectedElement = EventSystem.current.currentSelectedGameObject; // UniBpmAnalyzer.cs의 AnalyzeBpm() 함수로 선택한 오브젝트의 자식 오디오 소스의 BPM을 조사한 수치를 GameManager의 bpm에 선언 GameManager.instance.bpm = UniBpmAnalyzer.AnalyzeBpm(selectedElement.transform.GetChild(3).gameObject.GetComponent&lt;AudioSource&gt;().clip); // 플레이 타임(100%) GameManager.instance.playTime = selectedElement.transform.GetChild(3).gameObject.GetComponent&lt;AudioSource&gt;().clip.length; GameManager.instance.playTimeOffset = GameManager.instance.playTime - 15f; // 플레이 타임(50%) GameManager.instance.halfPlayTime = GameManager.instance.playTime / 2; GameManager.instance.halfHalfPlayTimeOffset = GameManager.instance.playTime / 2 - 15f; // textTitle.text ← customMusicElements.AudioSource.text GameManager.instance.infoTitle.GetComponent&lt;Text&gt;().text = $\"- {selectedElement.transform.GetChild(3).gameObject.GetComponent&lt;AudioSource&gt;().clip.name}\"; // 프리팹 오디오 소스 클립 -&gt; musicSelected의 클립 GameManager.instance.musicSelected.GetComponent&lt;AudioSource&gt;().clip = selectedElement.transform.GetChild(3).gameObject.GetComponent&lt;AudioSource&gt;().clip; // 플레이에 사용 될 오디오 소스 대칭화 GameManager.instance.musicPlayed.GetComponent&lt;AudioSource&gt;().clip = GameManager.instance.musicSelected.GetComponent&lt;AudioSource&gt;().clip; // BGM Pause GameManager.instance.musicBackGround.Pause(); // MusicSelected Play GameManager.instance.musicSelected.Play(); }}예시 사진1예시 사진2 VR로 했을 때 연속으로 콤보가 올라가는 부분 수정모션 패널의 상호 작용은 원래 PanelCheck라는 게임 오브젝트의 활성화/비활성화에 따라 접촉 시의 트리거를 통해 진행됐었지만, 기존 조건에 맞추려면 손과 손이 항상 일렬로 있어야 했다는 문제가 있었다.그래서 그 스크립트를 삭제하고 패널 체크 함수에서 가장 가까운 패널 인덱스를 삭제하는 것으로 HoverEnter/Exit에 관여하며 단발성을 가진 이벤트로 구현이 가능했다./// PanelManager.cs public UnityEvent _SFX; void PanelCheck() { if (GameManager.instance.isSensorLeft &amp;&amp; GameManager.instance.isSensorRight) { _SFX?.Invoke(); StartCoroutine(ScoreManager.instance.Increase()); Destroy(panelSpawnPoint.transform.GetChild(0).gameObject); } } 리셋 버튼 작동안함단순히 하이어라키 창을 정리하던 중 캔버스가 중복 되었기 때문에 작동이 안됐던 것이다.결과이로써 대부분의 버그/오류를 수정했다.게임을 빌드하면서 더이상 인게임에서 멈출 일은 없을 것 같다." }, { "title": "22-09-22(목)", "url": "/posts/Diary-220922/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-22 00:00:00 +0900", "snippet": "＃프로젝트 옵션 UI 디자인 Mode Menu Scripting※ 할당각각 토글들을 인스펙터에 할당해줌게임매니저 스크립트 Awake()에서 게임 속도(100%), 노래 길이(1절만), 장애물(ON)을 토글 켜주기각 메뉴별로 껏다 켰다 해주기※ 게임 속도패널컨트롤 스크립트에서 패널 속도 float형과 트리거/// GameManager.cs [H...", "content": "＃프로젝트 옵션 UI 디자인 Mode Menu Scripting※ 할당각각 토글들을 인스펙터에 할당해줌게임매니저 스크립트 Awake()에서 게임 속도(100%), 노래 길이(1절만), 장애물(ON)을 토글 켜주기각 메뉴별로 껏다 켰다 해주기※ 게임 속도패널컨트롤 스크립트에서 패널 속도 float형과 트리거/// GameManager.cs [Header(\"[Mode]\")] public float modePanelSpeed; public void Is70() { modePanelSpeed = 0.7f; } public void Is100() { modePanelSpeed = 1f; } public void Is130() { modePanelSpeed = 1.3f; }/// &lt;summary&gt;/// PanelCtrl.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (Eternal Light)/// This software is released under the GPL-2.0 license/// /// &lt;/summary&gt;using System;using System.Collections;using UnityEngine;public class PanelCtrl : MonoBehaviour{ private void FixedUpdate() { Move(); } void Move() { transform.position += transform.forward * (-GameManager.instance.moveSpeed * GameManager.instance.modePanelSpeed) * Time.deltaTime; }}※ 노래 길이offset 변수를 추가해서 곡 길이에서 절반 빼고 시작게임 매니저에서 아래의 변수 추가public float modeHalfPlayTime;public float modeHalfPlayTimeOffset;/// &lt;summary&gt;/// MusicElements.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (Eternal Light)/// This software is released under the GPL-2.0 license/// /// &lt;/summary&gt;public class MusicElements : MonoBehaviour{ public void Select() { [중략...] GameManager.instance.playTime = selectedElement.transform.GetChild(3).gameObject.GetComponent&lt;AudioSource&gt;().clip.length; GameManager.instance.playTimeOffset = GameManager.instance.playTime - 15f; GameManager.instance.modeHalfPlayTime = GameManager.instance.playTime / 2; GameManager.instance.modeHalfPlayTimeOffset = GameManager.instance.playTime / 2 - 15f; [중략...] }}패널 매니저 스크립트에서 버튼 별로 타이머를 다시 측정하고, 종료 이벤트를 내린다./// PanelManager.cs private void FixedUpdate() { if (GameManager.instance.isStart &amp;&amp; !GameManager.instance.isPause) { PanelCheck(); GameManager.instance.offsetTimer += Time.deltaTime; if (!GameManager.instance.btnHalf.interactable) { GameManager.instance.modeHalfPlayTime -= Time.deltaTime; if (GameManager.instance.modeHalfPlayTimeOffset &gt;= GameManager.instance.offsetTimer) PanelInstance(); if (GameManager.instance.modeHalfPlayTime &lt;= 0) GameManager.instance.EndEvent(); } else if (!GameManager.instance.btnAll.interactable) { GameManager.instance.playTime -= Time.deltaTime; if (GameManager.instance.playTimeOffset &gt;= GameManager.instance.offsetTimer) PanelInstance(); if (GameManager.instance.playTime &lt;= 0) GameManager.instance.EndEvent(); } } }초기화는 muisc element의 Select() 버튼 이벤트를 받아서 다시 양쪽 곡 시간을 받아온다.public void EndEvent() { // 패널 생성 된 거 삭제 int numOfChild = PanelManager.instance.panelSpawnPoint.transform.childCount; if (numOfChild != 0) for (int i = 0; i &lt; PanelManager.instance.panelSpawnPoint.transform.childCount; i++) Destroy(PanelManager.instance.panelSpawnPoint.transform.GetChild(i).gameObject); panelTimer = 0; offsetTimer = 0; secPerBeat = 0; PanelManager.instance.panelSpawnCount = -1; PanelManager.instance.panelLastIndex = -1; PanelManager.instance.isQuiz = false; PanelManager.instance.isCurLeft = false; PanelManager.instance.isCurRight = false; musicBackGround.UnPause(); ResultData(); _UIResult.SetActive(true); score = 0; kcal = 0; ScoreManager.instance.SetScore(); ScoreManager.instance.SetKcal(); /// 여기 btnEasy.interactable = false; btnNormal.interactable = false; btnHard.interactable = false; isStart = false; isPause = false; isHandChange = false; ControllerModeChange(); }※ 장애물패널 매니저 스크립트에서 생성 로직에 확률을 변경public void PanelInstance() { GameManager.instance.panelTimer += Time.deltaTime; if (GameManager.instance.panelTimer &gt; GameManager.instance.secPerBeat) { GameManager.instance.panelTimer -= GameManager.instance.secPerBeat; int panelIndex = Random.Range(0, 10); // &lt;--- 전체 패널 확률 int quizCool = Random.Range(5, 25); // &lt;--- 퀴즈 쿨타임 if (!GameManager.instance.btnObOn.interactable) { Debug.Log(\"장애물 ON\"); /* QUIZ 10% */ if (panelIndex == 0) { if (!isQuiz) { Debug.Log(\"퀴즈 패널 패턴이 아니므로 모션 패널 생성\"); GameObject _motion = Instantiate(motion[Random.Range(0, 1)], panelSpawnPoint); _motion.name = \"MOTION\"; panelSpawnCount++; panelLastIndex++; if (panelSpawnCount == quizCool &amp;&amp; !isQuiz) { _motion.transform.GetChild(4).gameObject.SetActive(true); panelSpawnCount -= quizCool + quizCool; } } else if (isQuiz) { Debug.Log(\"퀴즈 패널 생성\"); GameObject _quiz = Instantiate(quiz[0], panelSpawnPoint); _quiz.name = \"QUIZ\"; panelSpawnCount++; panelLastIndex++; isQuiz = false; } } /* BLOCK 10% */ else if (panelIndex == 1) { GameObject _block = Instantiate(block[Random.Range(0, 3)], panelSpawnPoint); _block.name = \"BLOCK\"; float zScale = Random.Range(1.0f, 4.0f); _block.transform.localScale = new Vector3(1, 1, Random.Range(1, zScale)); panelSpawnCount++; panelLastIndex++; } /* MOTION 80% */ else if (panelIndex &gt; 1) { GameObject _motion = Instantiate(motion[Random.Range(0, 1)], panelSpawnPoint); _motion.name = \"MOTION\"; panelSpawnCount++; panelLastIndex++; if (panelSpawnCount &gt;= quizCool &amp;&amp; !isQuiz) { _motion.transform.GetChild(4).gameObject.SetActive(true); panelSpawnCount -= quizCool + quizCool; } } } else if (!GameManager.instance.btnObOff.interactable) { Debug.Log(\"장애물 OFF\"); /* QUIZ 10% */ if (panelIndex == 0) { if (!isQuiz) { Debug.Log(\"퀴즈 패널 패턴이 아니므로 모션 패널 생성\"); GameObject _motion = Instantiate(motion[Random.Range(0, 1)], panelSpawnPoint); _motion.name = \"MOTION\"; panelSpawnCount++; panelLastIndex++; if (panelSpawnCount == quizCool &amp;&amp; !isQuiz) { _motion.transform.GetChild(4).gameObject.SetActive(true); panelSpawnCount -= quizCool + quizCool; } } else if (isQuiz) { Debug.Log(\"퀴즈 패널 생성\"); GameObject _quiz = Instantiate(quiz[0], panelSpawnPoint); _quiz.name = \"QUIZ\"; panelSpawnCount++; panelLastIndex++; isQuiz = false; } } /* MOTION 90% */ else if (panelIndex &gt;= 1) { GameObject _motion = Instantiate(motion[Random.Range(0, 1)], panelSpawnPoint); _motion.name = \"MOTION\"; panelSpawnCount++; panelLastIndex++; if (panelSpawnCount &gt;= quizCool &amp;&amp; !isQuiz) { _motion.transform.GetChild(4).gameObject.SetActive(true); panelSpawnCount -= quizCool + quizCool; } } } } } Option Menu Scripting※ 밝기※ 키 조절※ 밝기, 키 조절 슬라이더 / 버튼 연계 private void Update() { if (!btn70.interactable) modePanelSpeed = 0.7f; else if (!btn100.interactable) modePanelSpeed = 1.0f; else if (!btn130.interactable) modePanelSpeed = 1.3f; bright = sliderBright.value; height = sliderHeight.value; } // 시간 변환 함수 public static string TimeFormatter(float seconds, bool forceHHMMSS = false) { float secondsRemainder = Mathf.Floor((seconds % 60) * 100) / 100.0f; int minutes = ((int)(seconds / 60)) % 60; int hours = (int)(seconds / 3600); if (!forceHHMMSS) { if (hours == 0) { return System.String.Format(\"{0:00}:{1:00.00}\", minutes, secondsRemainder); } } return System.String.Format(\"{0}:{1:00}:{2:00}\", hours, minutes, secondsRemainder); } public void BrightInc() { if (0 &lt;= bright &amp;&amp; bright &lt;= 2.1) { bright += 0.1f; sliderBright.value = bright; } } public void BrightDec() { if (0 &lt;= bright &amp;&amp; bright &lt;= 2.1) { bright -= 0.1f; sliderBright.value = bright; } } public void HeightInc() { if (1.1 &lt;= height &amp;&amp; height &lt;= 1.3) { height += 0.01f; sliderHeight.value = height; } } public void HeightDec() { if (1.1 &lt;= height &amp;&amp; height &lt;= 1.3) { height -= 0.01f; sliderHeight.value = height; } }※ 종료 이벤트 // [Button] Quit public void BtnQuit() {#if UNITY_WEBPLAYER public static string webplayerQuitURL = \"http://google.com/\";#endif {#if UNITY_EDITOR UnityEditor.EditorApplication.isPlaying = false;#elif UNITY_WEBPLAYER Application.OpenURL(webplayerQuitURL);#else Application.Quit();#endif } }결과" }, { "title": "22-09-21(수)", "url": "/posts/Diary-220921/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-21 00:00:00 +0900", "snippet": "＃프로젝트 퀴즈 디자인/// &lt;summary&gt;/// QuizPanelsQ.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (Eternal Light)/// This software is released under the GPL-2.0 license/// /// 'Can...", "content": "＃프로젝트 퀴즈 디자인/// &lt;summary&gt;/// QuizPanelsQ.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (Eternal Light)/// This software is released under the GPL-2.0 license/// /// 'Canvas Quiz' GameObject에 적용되는 스크립트입니다./// Easy / Normal : 왼쪽-색 / 오른쪽-글귀/// Hard : 각각 좌/우 랜덤 위치에서 색과 글귀가 출제/// &lt;/summary&gt;using UnityEngine;using UnityEngine.UI;public class QuizPanelQ : MonoBehaviour{ public Text leftLetter; public Text rightLetter; private void OnEnable() { if (GameManager.instance.isStart &amp;&amp; GameManager.instance.musicPlayed.isPlaying &amp;&amp; (!GameManager.instance.btnEasy.interactable || !GameManager.instance.btnNormal.interactable)) { GameObject leftColorBall = Instantiate(PanelManager.instance.ballList[Random.Range(0, 7)], gameObject.transform.GetChild(0)); PanelManager.instance.curColor = leftColorBall.name; rightLetter.text = PanelManager.instance._LetterList[Random.Range(0, 49)]; PanelManager.instance.curLetter = rightLetter.text; PanelManager.instance.isQuiz = true; } else if (GameManager.instance.isStart &amp;&amp; GameManager.instance.musicPlayed.isPlaying &amp;&amp; !GameManager.instance.btnHard.interactable) { // Hard 전용 랜덤 변수 (0 == Color is Left | 1 == Color is Right) int randomDir = Random.Range(0, 2); switch (randomDir) { case 0: GameObject leftColorBall = Instantiate(PanelManager.instance.ballList[Random.Range(0, 7)], gameObject.transform.GetChild(0)); PanelManager.instance.curColor = leftColorBall.name; rightLetter.text = PanelManager.instance._LetterList[Random.Range(0, 49)]; PanelManager.instance.curLetter = rightLetter.text; PanelManager.instance.isQuiz = true; break; case 1: GameObject rightColorBall = Instantiate(PanelManager.instance.ballList[Random.Range(0, 7)], gameObject.transform.GetChild(1)); PanelManager.instance.curColor = rightColorBall.name; leftLetter.text = PanelManager.instance._LetterList[Random.Range(0, 49)]; PanelManager.instance.curLetter = leftLetter.text; PanelManager.instance.isQuiz = true; break; } } }}/// &lt;summary&gt;/// QuizPanelA.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (Eternal Light)/// This software is released under the GPL-2.0 license/// /// 컬러는 둘 다 같아도 됨/// &lt;/summary&gt;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class QuizPanelA : MonoBehaviour{ public Text leftLetter; public Text rightLetter; public GameObject btnLeft; public GameObject btnRight; static Color color; static string r = \"#FF0000\"; static string o = \"#FF6400\"; static string y = \"#FFFF00\"; static string g = \"#00FF00\"; static string s = \"#0096FF\"; static string b = \"#0014FF\"; static string p = \"#9600FF\"; private void OnEnable() { // (0 == Currect Letter is Left | 1 == Currect Letter is Right) int randomDir = Random.Range(0, 2); switch (randomDir) { case 0: // Currect Letter is Left PanelManager.instance.isCurLeft = true; Debug.Log(\"isCurLeft : \" + PanelManager.instance.isCurLeft); leftLetter.text = PanelManager.instance.curLetter; switch (PanelManager.instance.curColor) { case \"Red(Clone)\": if (ColorUtility.TryParseHtmlString(r, out color)) leftLetter.color = color; break; case \"Orange(Clone)\": if (ColorUtility.TryParseHtmlString(o, out color)) leftLetter.color = color; break; case \"Yellow(Clone)\": if (ColorUtility.TryParseHtmlString(y, out color)) leftLetter.color = color; break; case \"Green(Clone)\": if (ColorUtility.TryParseHtmlString(g, out color)) leftLetter.color = color; break; case \"Sky Blue(Clone)\": if (ColorUtility.TryParseHtmlString(s, out color)) leftLetter.color = color; break; case \"Blue(Clone)\": if (ColorUtility.TryParseHtmlString(b, out color)) leftLetter.color = color; break; case \"Purple(Clone)\": if (ColorUtility.TryParseHtmlString(p, out color)) leftLetter.color = color; break; } rightLetter.text = PanelManager.instance._LetterList[Random.Range(0, 49)]; int rightColorindex = Random.Range(0, 7); switch (rightColorindex) { case 0: if (ColorUtility.TryParseHtmlString(r, out color)) rightLetter.color = color; break; case 1: if (ColorUtility.TryParseHtmlString(o, out color)) rightLetter.color = color; break; case 2: if (ColorUtility.TryParseHtmlString(y, out color)) rightLetter.color = color; break; case 3: if (ColorUtility.TryParseHtmlString(g, out color)) rightLetter.color = color; break; case 4: if (ColorUtility.TryParseHtmlString(s, out color)) rightLetter.color = color; break; case 5: if (ColorUtility.TryParseHtmlString(b, out color)) rightLetter.color = color; break; case 6: if (ColorUtility.TryParseHtmlString(p, out color)) rightLetter.color = color; break; } if (leftLetter.text == rightLetter.text) rightLetter.text = PanelManager.instance._LetterList[Random.Range(0, 49)]; break; case 1: // Currect Letter is Right PanelManager.instance.isCurRight = true; Debug.Log(\"isCurRight : \" + PanelManager.instance.isCurRight); leftLetter.text = PanelManager.instance._LetterList[Random.Range(0, 49)]; int leftColorindex = Random.Range(0, 7); switch (leftColorindex) { case 0: if (ColorUtility.TryParseHtmlString(r, out color)) leftLetter.color = color; break; case 1: if (ColorUtility.TryParseHtmlString(o, out color)) leftLetter.color = color; break; case 2: if (ColorUtility.TryParseHtmlString(y, out color)) leftLetter.color = color; break; case 3: if (ColorUtility.TryParseHtmlString(g, out color)) leftLetter.color = color; break; case 4: if (ColorUtility.TryParseHtmlString(s, out color)) leftLetter.color = color; break; case 5: if (ColorUtility.TryParseHtmlString(b, out color)) leftLetter.color = color; break; case 6: if (ColorUtility.TryParseHtmlString(p, out color)) leftLetter.color = color; break; } rightLetter.text = PanelManager.instance.curLetter; switch (PanelManager.instance.curColor) { case \"Red(Clone)\": if (ColorUtility.TryParseHtmlString(r, out color)) rightLetter.color = color; break; case \"Orange(Clone)\": if (ColorUtility.TryParseHtmlString(o, out color)) rightLetter.color = color; break; case \"Yellow(Clone)\": if (ColorUtility.TryParseHtmlString(y, out color)) rightLetter.color = color; break; case \"Green(Clone)\": if (ColorUtility.TryParseHtmlString(g, out color)) rightLetter.color = color; break; case \"Sky Blue(Clone)\": if (ColorUtility.TryParseHtmlString(s, out color)) rightLetter.color = color; break; case \"Blue(Clone)\": if (ColorUtility.TryParseHtmlString(b, out color)) rightLetter.color = color; break; case \"Purple(Clone)\": if (ColorUtility.TryParseHtmlString(p, out color)) rightLetter.color = color; break; } if (leftLetter.text == rightLetter.text) leftLetter.text = PanelManager.instance._LetterList[Random.Range(0, 49)]; break; } }} 콤보 디자인/// ComboManager.cspublic class ComboManager : MonoBehaviour{ [SerializeField] string comboWord; [SerializeField] GameObject comboObj; [SerializeField] AnimationCurve scaleCurve; [SerializeField, Range(0.2f, 0.5f)] float initEffectDuration = 0.2f; //初期演出時間(초기 연출 시간) [SerializeField, Range(0.01f, 0.1f)] float durationIncrement = 0.03f; //増加時間(증가 시간) [SerializeField, Range(0.4f, 0.7f)] float maxEffectDuration = 0.4f; //最大演出時間(최대 연출 시간) [SerializeField, Range(1.2f, 1.5f)] float initMaxScale = 1.4f; //初期最大スケール(초기 후 큰 스케일) [SerializeField, Range(0.2f, 1f)] float scaleIncrement = 0.6f; //スケール増加量(스케일 증가량) [SerializeField, Range(5, 10)] float maxScale = 5f; //最大スケール(최대 스케일) [SerializeField, Range(0, 0.2f)] float basicScaleIncrement = 0.09f; //演出後の文字の大きさの増加量(연출 후 크기의 증가량) Text comboText; RectTransform comboRectTrans; public int combo = 0; public float timer = 0f; float scale; float basicScale; float effectDuration; bool playingEffect = false; Coroutine effectCol; public Queue&lt;int&gt; comboOrder = new Queue&lt;int&gt;(); public static ComboManager instance; void Awake() { if (instance == null) instance = this; else Destroy(gameObject); comboText = comboObj.GetComponent&lt;Text&gt;(); comboRectTrans = comboObj.GetComponent&lt;RectTransform&gt;(); } private void FixedUpdate() { if (comboOrder.Count == 0) return; timer += Time.deltaTime; var tempRate = Mathf.Clamp((1f - combo / 10f), 0.3f, 0.5f); //コンボ数が大きいほど短時間で次の表示(콤보 수가 클 수록 단기간에 다음을 표시) if (timer &gt; effectDuration * tempRate) { timer = 0; UpdateCombo(comboOrder.Dequeue()); } } public void IncreaseCombo() { combo++; comboOrder.Enqueue(combo); if (combo == 1) //初回のみ UpdateCombo(comboOrder.Dequeue()); } public void Clear() { combo = 0; comboText.text = \"\"; comboOrder.Clear(); } // 콤보 갱신 함수 // int comboCount 콤보 수 void UpdateCombo(int comboCount) { comboText.text = comboCount + comboWord; comboRectTrans.localRotation = Quaternion.Euler(0, 0, Random.Range(-15f, 15f)); //前のコンボ演出が終了してない場合(전 콤보 연출이 종료하지 않았을 경우) if (playingEffect) { StopCoroutine(effectCol); if (effectDuration &lt; maxEffectDuration) effectDuration += durationIncrement; if (scale &lt; maxScale) scale += scaleIncrement; //7コンボまでは初期スケールを大きくする(7콤보까지는 초기 스케일을 크게 한다.) if (combo &lt; 7) basicScale += basicScaleIncrement; } else { scale = initMaxScale; basicScale = 1; effectDuration = initEffectDuration; } effectCol = StartCoroutine(PlayEffect(effectDuration)); } /// &lt;summary&gt; /// 演出.テキストの大きさを大→小にする.(연출. 텍스트의 크기를 작게 한다.) /// &lt;/summary&gt; /// &lt;param name=\"duration\"&gt;期間(sec)&lt;/param&gt; IEnumerator PlayEffect(float duration) { var timer = 0f; var rate = 0f; var startScale = new Vector3(scale, scale, 1); var endScale = new Vector3(basicScale, basicScale, 1); playingEffect = true; while (rate &lt; 1) { timer += Time.deltaTime; rate = Mathf.Clamp01(timer / duration); var curvePos = scaleCurve.Evaluate(rate); comboRectTrans.localScale = Vector3.Lerp(startScale, endScale, curvePos); yield return null; } yield return new WaitForSeconds(0.5f); playingEffect = false; }} 패널 디자인/// &lt;summary&gt;/// PanelManager.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (Eternal Light)/// This software is released under the GPL-2.0 license/// /// &lt;/summary&gt;using System.Collections.Generic;using System.Linq;using UnityEngine;using UnityEngine.UI;using UnityEngineInternal;using Random = UnityEngine.Random;public class PanelManager : MonoBehaviour{ [Header(\"[패널 상호작용 요소]\")] public Transform panelSpawnPoint; // 패널 생성 좌표 public GameObject panelCheck; [Header(\"[패널 프리팹]\")] public GameObject[] quiz; // 패널 프리팹 배열 public GameObject[] block; // 패널 프리팹 배열 public GameObject[] motion; // 패널 프리팹 배열 public List&lt;GameObject&gt; ballList = new List&lt;GameObject&gt;(); static string[] _LetterArray = { \"집중\", \"평화\", \"용서\", \"감사\", \"침착\", \"정의\", \"조화\", \"자유\", \"정직\", \"지혜\", \"친절\", \"이해\", \"활력\", \"영감\", \"공감\", \"겸손\", \"힘\", \"지성\", \"고요\", \"결단\", \"사랑\", \"관용\", \"자비\", \"부드러움\", \"축복\", \"생명\", \"믿음\", \"젊음\", \"자신감\", \"덕성\", \"행복\", \"영혼\", \"민첩성\", \"건강\", \"충만\", \"일관성\", \"끈기\", \"목적\", \"성취\", \"풍요\", \"성공\", \"숙달\", \"능력\", \"에너지\", \"소명\", \"침묵\", \"직관\", \"재생\", \"소생\" }; public List&lt;string&gt; _LetterList = new List&lt;string&gt;(); public int panelSpawnCount; public int panelLastIndex; public bool isQuiz; public bool isCurLeft; public bool isCurRight; public int quizCool; public string curColor; public string curLetter; public static PanelManager instance; private void Awake() { if (instance == null) instance = this; else Destroy(gameObject); panelSpawnCount = -1; panelLastIndex = -1; _LetterList.AddRange(_LetterArray); } private void FixedUpdate() { if (GameManager.instance.isStart &amp;&amp; GameManager.instance.musicPlayed.isPlaying) { PanelCheck(); GameManager.instance.offsetTimer += Time.deltaTime; if (GameManager.instance.playTimeOffset &gt;= GameManager.instance.offsetTimer) { PanelInstance(); } } } public void PanelInstance() { GameManager.instance.timer += Time.deltaTime; if (GameManager.instance.timer &gt; GameManager.instance.secPerBeat) { GameManager.instance.timer -= GameManager.instance.secPerBeat; int panelIndex = Random.Range(0, 10); // &lt;--- 전체 패널 확률 int quizCool = Random.Range(5, 25); // &lt;--- 퀴즈 쿨타임 /* QUIZ 10% */ if (panelIndex == 0) { if (!isQuiz) { Debug.Log(\"퀴즈 패널 패턴이 아니므로 모션 패널 생성\"); GameObject _motion = Instantiate(motion[Random.Range(0, 1)], panelSpawnPoint); _motion.name = \"MOTION\"; panelSpawnCount++; panelLastIndex++; if (panelSpawnCount == quizCool &amp;&amp; !isQuiz) { _motion.transform.GetChild(4).gameObject.SetActive(true); panelSpawnCount -= quizCool + quizCool; } } else if (isQuiz) { Debug.Log(\"퀴즈 패널 생성\"); GameObject _quiz = Instantiate(quiz[0], panelSpawnPoint); _quiz.name = \"QUIZ\"; panelSpawnCount++; panelLastIndex++; isQuiz = false; } } /* BLOCK 10% */ else if (panelIndex == 1) { GameObject _block = Instantiate(block[Random.Range(0, 3)], panelSpawnPoint); _block.name = \"BLOCK\"; float zScale = Random.Range(1.0f, 4.0f); _block.transform.localScale = new Vector3(1, 1, Random.Range(1, zScale)); panelSpawnCount++; panelLastIndex++; } /* MOTION 80% */ else if (panelIndex &gt; 1) { GameObject _motion = Instantiate(motion[Random.Range(0, 1)], panelSpawnPoint); _motion.name = \"MOTION\"; panelSpawnCount++; panelLastIndex++; if (panelSpawnCount &gt;= quizCool &amp;&amp; !isQuiz) { _motion.transform.GetChild(4).gameObject.SetActive(true); panelSpawnCount -= quizCool + quizCool; } } } } void PanelCheck() { if (GameManager.instance.isSensorLeft &amp;&amp; GameManager.instance.isSensorRight) { panelCheck.SetActive(true); if (panelCheck.activeSelf) StartCoroutine(ScoreManager.instance.Increase()); } else if (!GameManager.instance.isSensorLeft || !GameManager.instance.isSensorRight) { panelCheck.SetActive(false); } }}/// &lt;summary&gt;/// PanelSensor.cs/// Copyright (c) 2022 VR-Based Cognitive Rehabilitation Program (Eternal Light)/// This software is released under the GPL-2.0 license/// /// &lt;/summary&gt;using System.Collections;using System.Collections.Generic;using UnityEngine;public class PanelSensor : MonoBehaviour{ private void OnTriggerEnter(Collider c) { if (PanelManager.instance.isCurLeft) { if (c.gameObject.tag == \"QUIZ LEFT\") { PanelManager.instance.isCurLeft = false; ComboManager.instance.IncreaseCombo(); PanelManager.instance.panelLastIndex--; Destroy(c.gameObject.transform.parent.gameObject); } else if (c.gameObject.tag == \"QUIZ RIGHT\") { if (GameManager.instance.score &gt; 0) { GameManager.instance.score -= 10000; ScoreManager.instance.SetScore(); } PanelManager.instance.isCurLeft = false; ComboManager.instance.Clear(); } } if (PanelManager.instance.isCurRight) { if (c.gameObject.tag == \"QUIZ LEFT\") { if (GameManager.instance.score &gt; 0) { GameManager.instance.score -= 10000; ScoreManager.instance.SetScore(); } PanelManager.instance.isCurRight = false; ComboManager.instance.Clear(); } else if (c.gameObject.tag == \"QUIZ RIGHT\") { PanelManager.instance.isCurRight = false; ComboManager.instance.IncreaseCombo(); PanelManager.instance.panelLastIndex--; Destroy(c.gameObject.transform.parent.gameObject); } } } private void OnTriggerStay(Collider c) { if (c.gameObject.tag == \"BLOCK\") { if (GameManager.instance.score &gt; 0) { GameManager.instance.score -= 100; ScoreManager.instance.SetScore(); } ComboManager.instance.Clear(); } }}" }, { "title": "22-09-20(화)", "url": "/posts/Diary-220920/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-20 00:00:00 +0900", "snippet": "＃프로젝트 콤보 시스템 콜라이더 체크 스크립트 분리 콤보 초기화 지점 : 엔드라인 체크 스크립트에서 콤보 초기화 퀴즈 디자인 게임 오브젝트 생성 및 배치 스크립트 스크립트 연결 퀴즈 회의 새로운 퀴즈 질문 패널 생성 모델링 : 중앙 비워진 곳 : 문제 / 양 옆 채워...", "content": "＃프로젝트 콤보 시스템 콜라이더 체크 스크립트 분리 콤보 초기화 지점 : 엔드라인 체크 스크립트에서 콤보 초기화 퀴즈 디자인 게임 오브젝트 생성 및 배치 스크립트 스크립트 연결 퀴즈 회의 새로운 퀴즈 질문 패널 생성 모델링 : 중앙 비워진 곳 : 문제 / 양 옆 채워진 곳 : 선택) 퀴즈 패널 색 : 기존 패널과 대비되는 색 Quiz Manager에서 빛 프리팹 배열(7), 텍스트 배열(49) 생성 빛이 제공되면 단어 선택 / 단어가 제공되면 빛 선택오늘로 생성은 성공했다./// PanelManager.cs public int panelSpawnCount; public int panelLastIndex; public bool isQuiz; public void PanelInstance() { GameManager.instance.timer += Time.deltaTime; if (GameManager.instance.timer &gt; GameManager.instance.secPerBeat) { GameManager.instance.timer -= GameManager.instance.secPerBeat; int panelIndex = Random.Range(0, 10); // &lt;--- 전체 패널 확률 int quizCool = Random.Range(5, 20); // &lt;--- 퀴즈 쿨타임 /* QUIZ 10% */ if (panelIndex == 0) { if (!isQuiz) { Debug.Log(\"퀴즈 패널 패턴이 아니므로 모션 패널 생성\"); GameObject _motion = Instantiate(motion[Random.Range(0, 1)], panelSpawnPoint); _motion.name = \"MOTION\"; panelSpawnCount++; panelLastIndex++; if (panelSpawnCount == quizCool) { _motion.transform.GetChild(4).gameObject.SetActive(true); panelSpawnCount -= quizCool; } } else if (isQuiz) { Debug.Log(\"퀴즈 패널 생성\"); GameObject _quiz = Instantiate(quiz[0], panelSpawnPoint); _quiz.name = \"QUIZ\"; panelSpawnCount++; panelLastIndex++; isQuiz = false; } } /* BLOCK 10% */ else if (panelIndex == 1) { GameObject _block = Instantiate(block[Random.Range(0, 3)], panelSpawnPoint); _block.name = \"BLOCK\"; panelSpawnCount++; panelLastIndex++; } /* MOTION 80% */ else if (panelIndex &gt; 1) { GameObject _motion = Instantiate(motion[Random.Range(0, 1)], panelSpawnPoint); _motion.name = \"MOTION\"; panelSpawnCount++; panelLastIndex++; if (panelSpawnCount == quizCool) { _motion.transform.GetChild(4).gameObject.SetActive(true); panelSpawnCount -= quizCool; } } } }/// QuizPanelQ.cspublic class QuizPanelQ : MonoBehaviour{ // Color Balls(size : 7) public GameObject[] leftcolorBallArray; public GameObject[] rightcolorBallArray; // Letters(size : 49) public string[] leftLetterArray = { \"집중\", \"평화\", \"용서\", \"감사\", \"침착\", \"정의\", \"조화\", \"자유\", \"정직\", \"지혜\", \"친절\", \"이해\", \"활력\", \"영감\", \"공감\", \"겸손\", \"힘\", \"지성\", \"고요\", \"결단\", \"사랑\", \"관용\", \"자비\", \"부드러움\", \"축복\", \"생명\", \"믿음\", \"젊음\", \"자신감\", \"덕성\", \"행복\", \"영혼\", \"민첩성\", \"건강\", \"충만\", \"일관성\", \"끈기\", \"목적\", \"성취\", \"풍요\", \"성공\", \"숙달\", \"능력\", \"에너치\", \"소명\", \"침묵\", \"직관\", \"재생\", \"소생\" }; public string[] rightLetterArray = { \"집중\", \"평화\", \"용서\", \"감사\", \"침착\", \"정의\", \"조화\", \"자유\", \"정직\", \"지혜\", \"친절\", \"이해\", \"활력\", \"영감\", \"공감\", \"겸손\", \"힘\", \"지성\", \"고요\", \"결단\", \"사랑\", \"관용\", \"자비\", \"부드러움\", \"축복\", \"생명\", \"믿음\", \"젊음\", \"자신감\", \"덕성\", \"행복\", \"영혼\", \"민첩성\", \"건강\", \"충만\", \"일관성\", \"끈기\", \"목적\", \"성취\", \"풍요\", \"성공\", \"숙달\", \"능력\", \"에너치\", \"소명\", \"침묵\", \"직관\", \"재생\", \"소생\" }; public Text leftLetter; public Text rightLetter; private void OnEnable() { if (GameManager.instance.isStart &amp;&amp; GameManager.instance.musicPlayed.isPlaying &amp;&amp; (!GameManager.instance.btnEasy.interactable || !GameManager.instance.btnNormal.interactable)) { leftcolorBallArray[Random.Range(0, 7)].SetActive(true); rightLetter.text = leftLetterArray[Random.Range(0, 49)]; PanelManager.instance.isQuiz = true; } else if (GameManager.instance.isStart &amp;&amp; GameManager.instance.musicPlayed.isPlaying &amp;&amp; !GameManager.instance.btnHard.interactable) { // Hard 전용 랜덤 변수 (0 == Color is Left | 1 == Color is Right) int randomDir = Random.Range(0, 2); switch (randomDir) { case 0: leftcolorBallArray[Random.Range(0, 7)].SetActive(true); rightLetter.text = leftLetterArray[Random.Range(0, 49)]; PanelManager.instance.isQuiz = true; break; case 1: rightcolorBallArray[Random.Range(0, 7)].SetActive(true); leftLetter.text = leftLetterArray[Random.Range(0, 49)]; PanelManager.instance.isQuiz = true; break; } } }}" }, { "title": "22-09-19(월)", "url": "/posts/Diary-220919/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-19 00:00:00 +0900", "snippet": "＃프로젝트 노트 싱크 해결Update()가 아닌 FixedUpdate()으로 교체/// PanelCtrl.cs public class PanelCtrl : MonoBehaviour { float moveSpeed = 2.0f; private void FixedUpdate() { Mo...", "content": "＃프로젝트 노트 싱크 해결Update()가 아닌 FixedUpdate()으로 교체/// PanelCtrl.cs public class PanelCtrl : MonoBehaviour { float moveSpeed = 2.0f; private void FixedUpdate() { Move(); } void Move() { transform.position += transform.forward * -moveSpeed * Time.deltaTime; } } /// PanelManager.cs private void FixedUpdate() { if (GameManager.instance.isStart &amp;&amp; GameManager.instance.musicPlayed.isPlaying) { GameManager.instance.offsetTimer += Time.deltaTime; if (GameManager.instance.playTimeOffset &gt;= GameManager.instance.offsetTimer) { PanelInstance(); PanelCheck(); } } } 1 센싱 Score, Kcal 1회 적용코루틴으로 생성 후 패널 체크가 액티브 중일 때 코루틴 스타트/// ScoreManager.cs public IEnumerator Increase() { yield return null; GameManager.instance.score += 1000; SetScore(); [중략...] yield break; }/// PanelManager.cs void PanelCheck() { if (GameManager.instance.isSensorLeft &amp;&amp; GameManager.instance.isSensorRight) { panelCheck.SetActive(true); if (panelCheck.activeSelf) StartCoroutine(ScoreManager.instance.Increase()); } else if (!GameManager.instance.isSensorLeft || !GameManager.instance.isSensorRight) { panelCheck.SetActive(false); } } 곡 리스트 갱신할 때 복사되는 버그 수정 void OriginalListRenewal() { /// 여기가 추가됨 foreach (Transform item in contentOriginal.transform) Destroy(item.gameObject); // Custom Music 폴더의 AudioClip 속성 파일 조회 object[] originalMusics = Resources.LoadAll&lt;AudioClip&gt;(\"Original Music\"); [중략...] } void CustomListRenewal() { /// 여기가 추가됨 foreach (Transform item in contentCustom.transform) Destroy(item.gameObject); // Custom Music 폴더의 AudioClip 속성 파일 조회 object[] customMusics = Resources.LoadAll&lt;AudioClip&gt;(\"Custom Music\"); [중략...] } 버튼별 중복 클릭 방지, 데이터 전송 관련 플래그 변수 -&gt; Button Interactable 트리거 /// GameManager.cs // [Button] Easy public void BtnLvEasy() { secPerBeat = 360f / bpm; btnEasy.interactable = false; btnNormal.interactable = true; btnHard.interactable = true; btnPlay.interactable = true; // 노래 재생(Play) 버튼 활성화 } // [Button] Normal public void BtnLvNormal() { secPerBeat = 300f / bpm; btnEasy.interactable = true; btnNormal.interactable = false; btnHard.interactable = true; btnPlay.interactable = true; // 노래 재생(Play) 버튼 활성화 } // [Button] Hard public void BtnLvHard() { secPerBeat = 240f / bpm; btnEasy.interactable = true; btnNormal.interactable = true; btnHard.interactable = false; btnPlay.interactable = true; // 노래 재생(Play) 버튼 활성화 } public void ResultData() { _TextTitle.text = PlayerPrefs.GetString(\"Title\", $\"{musicPlayed.clip.name}\"); if (!btnEasy.interactable) _TextLevel.text = PlayerPrefs.GetString(\"Level\", \"Easy\"); else if (!btnNormal.interactable) _TextLevel.text = PlayerPrefs.GetString(\"Level\", \"Normal\"); else if (!btnHard.interactable) _TextLevel.text = PlayerPrefs.GetString(\"Level\", \"Hard\"); _TextScore.text = PlayerPrefs.GetString(\"Score\", $\"{_IngameTextScore.text}\"); _TextKcal.text = PlayerPrefs.GetString(\"Kcal\", $\"{_IngameTextKacl.text}\"); } 노란색 블럭 점수 트리거 시 점수 깎기 /// PanelSensor.cs private void OnTriggerStay(Collider c) { if (c.gameObject.tag == \"BLOCK\") { if (GameManager.instance.score &gt; 0) { GameManager.instance.score -= 10; ScoreManager.instance.SetScore(); } } } 로비 화면 결과 리스트에 출력 /// GameManager.cs void ReusltListRenewal() { GameObject resultElementPrefab = Instantiate(resultElement, contentResult.transform.position, contentResult.transform.rotation); resultElementPrefab.transform.parent = contentResult.transform; resultElementPrefab.transform.localScale = Vector3.one; } /// ResultElements.cs public class ResultElements : MonoBehaviour { private void Start() { /*타이틀*/ gameObject.transform.GetChild(0).gameObject.GetComponent&lt;Text&gt;().text = GameManager.instance._TextTitle.text; /*난이도*/ gameObject.transform.GetChild(1).gameObject.GetComponent&lt;Text&gt;().text = GameManager.instance._TextLevel.text; /*스코어*/ gameObject.transform.GetChild(2).gameObject.GetComponent&lt;Text&gt;().text = GameManager.instance._TextScore.text; /*칼로리*/ gameObject.transform.GetChild(3).gameObject.GetComponent&lt;Text&gt;().text = GameManager.instance._TextKcal.text; } } 리스트 초기화 버튼/// GameManager.cs void AddReusltList() { GameObject resultElementPrefab = Instantiate(resultElement, contentResult.transform.position, contentResult.transform.rotation); resultElementPrefab.transform.parent = contentResult.transform; resultElementPrefab.transform.localScale = Vector3.one; btnReset.interactable = true; } // [Button] 결과 리스트 초기화 public void ResultListReset() { foreach (Transform item in contentResult.transform) Destroy(item.gameObject); btnReset.interactable = false; } 콤보 시스템 콜라이더 체크 스크립트 분리 콤보 초기화 지점 : 엔드라인 체크 스크립트에서 콤보 초기화 퀴즈 디자인 게임 오브젝트 생성 및 배치 스크립트 스크립트 연결 퀴즈 회의 새로운 퀴즈 질문 패널 생성 모델링 : 중앙 비워진 곳 : 문제 / 양 옆 채워진 곳 : 선택) 퀴즈 패널 색 : 기존 패널과 대비되는 색 Quiz Manager에서 빛 프리팹 배열(7), 텍스트 배열(49) 생성 빛이 제공되면 단어 선택 / 단어가 제공되면 빛 선택" }, { "title": "22-09-18(일)", "url": "/posts/Diary-220918/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-18 00:00:00 +0900", "snippet": "＃C# 공부 Basic Example 11~20 Nullable(널러블) Indexer(인덱서)", "content": "＃C# 공부 Basic Example 11~20 Nullable(널러블) Indexer(인덱서)" }, { "title": "C# Basic Example#20 Finding the biggest of three numbers in C#", "url": "/posts/Example-20/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-18 00:00:00 +0900", "snippet": "Example 20: Finding the biggest of three numbers in C# internal class Example20 { static void Main(string[] args) { int number1, number2, number3; string r...", "content": "Example 20: Finding the biggest of three numbers in C# internal class Example20 { static void Main(string[] args) { int number1, number2, number3; string result; Console.Write(\"Input the first number :\"); number1 = Convert.ToInt32(Console.ReadLine()); Console.Write(\"Input the second number :\"); number2 = Convert.ToInt32(Console.ReadLine()); Console.Write(\"Input the third number :\"); number3 = Convert.ToInt32(Console.ReadLine()); if (number1 &gt; number2 &amp;&amp; number1 &gt; number3) result = \"The 1st Number is the greatest among three. \\n\"; else if (number2 &gt; number1 &amp;&amp; number2 &gt; number3) result = \"The 2nd Number is the greatest among three \\n\"; else result = \"The 3rd Number is the greatest among three \\n\"; Console.WriteLine(result); Console.ReadLine(); } }실습 및 해석num1부터 순서대로 입력 받고 if절부터 순서대로 크기 비교하며 어디 자릿 수가 가장 큰 지 체크하고 그 if절을 출력한다.Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#19 Program to Print all Prime Numbers in an Interval", "url": "/posts/Example-19/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-18 00:00:00 +0900", "snippet": "Example 19: C# Program to Print all Prime Numbers in an Interval internal class Example19 { static void Main(string[] args) { int num1, num2, sayac = 0; Co...", "content": "Example 19: C# Program to Print all Prime Numbers in an Interval internal class Example19 { static void Main(string[] args) { int num1, num2, sayac = 0; Console.Write(\"Enter lower range: \"); num1 = Convert.ToInt32(Console.ReadLine()); Console.Write(\"Enter upper range: \"); num2 = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(\"Prime numbers between {0} and {1} are: \", num1, num2); Console.WriteLine(\"==============================================\"); for (int i = num1; i &lt; num2; i++) { sayac = 0; if (i &gt; 1) { for (int j = 2; j &lt; i; j++) { if (i % j == 0) { sayac = 1; break; } } if (sayac == 0) { Console.WriteLine(i); } } } Console.ReadKey(); } }실습 및 해석num1과 num2로 최솟값과 최댓값을 정해준다.이후에 num1과 num2의 사잇값중 나머지가 0인 숫자를 분별할 때 마다 sayac 변수를 1로 만들어 주고 탈출시킨다.이후에 sayac가 0인 사잇값을 출력한다.Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#18 Find Numbers Above and Below the Average in C#", "url": "/posts/Example-18/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-18 00:00:00 +0900", "snippet": "Example 18: Find Numbers Above and Below the Average in C# internal class Example18 { static void Main(string[] args) { int counter = 0; int[] numbers = ne...", "content": "Example 18: Find Numbers Above and Below the Average in C# internal class Example18 { static void Main(string[] args) { int counter = 0; int[] numbers = new int[10]; int sum = 0, avg = 0, low = 0, high = 0; for (int i = 0; i &lt; 10; i++) { Console.Write(\"Number {0}: \", (i + 1)); numbers[i] = Convert.ToInt32(Console.ReadLine()); sum += numbers[i]; } //avg = sum / numbers.Length; avg = sum / 10; for (int i = 0; i &lt; 10; i++) { if (numbers[i] &lt; avg) low++; else high++; } Console.WriteLine(\"The average is : {0}\", avg); Console.WriteLine(\"The numbers above the average are: {0}\", high); Console.WriteLine(\"The numbers below the average are: {0}\", low); Console.ReadKey(); } }실습 및 해석numbers[] 배열에 10번 원하는 숫자 입력하는데, 그 수들이 매번 sum에 더해서 저장된다.그 합계를 초기에 정한 numbers[] 배열의 크기인 10을 나눈다. 그 값을 avg에 저장한다.다음 for문에서 number[] 배열의 멤버들을 하나씩 평균과 비교하여 분리한다.Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#17 Find Number is Even or Odd using if else Statement in C#", "url": "/posts/Example-17/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-18 00:00:00 +0900", "snippet": "Example 17: Find Number is Even or Odd using if else Statement in C# internal class Example17_1 { static void Main(string[] args) { int n; Console.Write(\"E...", "content": "Example 17: Find Number is Even or Odd using if else Statement in C# internal class Example17_1 { static void Main(string[] args) { int n; Console.Write(\"Enter an integer : \"); n = Int32.Parse(Console.ReadLine()); if (n % 2 == 0) { Console.WriteLine(\"{0} is even\", n); } else { Console.WriteLine(\"{0} is odd\", n); } Console.ReadKey(); } } internal class Example17_2 { static bool IsEvenNumber(int num) { if (num % 2 == 0) { return true; } else { return false; } } static void Main(string[] args) { int n; Console.Write(\"Enter an integer : \"); n = Int32.Parse(Console.ReadLine()); if (IsEvenNumber(n)) { Console.WriteLine(\"{0} is even\", n); } else { Console.WriteLine(\"{0} is odd\", n); } Console.ReadKey(); } }실습 및 해석코드 2에서 bool을 리턴하는 메소드를 통해 짝수와 홀수에 따라 출력한다.Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#16 Fibonacci Series in C# with Method", "url": "/posts/Example-16/", "categories": "C#, 06.Example", "tags": "C#, Fibonacci", "date": "2022-09-18 00:00:00 +0900", "snippet": "Example 16: Fibonacci Series in C# with Method internal class Example16 { static long[] numbers; static long Fib(int n) { if (0 == numbers[n]) { ...", "content": "Example 16: Fibonacci Series in C# with Method internal class Example16 { static long[] numbers; static long Fib(int n) { if (0 == numbers[n]) { numbers[n] = Fib(n - 1) + Fib(n - 2); } return numbers[n]; } static void Main() { Console.Write(\"n = \"); int n = int.Parse(Console.ReadLine()); numbers = new long[n + 2]; numbers[1] = 1; numbers[2] = 1; long result = Fib(n); Console.WriteLine(\"fib({0}) = {1}\", n, result); Console.ReadKey(); } }실습 및 해석if (n == 0) return 0;if (n == 1) return 1;if (n &gt; 1) F(n) = F(n - 1) + F(n - 2);피보나치 수의 정의대로 코드를 표현하면 매우 간단하지만, 이 처럼 재귀 알고리즘을 이용하게 될 경우 시간 복잡도는 O(2＾n)이 된다.따라서 100에서의 피보나치 수를 구하려면 2＾100에 해당하는 시간 복잡도를 가지게 된다. 그러므로 재귀 알고리즘으로 피보나치 수를 구하는 것은 너무 비효율적이다.효율적인 알고리즘은 ‘반복문’이다.먼저, 피보나치 수열의 규칙은 어떤 수를 구하든 0과 1이 아니라면 F(n) = F(n - 1) + F(n - 2)이다.따라서 F(n)을 구하려면 F(n - 1)과 F(n - 2)를 알고 있어야 하고 또 F(n - 1)과 F(n - 2)는 각각 F(n - 3)과 F(n - 4)를 알고 있어야 한다.그러므로 하나의 피보나치 수를 구하려면 그 전의 피보나치 수들을 모두 알고 있어야 한다는 것이 규칙이다.따라서 어떤 피보나치 수를 구하든 간에, 0과 1이 아닌 가장 n이 작은 피보나치 수인 F(2)부터 시작해서 F(n)에 도달할 때 까지 피보나치 수를 구하는 것이 바람직하다. 즉, 위에서 아래로 내려가는 방식보다 아래에서 위로 올라가는 방식을 취해야 하는 것이다.(재귀 알고리즘은 위에서부터 아래로 내려간다.)따라서F(n) = CF(n - 1) = AF(n - 2) = B라고 할 때,C = A + BB = AA = C 이런 순서로 코드를 짜면 피보나치 수를 구할 수 있다.이렇게 하면 시간 복잡도 또한 O(F(n)) = O(n)으로 매우 빠르다.아래의 코드가 피보나치 수열 반복문 함수이다.public static long Fibonacci(int n){ long C = 0; long A = 1; long B = 0; if (n == 1 || n == 0) return n; else { for (int i = 0; i &lt; n - 1; i++) { C = A + B; B = A; A = C; } } return C;}Result후기없음참고 사이트 csharp-console-examples wikipedia MultiBus" }, { "title": "C# Basic Example#15 Convert Dollars to Cents in C#", "url": "/posts/Example-15/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-18 00:00:00 +0900", "snippet": "Example 15: Convert Dollars to Cents in C# //Solution 1: Calculate in Main Method internal class Example15_1 { static void Main(string[] args) { double dollar_amo...", "content": "Example 15: Convert Dollars to Cents in C# //Solution 1: Calculate in Main Method internal class Example15_1 { static void Main(string[] args) { double dollar_amount; int cents; // int compute_cents; Console.Write(\"Enter dollar amount :\"); dollar_amount = Convert.ToDouble(Console.ReadLine()); cents = (int)(dollar_amount * 100); Console.WriteLine(\"{0} $ = {1} ¢\", dollar_amount, cents); Console.ReadLine(); } } //Solution 2: Calculate with Custom Method internal class Example15_2 { static void Main(string[] args) { double dollar_amount; int cents; // int compute_cents; Console.Write(\"Enter dollar amount :\"); dollar_amount = Convert.ToDouble(Console.ReadLine()); cents = compute_cents(dollar_amount); Console.WriteLine(\"{0} $ = {1} ¢\", dollar_amount, cents); Console.ReadLine(); } static int compute_cents(double dollar_amount) { return (int)(dollar_amount * 100); } }실습 및 해석솔루션 1은 달러를 입력해주면 100센트로 해줄 뿐이다. 어려운 건 없다.솔루션 2는 솔루션 1에서 cents 변수에 값을 저장하는 코드를 정적 함수의 리턴으로 만들었다.매개 변수로는 double을 받고 int로 형변환 후 계산한다. 이후 리턴하면 결과는 아래와 같다.Result솔루션 1솔루션 2후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#14 Program to Count Number of Words in a String", "url": "/posts/Example-14/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-18 00:00:00 +0900", "snippet": "Example 14: C# Program to Count Number of Words in a String internal class Example14 { static void Main(string[] args) { string sentence; Console.Write(\"En...", "content": "Example 14: C# Program to Count Number of Words in a String internal class Example14 { static void Main(string[] args) { string sentence; Console.Write(\"Enter String : \"); sentence = Console.ReadLine(); string[] words = sentence.Split(' '); Console.WriteLine(\"Count of words :\" + words.Length); Console.ReadKey(); } }실습 및 해석sentence.Split(‘ ‘)를 하여 띄어쓰기로 하나의 문자열을 분리했다. 그 값을 words라는 string[] 문자열 배열 형식에 저장하고 words.Length로 전체 출력했다.추가 설명Result후기없음참고 사이트 csharp-console-examples microsoft dotnet api" }, { "title": "C# Basic Example#13 Math.Pow Negative Exponent Example", "url": "/posts/Example-13/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-18 00:00:00 +0900", "snippet": "Example 13: C# Math.Pow Negative Exponent Example internal class Example13 { static void Main(string[] args) { double baseNumber, powerNumber; Console.Writ...", "content": "Example 13: C# Math.Pow Negative Exponent Example internal class Example13 { static void Main(string[] args) { double baseNumber, powerNumber; Console.Write(\"Enter base number :\"); baseNumber = Convert.ToDouble(Console.ReadLine()); //2 Console.Write(\"Enter exponent number :\"); powerNumber = Convert.ToDouble(Console.ReadLine()); //-2 double returnNumber = Math.Pow(baseNumber, powerNumber); Console.WriteLine(\"{0}^{1} = {2}\", baseNumber, powerNumber, returnNumber); Console.ReadLine(); } }실습 및 해석12번 문제 응용이다. 거듭제곱될 수가 -도 가능하다.결과대로라면 2 / 2 / 2가된 셈Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#12 Math.Pow Example", "url": "/posts/Example-12/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-18 00:00:00 +0900", "snippet": "Example 12: C# Math.Pow Example internal class Example12 { static void Main(string[] args) { double baseNumber, powerNumber; Console.Write(\"Enter base numb...", "content": "Example 12: C# Math.Pow Example internal class Example12 { static void Main(string[] args) { double baseNumber, powerNumber; Console.Write(\"Enter base number :\"); baseNumber = Convert.ToDouble(Console.ReadLine()); Console.Write(\"Enter exponent number :\"); powerNumber = Convert.ToDouble(Console.ReadLine()); double returnNumber = Math.Pow(baseNumber, powerNumber); Console.WriteLine(\"{0}^{1} = {2}\", baseNumber, powerNumber, returnNumber); Console.ReadLine(); } }실습 및 해석baseNumber = 제곱될 수powerNumber = 거듭제곱 수 Math.Pow(baseNumber, powerNumber)각 매개변수의 위치에 넣는다.Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#11 Program to finds the average of 3 numbers in C#", "url": "/posts/Example-11/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-18 00:00:00 +0900", "snippet": "Example 11: Program to finds the average of 3 numbers in C# internal class Example11 { static void Main(string[] args) { int number1, number2, number3, avarage; ...", "content": "Example 11: Program to finds the average of 3 numbers in C# internal class Example11 { static void Main(string[] args) { int number1, number2, number3, avarage; Console.Write(\"Enter 1st number :\"); number1 = Convert.ToInt32(Console.ReadLine()); Console.Write(\"Enter 2nd number :\"); number2 = Convert.ToInt32(Console.ReadLine()); Console.Write(\"Enter 3rd number :\"); number3 = Convert.ToInt32(Console.ReadLine()); avarage = (number1 + number2 + number3) / 3; Console.Write(\"Avarage of three numbers is {0}\", avarage); Console.ReadKey(); } }실습 및 해석3개의 int형 지역 변수를 입력해주고 각각을 더한 뒤 3을 나눈 값을 avarage 변수에 저장, 출력Result후기없음참고 사이트 csharp-console-examples" }, { "title": "22-09-17(토)", "url": "/posts/Diary-220917/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-17 00:00:00 +0900", "snippet": "＃9일부터 오늘까지의 프로젝트 진행패널 로직 BPM 획득 레벨별로 생성 빈도 조절 노래 싱크 맞추어 노트 판정 내리기 오브젝트 풀링퀴즈 로직 퀴즈 패널 생성 로직 퀴즈 배열UI(스코어 + 칼로리) 스코어 구현 칼로리 구현SFX(인게임 + 결과) 패널 맞출 때 소리 결과창 구현필수 구현할 목록 오리지널 / 커스텀 이동 시 곡이 복사되...", "content": "＃9일부터 오늘까지의 프로젝트 진행패널 로직 BPM 획득 레벨별로 생성 빈도 조절 노래 싱크 맞추어 노트 판정 내리기 오브젝트 풀링퀴즈 로직 퀴즈 패널 생성 로직 퀴즈 배열UI(스코어 + 칼로리) 스코어 구현 칼로리 구현SFX(인게임 + 결과) 패널 맞출 때 소리 결과창 구현필수 구현할 목록 오리지널 / 커스텀 이동 시 곡이 복사되는 버그 playerprefs 곡명, 난이도, 스코어, 칼로리 결과 화면 출력 Result Element 동적 프리팹에 저장 콤보 구현 클라우드 서버 음원 관리선택 구현 튜토리얼 키 높이 조절＃C# 공부 Nullable(널러블) Indexer(인덱서)" }, { "title": "C# Basic Example#10 Area and Perimeter of Circle in C# Console Application", "url": "/posts/Example-10/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-17 00:00:00 +0900", "snippet": "Example 10: Area and Perimeter of Circle in C# Console Application internal class Example10 { static void Main(string[] args) { double r, perimeter, area; ...", "content": "Example 10: Area and Perimeter of Circle in C# Console Application internal class Example10 { static void Main(string[] args) { double r, perimeter, area; Console.Write(\"Please write the radius of your circle : \"); r = Convert.ToDouble(Console.ReadLine()); perimeter = 2 * 3.14 * r; area = 3.14 * Math.Pow(r, 2); //area = 3.14 * r * r; Console.WriteLine(\"=============================================\"); Console.WriteLine(\"The perimeter of yor circle : {0}\", perimeter); Console.WriteLine(\"The area of yor circle : {0}\", area); Console.ReadKey(); } }실습 및 해석입력값으로 받은 문자열을 더블로 컨버트하여 r에 저장하고 나머지 계산, 추가 설명 참고추가 설명double.parse는 변환할 값이 null이면 null메세지가 나와서 에러가 생기는데 Convert.ToDouble을 사용하게 되면 null일때 0으로 처리해 준다 Math.Pow(반복할 값, 횟수)Result후기없음참고 사이트 csharp-console-examples 주니봉:티스토리" }, { "title": "C# Basic Example#09 Square Area and Perimeter Calculator", "url": "/posts/Example-09/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-17 00:00:00 +0900", "snippet": "Example 9: C# Square Area and Perimeter Calculator internal class Example09 { static void Main(string[] args) { int squareheight, area, perimeter; Console....", "content": "Example 9: C# Square Area and Perimeter Calculator internal class Example09 { static void Main(string[] args) { int squareheight, area, perimeter; Console.Write(\"What is the height of your square? :\"); squareheight = Convert.ToInt32(Console.ReadLine()); area = squareheight * squareheight; perimeter = 4 * squareheight; Console.WriteLine(\"Area : {0}\\nPerimeter : {1}\", area, perimeter); // \"\\n\" --&gt; new line Console.ReadKey(); } }실습 및 해석내용은 단순하고, 건질 건 “\\n” 이거 정도일 듯 하다. 이걸 사용하면 한 문자열 안에서 띄어쓰기가 된다.Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#08 Calculate Rectangle Area", "url": "/posts/Example-08/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-17 00:00:00 +0900", "snippet": "Example 8: C# Calculate Rectangle Area internal class Example08 { static void Main(string[] args) { int area, length, width; Console.Write(\"Please write th...", "content": "Example 8: C# Calculate Rectangle Area internal class Example08 { static void Main(string[] args) { int area, length, width; Console.Write(\"Please write the length of your rectangle: \"); length = Convert.ToInt32(Console.ReadLine()); Console.Write(\"Please write the width of your rectangle: \"); width = Convert.ToInt32(Console.ReadLine()); area = length * width; Console.WriteLine(\"The area of rectangle : {0}\", area); Console.ReadKey(); } }실습 및 해석해석대로 int형 length, width를 곱해준 값을 int형 area로 받아준다는 내용Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#07 Program To Calculate the Simple Interest in C#", "url": "/posts/Example-07/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-17 00:00:00 +0900", "snippet": "Example 7: Program To Calculate the Simple Interest in C# internal class Example07 { static void Main(string[] args) { int P, T; float R, SI; Co...", "content": "Example 7: Program To Calculate the Simple Interest in C# internal class Example07 { static void Main(string[] args) { int P, T; float R, SI; Console.Write(\"Enter Amount :\"); P = Convert.ToInt32(Console.ReadLine()); Console.Write(\"Enter Rate :\"); R = Convert.ToSingle(Console.ReadLine()); Console.Write(\"Enter Time :\"); T = Convert.ToInt32(Console.ReadLine()); SI = P * R * T / 100; Console.WriteLine(\"Interest is :{0}\", SI); Console.ReadKey(); Console.ReadLine(); } }실습 및 해석쉽게 선언된 형식의 계산으로 SI(float) = P(int) * R(float) * T(int) / 100을 출력한 결과이다.Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#06 Program to Compute Quotient and Remainder", "url": "/posts/Example-06/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-17 00:00:00 +0900", "snippet": "Example 6: C# Program to Compute Quotient and Remainder internal class Example06 { static void Main(string[] args) { int dividend = 50, divisor = 8; int qu...", "content": "Example 6: C# Program to Compute Quotient and Remainder internal class Example06 { static void Main(string[] args) { int dividend = 50, divisor = 8; int quotient = dividend / divisor; int remainder = dividend % divisor; Console.WriteLine(\"Dividend:{0} Divisor:{1}\", dividend, divisor); Console.WriteLine(\"Quotient = \" + quotient); Console.WriteLine(\"Remainder = \" + remainder); Console.ReadLine(); } }실습 및 해석’/’는 나눗셈의 결과, 몫은 제외’%’ 나눈 후 몫을 출력함Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#05 Multiply Two Floating Point Numbers in C# Console", "url": "/posts/Example-05/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-17 00:00:00 +0900", "snippet": "Example 5: Multiply Two Floating Point Numbers in C# Console internal class Example05 { static void Main(string[] args) { float number1, number2, product; ...", "content": "Example 5: Multiply Two Floating Point Numbers in C# Console internal class Example05 { static void Main(string[] args) { float number1, number2, product; number1 = 12.45f; number2 = 10.74f; product = number1 * number2; Console.WriteLine(\"{0} * {1} = {2}\", number1, number2, product); Console.ReadLine(); } }실습 및 해석ReadLine()해주지 않고, 값을 저장한 float형 변수들을 곱셈한 결과를 출력하는 문제Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#04 Program to Multiply two Floating Point Numbers Entered by User", "url": "/posts/Example-04/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-17 00:00:00 +0900", "snippet": "Example 4: C# Program to Multiply two Floating Point Numbers Entered by User internal class Example04 { static void Main(string[] args) { float number1, number2, prod...", "content": "Example 4: C# Program to Multiply two Floating Point Numbers Entered by User internal class Example04 { static void Main(string[] args) { float number1, number2, product; Console.Write(\"Enter a number1:\"); number1 = Convert.ToSingle(Console.ReadLine()); Console.Write(\"Enter a number2:\"); number2 = Convert.ToSingle(Console.ReadLine()); product = number1 * number2; Console.WriteLine(\"{0} * {1} = {2}\", number1, number2, product); Console.ReadLine(); } }실습 및 해석3번 예제와 마찬가지로 float형 변수를 선언 후 형변환 하여 입력하고 곱셈을 한 것을 출력Convert.ToSingle() : 지정된 값을 단정밀도 부동 소수점 숫자로 변환합니다.Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#03 Program to Add Two Integers", "url": "/posts/Example-03/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-17 00:00:00 +0900", "snippet": "Example 3: C# Program to Add Two Integers internal class Example03 { static void Main(string[] args) { int num1, num2, sum; Console.WriteLine(\"Calculate th...", "content": "Example 3: C# Program to Add Two Integers internal class Example03 { static void Main(string[] args) { int num1, num2, sum; Console.WriteLine(\"Calculate the sum of two numbers:\"); Console.Write(\"Input number1:\"); num1 = Convert.ToInt32(Console.ReadLine()); Console.Write(\"Input number2:\"); num2 = Convert.ToInt32(Console.ReadLine()); sum = num1 + num2; Console.Write(\"Result:\" + sum); Console.ReadKey(); } }실습 및 해석지역 변수 num1, num2, sum을 선언num1부터 string to int하여 값 입력num2까지 입력하면 num1 + num2한 값이 sum 변수에 저장저장된 값 출력이후 아무 키나 입력하면 종료Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#02 Program to Print an Integer Entered by User", "url": "/posts/Example-02/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-17 00:00:00 +0900", "snippet": "Example 2: C# Program to Print an Integer Entered by User internal class Example02 { static void Main(string[] args) { int number; Console.Write(\"Enter a n...", "content": "Example 2: C# Program to Print an Integer Entered by User internal class Example02 { static void Main(string[] args) { int number; Console.Write(\"Enter a number : \"); number = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(\"You entered : {0}\", number); Console.ReadLine(); } }실습 및 해석콘솔에 입력 할 숫자를 넣기 위해 number라는 int형 지역 변수를 만들고, string to int해서 입력값을 준다.{?} 안으로 입력한 number가 출력된다.이후 아무 버튼이나 누르면 종료Result후기없음참고 사이트 csharp-console-examples" }, { "title": "C# Basic Example#01 Program to Print Hello World", "url": "/posts/Example-01/", "categories": "C#, 06.Example", "tags": "C#", "date": "2022-09-17 00:00:00 +0900", "snippet": "Example 1: C# Program to Print Hello World internal class Example01 { static void Main(string[] args) { Console.WriteLine(\"Hello World!\"); Console.ReadKey(...", "content": "Example 1: C# Program to Print Hello World internal class Example01 { static void Main(string[] args) { Console.WriteLine(\"Hello World!\"); Console.ReadKey(); } }실습 및 해석어려운 게 없으니 콘솔 클래스 내장 함수 중 Console.ReadKey()에 대한 정의만 봤다.Char로 가져오는 듯 하다.Result후기새 마음 새 출발의 다짐으로 시작꼼꼼하게 C#을 마스터하자참고 사이트 csharp-console-examples microsoft dotnet api" }, { "title": "OnEnable 함수를 이용한 점수 시스템 구현", "url": "/posts/Unity-OnEnable/", "categories": "Unity", "tags": "Unity", "date": "2022-09-15 00:00:00 +0900", "snippet": "OnEnable()의 특징 private void OnEnable() { // 게임 오브젝트 또는 스크립트가 Enable될 때마다 호출 // 주로 사용자 정의 이벤트 연결에 사용 // Coroutine으로 실행 불가능 }현재 프로젝트에선 양 쪽 컨트롤러의 트리거 유무에 따라 패널을 활성화/비활성화 ...", "content": "OnEnable()의 특징 private void OnEnable() { // 게임 오브젝트 또는 스크립트가 Enable될 때마다 호출 // 주로 사용자 정의 이벤트 연결에 사용 // Coroutine으로 실행 불가능 }현재 프로젝트에선 양 쪽 컨트롤러의 트리거 유무에 따라 패널을 활성화/비활성화 하는 스크립트를 사용하고 있다. 다만 이 함수는 Update()에서 돌고 있기 때문에 스코어나 콤보 시스템을 동일한 if문에 적용하기엔 무리가 있다. void Check() { if (GameManager.instance.isSensorLeft &amp;&amp; GameManager.instance.isSensorRight) { panelCheck.SetActive(true); } else if (GameManager.instance.isSensorLeft == false || GameManager.instance.isSensorRight == false) panelCheck.SetActive(false); }이 스크립트는 활성화/비활성화 되는 오브젝트에 내장되어 있음.public class PanelDestroy : MonoBehaviour{ private void OnTriggerEnter(Collider c) { if (c.gameObject.tag == \"TRIGGER PANEL\") { Destroy(c.gameObject); } }}그리고 그 오브젝트에 아래의 스크립트도 추가해준다.using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class ScoreSystem : MonoBehaviour{ public static ScoreSystem instance; public GameObject scoreObj; Text textScore; int score = 0; private void Awake() { instance = this; textScore = scoreObj.GetComponent&lt;Text&gt;(); } private void OnEnable() { IncreaseScore(); } private void Start() { if (GameManager.instance.isStart) { SetText(); } } public void IncreaseScore() { score += 1000; SetText(); } public void SetText() { textScore.text = score.ToString(); }}결과Kcal 구현내 프로젝트에선 스코어와 같이 소모된 칼로리도 제공해주어야 하므로 비슷한 로직으로 만들어준다.public class ScoreSystem : MonoBehaviour{ public static ScoreSystem instance; public GameObject scoreObj; Text textScore; int score = 0; public GameObject kcalObj; Text textKcal; float kcal = 0; private void Awake() { instance = this; textScore = scoreObj.GetComponent&lt;Text&gt;(); textKcal = kcalObj.GetComponent&lt;Text&gt;(); } private void OnEnable() { IncreaseScore(); IncreaseKcal(); } private void Start() { if (GameManager.instance.isStart) { SetScore(); SetKcal(); } } public void IncreaseScore() { score += 1000; SetScore(); } public void SetScore() { textScore.text = score.ToString(); } public void IncreaseKcal() { kcal += 0.4f; SetKcal(); } public void SetKcal() { textKcal.text = kcal.ToString(); }}하지만 이렇게 실수형인 float 형을 선언하면 아래 사진과 같이 소수점 자리가 길게 나타난다.소수점 자리 수를 지정하여 해결한다.ToString(\"F\")ToString(\"F0\") // 소수점을 표기하고싶지 않으면ToString(\"F1\") // 소수점 첫째자리까지 표기하고싶으면ToString(\"F2\") // 소수점 둘쨰자리까지 표기하고싶으면전체 코드using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class ScoreSystem : MonoBehaviour{ public static ScoreSystem instance; public GameObject scoreObj; Text textScore; int score = 0; public GameObject kcalObj; Text textKcal; float kcal = 0; private void Awake() { instance = this; textScore = scoreObj.GetComponent&lt;Text&gt;(); textKcal = kcalObj.GetComponent&lt;Text&gt;(); } private void OnEnable() { IncreaseScore(); IncreaseKcal(); } private void Start() { if (GameManager.instance.isStart) { SetScore(); SetKcal(); } } public void IncreaseScore() { score += 1000; SetScore(); } public void SetScore() { textScore.text = score.ToString(); } public void IncreaseKcal() { kcal += 0.4f; SetKcal(); } public void SetKcal() { textKcal.text = kcal.ToString(\"F1\"); }}결과참고 사이트 C# 소수점 자리수 정리" }, { "title": "Sync Objects With Music", "url": "/posts/Unity-CodingtotheBeat/", "categories": "Unity", "tags": "Unity", "date": "2022-09-14 00:00:00 +0900", "snippet": "리듬 게임을 만드는 데 필요한 일부 프로그래밍에 대한 빠른 가이드입니다.Unity를 사용하여 게임을 빌드하지만 대부분의 엔진에 적용될 수 있습니다.오디오 클립으로부터 BPM 추출하기내용은 간단한 일본어였지만, 아무튼 공부를 해둔 것이 도움이 됐다. 다음부턴 자주 일본어로 검색해봐야겠다. ㅎㅎ UniBpmAnalyzer/*UniBpmAnalyzerCo...", "content": "리듬 게임을 만드는 데 필요한 일부 프로그래밍에 대한 빠른 가이드입니다.Unity를 사용하여 게임을 빌드하지만 대부분의 엔진에 적용될 수 있습니다.오디오 클립으로부터 BPM 추출하기내용은 간단한 일본어였지만, 아무튼 공부를 해둔 것이 도움이 됐다. 다음부턴 자주 일본어로 검색해봐야겠다. ㅎㅎ UniBpmAnalyzer/*UniBpmAnalyzerCopyright (c) 2016 WestHillApps (Hironari Nishioka)This software is released under the MIT License.http://opensource.org/licenses/mit-license.php*/using System;using System.Collections.Generic;using System.Linq;using System.Text;using UnityEngine;public class UniBpmAnalyzer{ #region CONST // BPM search range private const int MIN_BPM = 60; private const int MAX_BPM = 400; // Base frequency (44.1kbps) private const int BASE_FREQUENCY = 44100; // Base channels (2ch) private const int BASE_CHANNELS = 2; // Base split size of sample data (case of 44.1kbps &amp; 2ch) private const int BASE_SPLIT_SAMPLE_SIZE = 2205; #endregion public struct BpmMatchData { public int bpm; public float match; } private static BpmMatchData[] bpmMatchDatas = new BpmMatchData[MAX_BPM - MIN_BPM + 1]; /// &lt;summary&gt; /// Analyze BPM from an audio clip /// &lt;/summary&gt; /// &lt;param name=\"clip\"&gt;target audio clip&lt;/param&gt; /// &lt;returns&gt;bpm&lt;/returns&gt; public static int AnalyzeBpm(AudioClip clip) { for (int i = 0; i &lt; bpmMatchDatas.Length; i++) { bpmMatchDatas[i].match = 0f; } if (clip == null) { return -1; } Debug.Log(\"AnalyzeBpm audioClipName : \" + clip.name); int frequency = clip.frequency; Debug.Log(\"Frequency : \" + frequency); int channels = clip.channels; Debug.Log(\"Channels : \" + channels); int splitFrameSize = Mathf.FloorToInt(((float)frequency / (float)BASE_FREQUENCY) * ((float)channels / (float)BASE_CHANNELS) * (float)BASE_SPLIT_SAMPLE_SIZE); // Get all sample data from audioclip var allSamples = new float[clip.samples * channels]; clip.GetData(allSamples, 0); // Create volume array from all sample data var volumeArr = CreateVolumeArray(allSamples, frequency, channels, splitFrameSize); // Search bpm from volume array int bpm = SearchBpm(volumeArr, frequency, splitFrameSize); Debug.Log(\"Matched BPM : \" + bpm); var strBuilder = new StringBuilder(\"BPM Match Data List\\n\"); for (int i = 0; i &lt; bpmMatchDatas.Length; i++) { strBuilder.Append(\"bpm : \" + bpmMatchDatas[i].bpm + \", match : \" + Mathf.FloorToInt(bpmMatchDatas[i].match * 10000f) + \"\\n\"); } Debug.Log(strBuilder.ToString()); return bpm; } /// &lt;summary&gt; /// Create volume array from all sample data /// &lt;/summary&gt; private static float[] CreateVolumeArray(float[] allSamples, int frequency, int channels, int splitFrameSize) { // Initialize volume array var volumeArr = new float[Mathf.CeilToInt((float)allSamples.Length / (float)splitFrameSize)]; int powerIndex = 0; // Sample data analysis start for (int sampleIndex = 0; sampleIndex &lt; allSamples.Length; sampleIndex += splitFrameSize) { float sum = 0f; for (int frameIndex = sampleIndex; frameIndex &lt; sampleIndex + splitFrameSize; frameIndex++) { if (allSamples.Length &lt;= frameIndex) { break; } // Use the absolute value, because left and right value is -1 to 1 float absValue = Mathf.Abs(allSamples[frameIndex]); if (absValue &gt; 1f) { continue; } // Calculate the amplitude square sum sum += (absValue * absValue); } // Set volume value volumeArr[powerIndex] = Mathf.Sqrt(sum / splitFrameSize); powerIndex++; } // Representing a volume value from 0 to 1 float maxVolume = volumeArr.Max(); for (int i = 0; i &lt; volumeArr.Length; i++) { volumeArr[i] = volumeArr[i] / maxVolume; } return volumeArr; } /// &lt;summary&gt; /// Search bpm from volume array /// &lt;/summary&gt; private static int SearchBpm(float[] volumeArr, int frequency, int splitFrameSize) { // Create volume diff list var diffList = new List&lt;float&gt;(); for (int i = 1; i &lt; volumeArr.Length; i++) { diffList.Add(Mathf.Max(volumeArr[i] - volumeArr[i - 1], 0f)); } // Calculate the degree of coincidence in each BPM int index = 0; float splitFrequency = (float)frequency / (float)splitFrameSize; for (int bpm = MIN_BPM; bpm &lt;= MAX_BPM; bpm++) { float sinMatch = 0f; float cosMatch = 0f; float bps = (float)bpm / 60f; if (diffList.Count &gt; 0) { for (int i = 0; i &lt; diffList.Count; i++) { sinMatch += (diffList[i] * Mathf.Cos(i * 2f * Mathf.PI * bps / splitFrequency)); cosMatch += (diffList[i] * Mathf.Sin(i * 2f * Mathf.PI * bps / splitFrequency)); } sinMatch *= (1f / (float)diffList.Count); cosMatch *= (1f / (float)diffList.Count); } float match = Mathf.Sqrt((sinMatch * sinMatch) + (cosMatch * cosMatch)); bpmMatchDatas[index].bpm = bpm; bpmMatchDatas[index].match = match; index++; } // Returns a high degree of coincidence BPM int matchIndex = Array.FindIndex(bpmMatchDatas, x =&gt; x.match == bpmMatchDatas.Max(y =&gt; y.match)); return bpmMatchDatas[matchIndex].bpm; }}사용법은 UniBpmAnalyzer 클래스의 AnalyzeBpm 함수의 인자로 추출할 오디오 소스 클립을 넣게 되면, BPM을 추출할 수 있다.매우 간단하다.using UnityEngine;public class Example : MonoBehaviour{ public AudioClip clip; private void Start() { int bpm = UniBpmAnalyzer.AnalyzeBpm( clip ); }}이제 추출한 bpm에서 계산된 비트의 초당 지속 시간을 제공하는 secPerBeat 전역 변수를 선언해줍니다.//The number of seconds for each song beatfloat secPerBeat = 60 / bpm;참고 사이트 Here’s a quick and dirty guide I just wrote: How To Make A Rhythm Game Coding to the Beat - Under the Hood of a Rhythm Game in Unity Music Syncing in Rhythm Games docs.unity3d.com / AudioSettings.dspTime AudioClip から BPM を取得できる「UniBpmAnalyzer」紹介" }, { "title": "22-09-08(목)", "url": "/posts/Diary-220908/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-08 00:00:00 +0900", "snippet": "＃프로젝트 동시 박살 인터랙션 툴킷 인터렉테이블 Hover Entered, Exited를 통해 센싱 플래그 변수 적용 최상위 패널 프리팹 오브젝트 태그 지정 패널 매니저에서 불리언 체크로 제거 ＃C# 공부 Switch enum(열거형) foreach(배열 반복문) Generic(일반화) 과 Non-G...", "content": "＃프로젝트 동시 박살 인터랙션 툴킷 인터렉테이블 Hover Entered, Exited를 통해 센싱 플래그 변수 적용 최상위 패널 프리팹 오브젝트 태그 지정 패널 매니저에서 불리언 체크로 제거 ＃C# 공부 Switch enum(열거형) foreach(배열 반복문) Generic(일반화) 과 Non-Generic where(특수화)" }, { "title": "C# Grammar#0x | where(특수화)", "url": "/posts/Grammar-0x/", "categories": "C#, 03.Grammar", "tags": "C#, Grammar, Unity", "date": "2022-09-08 00:00:00 +0900", "snippet": "where(특수화) C#에만 있는 문법으로 특수화를 할 때 사용한다. 구체화할 때 where T : type 👉 T를 type타입으로만 구체화하도록 제약을 둔다.class MyList &lt;T&gt; where T : Monster{} 종류 설명 where T : struct T는...", "content": "where(특수화) C#에만 있는 문법으로 특수화를 할 때 사용한다. 구체화할 때 where T : type 👉 T를 type타입으로만 구체화하도록 제약을 둔다.class MyList &lt;T&gt; where T : Monster{} 종류 설명 where T : struct T는 Call by Value 형식어야 한다. int, float, struct 등등.. where T : class T는 Call by Reference 형식어야 한다.모든 클래스, 인터페이스, 대리자 또는 배열 형식에도 적용된다.따라서 기본 자료형은 들어올 수 없다. where T : new() T는 매개 변수 없는 디폴트 생성자를 반드시 가지고 있어야 한다.where T : Monster, new()는 Monster타입의 클래스로만 구체화될 수 있으며구체화될 땐 디폴트 생성자 를호출해야 한다. where T : 특정 클래스 이름 T는 해당 클래스와 해당 클래스의 자식 클래스 타입의 객체여야만 한다.where T : Monster는 Monster와 Monster를 상속받는 Orc, Slime 등등의 클래스 타입의 객체로만 구체화될 수 있다. where T : 인터페이스 이름 T는 명시한 인터페이스를 반드시 구현해야 한다. 인터페이스를 여러개 명시해줄 수도 있다. where T : U T는 또 다른 형식 매개 변수 U와 일치하거나 U로부터 상속 받은 클래스여야 한다. 참고 사이트 공부하는 식빵맘 [BQRIUM] - C# where 키워드" }, { "title": "C# Grammar#05 | Generic(일반화) 과 Non-Generic", "url": "/posts/Grammar-05/", "categories": "C#, 03.Grammar", "tags": "C#, Grammar, Unity", "date": "2022-09-08 00:00:00 +0900", "snippet": "참고 사이트 tutorials_korea", "content": "참고 사이트 tutorials_korea" }, { "title": "C# Grammar#04 | while, do while", "url": "/posts/Grammar-04/", "categories": "C#, 03.Grammar", "tags": "C#, Grammar, Unity", "date": "2022-09-08 00:00:00 +0900", "snippet": "whileC# while 문은 while 조건식이 true인 동안 계속 while 블럭을 실행할 때 사용한다. 다음 예제는 while문을 사용하여 1부터 10까지 숫자를 콘솔에 출력하는 코드이다. 아래에서 i가 11이 되면 while 조건식이 false가 되어 while 루프를 빠져나오게 된다.static void Main(string[] args){...", "content": "whileC# while 문은 while 조건식이 true인 동안 계속 while 블럭을 실행할 때 사용한다. 다음 예제는 while문을 사용하여 1부터 10까지 숫자를 콘솔에 출력하는 코드이다. 아래에서 i가 11이 되면 while 조건식이 false가 되어 while 루프를 빠져나오게 된다.static void Main(string[] args){ int i = 1; // while 루프 while (i &lt;= 10) { Console.WriteLine(i); i++; }}do whiledo ~ while은 위의 while문과 거의 비슷하나, 마지막 while 조건식까지 가기 전에 do ~ while 사이의 블럭을 미리 한 번 실행한다는 점에서 차이가 있다.static void Main(string[] args){ int i=1; // do ~ while 루프 do { Console.WriteLine(i); i++; } while (i &lt; 10);}C# 반복 구문 예제아래 예제는 콘솔로부터 Q키가 입력되지 전까지 계속 키 입력을 받아들인 후, 그동안 입력된 키들을 foreach 루프를 써서 출력해 본 예이다.using System;using System.Collections.Generic;namespace MySystem{ class Program { static void Main(string[] args) { List&lt;char&gt; keyList = new List&lt;char&gt;(); ConsoleKeyInfo key; do { key = Console.ReadKey(); keyList.Add(key.KeyChar); } while (key.Key != ConsoleKey.Q); // Q가 아니면 계속 Console.WriteLine(); foreach (char ch in keyList) // 리스트 루프 { Console.Write(ch); } } }}참고 사이트 1commit1zerocoke 예제로 배우는 C# 프로그래밍" }, { "title": "C# Grammar#03 | for(반복 구문) vs foreach(배열 반복문)", "url": "/posts/Grammar-03/", "categories": "C#, 03.Grammar", "tags": "C#, Grammar, Unity", "date": "2022-09-08 00:00:00 +0900", "snippet": "for(반복 구문)C# for 문은 루프 안에 있는 문장들을 반복적으로 실행할 때 사용한다. for 루프는 일반적으로 카운터 변수를 이용해 일정 범위 동안 for 루프 안의 블럭을 실행한다.다음 예제는 0부터 9까지 총 10번 콘솔 출력을 반복하는 코드이다.class Program{ static void Main(string[] args) ...", "content": "for(반복 구문)C# for 문은 루프 안에 있는 문장들을 반복적으로 실행할 때 사용한다. for 루프는 일반적으로 카운터 변수를 이용해 일정 범위 동안 for 루프 안의 블럭을 실행한다.다음 예제는 0부터 9까지 총 10번 콘솔 출력을 반복하는 코드이다.class Program{ static void Main(string[] args) { // for 루프 for (int i = 0; i &lt; 10; i++) { Console.WriteLine(\"Loop {0}\", i); } }}foreach(배열 반복문)int[] arr = new int[10] {1 , 2, 3, 4, 5, 6, 7, 8, 9, 10 };foreach(int value in arr) {\tConsole.WriteLine(\"{0}\", value);}하나의 요소로서 value를 선언해주었고 in 뒤에는 순회할 자료형을 쓴다.대표적으로 배열이나 List, ArrayList 등을 많이 사용하게 된다.위 예제처럼 아주 간단하다면 편리함을 크게 못느낄수도 있지만 배열의 요소를 많이 사용한다면for문으로 arr[i] 처럼 사용하는 것보다는 foreach에서 처럼 사용하는 것이 직관적이며 도움이 될 수 있다.for vs foreachC#에서 for와 foreach를 비교하는 것은 흔히 성능적 측면과 코드 가독성 측면을 고려하는데, 성능적 측면은 for가 경우에 따라 약간 빠를 수 있지만 대부분의 경우 성능적 차이는 크지 않으며, foreach는 for보다 훨신 간결한 코드를 제공한다는 장점이 있다.특히, 루프에서 가장 많이 사용되는 C# 배열(array)의 경우, foreach가 내부적인 최적화를 거쳐 for 루프와 동일한 성능이므로 더 간결한 foreach를 사용할 것을 권장한다. 예를 들어, 2차배열, 3차배열 등의 다중 배열을 처리할 경우, for루프는 배열 차수만큼 여러번 루프를 돌려야 하지만, foreach는 아래와 같이 단순히 한 루프 문장으로 이를 처리할 수 있어 편리하다.static void Main(string[] args){ // 3차배열 선언 string[,,] arr = new string[,,] { { {\"1\", \"2\"}, {\"11\",\"22\"} }, { {\"3\", \"4\"}, {\"33\", \"44\"} } }; //for 루프 : 3번 루프를 만들어 돌림 for (int i = 0; i &lt; arr.GetLength(0); i++) { for (int j = 0; j &lt; arr.GetLength(1); j++) { for (int k = 0; k &lt; arr.GetLength(2); k++) { Debug.WriteLine(arr[i, j, k]); } } } //foreach 루프 : 한번에 3차배열 모두 처리 foreach (var s in arr) { Debug.WriteLine(s); }}참고 사이트 1commit1zerocoke 예제로 배우는 C# 프로그래밍" }, { "title": "C# Grammar#02 | enum", "url": "/posts/Grammar-02/", "categories": "C#, 03.Grammar", "tags": "C#, Grammar, Unity", "date": "2022-09-08 00:00:00 +0900", "snippet": "enum 열거형 -&gt; 같은 종류의 상수 모음 상수나 변수를 사용하는 이유 상수 리터럴을 통한 하드 코딩은 그 의미를 알기 쉽지 않고 리팩토링이 어렵기 때문에. enum 열거형을 사용하는 이유 상수이므로 의미를 알기 쉽다. 연관된 것들을 하나의 enum 으로 묶기 때문에 그룹화를 할 수 있다...", "content": "enum 열거형 -&gt; 같은 종류의 상수 모음 상수나 변수를 사용하는 이유 상수 리터럴을 통한 하드 코딩은 그 의미를 알기 쉽지 않고 리팩토링이 어렵기 때문에. enum 열거형을 사용하는 이유 상수이므로 의미를 알기 쉽다. 연관된 것들을 하나의 enum 으로 묶기 때문에 그룹화를 할 수 있다. 상수나 변수가 굉장히 많아지면 이름이 중복될 우려도 있는데 서로 다른 enum에 속하면 이름이 동일해도 전혀 다른 것으로 간주되기 때문에 이름 중복 우려를 방지할 수 있다.s enum Choice { Rock, Paper, Scissors } static void Main(string[] args) { 열거형 선언은 클래스처럼 함수 밖에서 선언되야 한다. 내부적으론 정수가 저장된다. 값이 입력 안되면 디폴트 값 0 에서 출발하여 0, 1, 2, 3, 이런식으로 저장된다. 이전 값에서 +1 한 값으로 설정된다. 아래와 같이 직접 값을 명시해줄 수도 있다. enum Choice { Rock = 1, Paper, // 자동으로 2가 된다. 이전 값이 1 이어서. Scissors = 0 } enum은 상수의 모음이기 때문에 case문에 사용할 수 있다. Choice.Rock, Choice.Paper 이거 자체로는 정수타입이 아니라 enum 타입이기 때문에 (int)로 형 변환 해주어야 한다. ✔현재 switch 조건문의 choice가 int형이니까 !!! (int)Choice.Rock, (int)Choice.Paper int choice = 2;switch(choice){ case (int)Choice.Rock: break; case (int)Choice.Paper: break;} 열거형 변수는 초기화 하지 않으면 자동으로 첫번째 값으로 초기화 한다. enum Choice { Rock = 1, Paper, // 자동으로 2가 된다. 이전 값이 1 이어서. Scissors = 0 } static void Main(string[] args) { Choice choice; // 초기화 안했지만 자동으로 choice = Choice.Rock 이 됨. }참고 사이트 공부하는 식빵맘" }, { "title": "C# Grammar#01 | Switch", "url": "/posts/Grammar-01/", "categories": "C#, 03.Grammar", "tags": "C#, Grammar, Unity", "date": "2022-09-08 00:00:00 +0900", "snippet": "Switch if - else 반복 줄임 가독성 높임 switch(n) 인수로는 기본적으로 정수와 문자를 넣을 수 있음 최근 C# 에서는 다른 타입의 객체도 넣을 수 있게끔 개선됐다. int choice = 0;switch(choice){ case 0: Console.WriteLine(\"가위\"); ...", "content": "Switch if - else 반복 줄임 가독성 높임 switch(n) 인수로는 기본적으로 정수와 문자를 넣을 수 있음 최근 C# 에서는 다른 타입의 객체도 넣을 수 있게끔 개선됐다. int choice = 0;switch(choice){ case 0: Console.WriteLine(\"가위\"); break; case 1: Console.WriteLine(\"바위\"); break; case 2: Console.WriteLine(\"보\"); break; default: Console.WriteLine(\"다 실패\"); break;} break에 걸리지 않으면 해당된 case에서부터 쭉쭉 다 실행한다. 해당 case만 실행 시킬 것이라면 break 꼭 명시. break는 switch문을 벗어나는 것에 해당한다. switch문으로 표현 한 것은 항상 if-else문으로도 표현할 수 있지만 그 반대는 항상 성립되는 것은 아니다. switch는 값에 따른 분기에만 한정 됨. 따라서 간단한 분기의 경우 가독성 좋은 switch를 권장. 복잡한 조건 분기의 경우 if-else문 사용하기. switch문의 case 값으로는 일반 변수가 들어갈 순 없다. 상수 리터럴이나 const 상수가 들어가야 한다. 즉 실행 중에 값이 바뀔 수 있는 변수는 들어갈 수 없다. 이와 달리 if-else문은 조건문에도 일반 변수를 사용할 수 있다. int ROCK = 1; const int PAPER = 2;switch(choice){ case ROCK: // ❌ 에러! case 엔 컴파일타임에 메모리가 결정되는 상수가 들어와야 한다. break; case PAPER: // ⭕ const 상수이므로 문제 없다. break;} 참고 사이트 공부하는 식빵맘 Chameleon Studio" }, { "title": "22-09-07(수)", "url": "/posts/Diary-220907/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-07 00:00:00 +0900", "snippet": "＃C#C# 공부 C# - C# online editor, IDE, compiler, interpreter, and REPL C# - 공부하는 식빵맘 C# - 예제로 배우는 C# 프로그래밍 C# - 나무위키 C# - Microsoft Docs＃Data 정수 형식, 2진수, 16진수, 정수 범위 형변환 const(상수) String 비트...", "content": "＃C#C# 공부 C# - C# online editor, IDE, compiler, interpreter, and REPL C# - 공부하는 식빵맘 C# - 예제로 배우는 C# 프로그래밍 C# - 나무위키 C# - Microsoft Docs＃Data 정수 형식, 2진수, 16진수, 정수 범위 형변환 const(상수) String 비트 연산 Object 와 Boxing/Unboxing Method, ref, out＃Object Oriented Programming(객체 지향) 객체 지향 자연 언어 복사와 참조 스택과 힙 생성자, this / this() 키워드 Static 정적 변수 / 정적 함수 / 정적 클래스 inheritance(상속성), base 키워드 Data Hiding(은닉성) - 접근 제한자 클래스 형변환(is, as) new Polymorphism(다형성), virtual(가상 함수), override, sealed)＃Data Structure(자료구조) tutorials_korea Array Multidimensional Arrays List Multidimensional List Dictionary＃문법 Switch enum(열거형) foreach(배열 반복문) - 공부하는 식빵맘 Nullable(널러블) Indexer(인덱서) Generic(일반화) 과 Non-Generic - tutorials_korea where(특수화) Interface(인터페이스) IEnumerator(열거자) IEnumerable(열거자, IEnumerator를 리턴) yield Anonymous Method(익명 메소드) Struct(구조체) Delegate(대리자) Generic Delegate Func Generic Delegate Action Call Back Method(콜백 함수) Lambda(람다식) Property(프로퍼티) Event(이벤트) Exception(예외 처리) Reflection(리플렉션)＃알고리즘＃디자인 패턴" }, { "title": "C# Data Structure#06 | Dictionary", "url": "/posts/Data-Structure-06/", "categories": "C#, 04.Data Structure", "tags": "C#, Data Structure", "date": "2022-09-07 00:00:00 +0900", "snippet": "Dictionary dic[Key] = Value, Key를 통하여 접근하여 그에 대응하는 Value를 불러올 수 있다. using System.Collections.Generic; using 선언 필수 얘도 클래스이기 때문에 Dictionary 타입의 객체를 생성하면 참조를 하게 된다는 의미가 된다. new를 사용하여 생성해야 ...", "content": "Dictionary dic[Key] = Value, Key를 통하여 접근하여 그에 대응하는 Value를 불러올 수 있다. using System.Collections.Generic; using 선언 필수 얘도 클래스이기 때문에 Dictionary 타입의 객체를 생성하면 참조를 하게 된다는 의미가 된다. new를 사용하여 생성해야 함. 해시 테이블을 사용하기 때문에 매우 빠르다. 공간을 미리 많이 차지하고 있기 때문에 공간 면에선 비효율적일 수 있다. 메모리를 내주고 성능을 취한다. class Monster { public Monster(int id) { this.id = id; } public int id; } class Program { static void Main(string[] args) { Dictionary&lt;int, Monster&gt; dic = new Dictionary&lt;int, Monster&gt;(); } }추가 : Add(Key, Value)Dictionary&lt;int, Monster&gt; dic = new Dictionary&lt;int, Monster&gt;();dic.Add(1, new Monster());dic[5] = new Monster(5); // Key 5 가 새롭게 생김 추가 방법 Add 사용 Add(Key, Value) [] 사용 기존에 없는 Key에 Value 를 대입해도 추가가 된다. Value 가져오기 : TryGetValue(Key, out)Dictionary&lt;int, Monster&gt; dic = new Dictionary&lt;int, Monster&gt;();for(int i = 0; i &lt; 10; i++) dic.Add(i, new Monster(i));Mionster mon = dic[5]; // ⭕Mionster mon2 = dic[154]; // ❌ 154는 없는 Key이기 때문에 리턴 값이 없다. 따라서 런타임 에러 발생.Mionster mon3;bool found = dic.TryGetValue(154, out mon3); // ⭕ mon3에 154 키에 해당하는 값이 저장된다. Value 가져오는 방법 [] 사용 없는 Key로 접근하여 Value를 받아오려 할 경우 런타임 에러가 발생할 수 있다. TryGetValue(Key, out) 해당 Key가 Dictionary에 존재한다면 Value를 out 키워드 붙은 변수에 저장하고 (원본 저장, 참조) True를 리턴한다. 해당 Key가 Dictionary에 존재하지 않는다면 False를 리턴하고 mon 변수는 null 상태로 남을 것이다. 삭제 : Remove(Key), Clear()Dictionary&lt;int, Monster&gt; dic = new Dictionary&lt;int, Monster&gt;();for(int i = 0; i &lt; 10; i++) dic.Add(i, new Monster(i));dic.Remove(7); // 해당 key에 해당하는 정보 삭제.dic.Clear();검색 : ContainsKey(Key)Dictionary&lt;int, Monster&gt; dic = new Dictionary&lt;int, Monster&gt;();if (dic.ContainsKey(3)) Console.WriteLine(\"3 Key가 존재합니다\"); ContainsKey(Key) 해당 키가 Dictionary 안에 있다면 True, 없다면 False. 참고 사이트 공부하는 식빵맘" }, { "title": "C# Data Structure#05 | Multidimensional List(다차원 동적 배열)", "url": "/posts/Data-Structure-05/", "categories": "C#, 04.Data Structure", "tags": "C#, Data Structure", "date": "2022-09-07 00:00:00 +0900", "snippet": "Multidimensional List(다차원 동적 배열)불행히도 C#에서 다차원 목록을 선언하는 기본 제공 메서드는 없습니다. 따라서 이 목표를 달성하려면 사용자 정의 접근 방식에 의존해야합니다.C#에서List&lt;List&gt;를 사용하여 2D 목록 선언List&lt;List&lt;T&gt;&gt;표기법을 사용하여 목록의 명부를 선언 할 수 있습...", "content": "Multidimensional List(다차원 동적 배열)불행히도 C#에서 다차원 목록을 선언하는 기본 제공 메서드는 없습니다. 따라서 이 목표를 달성하려면 사용자 정의 접근 방식에 의존해야합니다.C#에서List&lt;List&gt;를 사용하여 2D 목록 선언List&lt;List&lt;T&gt;&gt;표기법을 사용하여 목록의 명부를 선언 할 수 있습니다. 여기서 T 는 목록 내의 변수 유형을 지정합니다.다음 코드 예제는 C#에서 List&lt;List&lt;T&gt;&gt;표기법을 사용하여 2D 목록을 선언하는 방법을 보여줍니다.using System;using System.Collections.Generic;namespace multidimensional_list{ class Program { static void Main(string[] args) { List&lt;List&lt;string&gt;&gt; Person = new List&lt;List&lt;string&gt;&gt;(); for (int i = 0; i &lt; 3; i++) { List&lt;string&gt; Data = new List&lt;string&gt;(); Data.Add(\"Person \"); Data.Add(\"Description \"); Person.Add(Data); } foreach (var list in Person) { foreach (var element in list) { Console.Write(element); } Console.WriteLine(); } }}ResultPerson DescriptionPerson DescriptionPerson DescriptionC#에서 List&lt;List&lt;string&gt;&gt; 표기법을 사용하여 문자열 변수의 2D 목록 Person을 선언했습니다. 목록에 데이터를 입력하려면 데이터를 다른 string 변수 목록에 저장 한 다음 Person.Add() 함수를 사용하여 해당 객체를 Person 목록에 추가해야합니다. 중첩 루프가있는 목록을 출력합니다. 이 방법의 단점은 2D 배열에서만 작동하며 1 데이터 유형의 요소만 포함 할 수 있다는 것입니다.C#에서 클래스 목록을 사용하여 다차원 목록 선언여러 데이터 형식의 목록을 만들려면 C#에서 클래스 개체 목록을 선언 할 수 있습니다. 아시다시피 class에는 데이터 형식이 다른 여러 변수가 포함될 수 있습니다.다음 코드 예제는 C#에서 개체 목록을 만들어 2D 목록을 선언하는 방법을 보여줍니다.using System;using System.Collections.Generic;namespace multidimensional_list{ public class Person { public string Name { get; set; } public string Description { get; set; } } class Program { static void Main(string[] args) { List&lt;Person&gt; People = new List&lt;Person&gt;(); for(int i = 0; i &lt; 3; i++) { Person p = new Person(); p.Name = \"Person \"; p.Description = \"Description \"; People.Add(p); } foreach(var obj in People) { Console.WriteLine(obj.Name); Console.WriteLine(obj.Description); } }}ResultPersonDescriptionPersonDescriptionPersonDescriptionC#에서 Person 클래스 목록을 생성하여 2D 목록 People 을 선언했습니다. 목록에 데이터를 입력하려면 Person 클래스의 객체에 데이터를 저장 한 다음 People.Add() 함수를 사용하여 해당 객체를 People 목록에 추가해야합니다.이 접근 방식을 사용하면 목록에 서로 다른 데이터 유형의 여러 요소를 가질 수 있습니다.C#에서 튜플 목록을 사용하여 다차원 목록 선언목록에서 여러 데이터 유형을 사용하고 싶지만 모든 변수를 저장하는 별도의 클래스를 만들고 싶지 않은 경우 튜플 목록을 선언 할 수도 있습니다. C#에서 List&lt;(T1, T2)&gt; 표기법으로 튜플 목록을 선언 할 수 있습니다. 여기서 T1 및 T2는 각각 튜플의 첫 번째 및 두 번째 요소의 데이터 유형입니다.다음 코드 예제는 C#에서 튜플 목록으로 다차원 목록을 선언하는 방법을 보여줍니다.using System;using System.Collections.Generic;namespace multidimensional_list{ class Program { static void Main(string[] args) { List&lt;(string, string)&gt; Person = new List&lt;(string, string)&gt;(); for (int i = 0; i &lt; 3; i++) { Person.Add((\"Person\", \"Description\")); } foreach (var list in Person) { Console.WriteLine(list); } }}Result(Person, Description)(Person, Description)(Person, Description)C#에서 ist&lt;(string, string)&gt; 표기법을 사용하여 Person 튜플 목록을 선언했습니다. Person 목록에 튜플 형태로 데이터를 입력하고 foreach 배열 반복문으로 표시합니다.참고 사이트 C# 하우투 IEnumerable을 C#의 목록으로 변환하는 방법 C# 목록에서 항목 제거 C# 두 목록을 함께 결합 C#에서 필드별로 목록 정렬" }, { "title": "C# Data Structure#04 | List(동적 배열)", "url": "/posts/Data-Structure-04/", "categories": "C#, 04.Data Structure", "tags": "C#, Data Structure", "date": "2022-09-07 00:00:00 +0900", "snippet": "List(동적 배열)C#에서 List는 동적 배열 = 가변적 크기의 배열(C++에선 vector와 같은 존재) using System.Collections.Generic; using 선언 필수 얘도 클래스이기 때문에 List 타입의 객체를 생성하면 참조를 하게 된다는 의미가 된다. new를 사용하여 생성해야 함.```c#using ...", "content": "List(동적 배열)C#에서 List는 동적 배열 = 가변적 크기의 배열(C++에선 vector와 같은 존재) using System.Collections.Generic; using 선언 필수 얘도 클래스이기 때문에 List 타입의 객체를 생성하면 참조를 하게 된다는 의미가 된다. new를 사용하여 생성해야 함.```c#using System.Collections.Generic; List list = new List(); // 빈 상태``` 빈 상태일 때 없는 인덱스에 접근하면 런타임 에러 예외가 발생한다. 이건 정적 배열(Array)도 동일 중간 삽입, 중간 삭제가 효율적이지 않다. 뒤에 있는 원소들이 전부 다 한 칸씩 밀리거나 앞으로 땡겨야 하기 때문이다. 그 과정에서 사본을 생성해야 하는 일도 발생 List의 접근법은 인덱스 접근이기 때문에 임의 접근은 굉장히 빠르다.Count : 리스트 길이 리턴List&lt;int&gt; list = new List&lt;int&gt;();for (int i = 0; i &lt; 5; i++) list.Add(i); // 0 1 2 3 4Console.WriteLine(list.Count); // 5함수 아니고 프로퍼티다.Add : 후열 삽입List&lt;int&gt; list = new List&lt;int&gt;();list.Add(1); // 원소 1 을 추가.List의 끝에다가 새로운 원소를 추가한다.(C++, vector.push_back())Insert : 중간 삽입List&lt;int&gt; list = new List&lt;int&gt;();for(int i = 0; i &lt; 5; i++) list.Add(i); // 0 1 2 3 4list.Insert(2, 999); // 인덱스2 자리에 원소 999 추가 -&gt; 0 1 999 2 3 4Remove : 원소로 search하여 삭제List&lt;int&gt; list = new List&lt;int&gt;();for(int i = 0; i &lt; 5; i++) list.Add(i); // 0 1 2 3 4list.Add(3); // 0 1 2 3 4 3list.Remove(3); // 0 1 2 4 3인수로 넘긴 원소와 동일한 원소들이 있을 수 있지만 가장 처음 만난 원소를 삭제한다. 그리고 삭제에 성공하면 True 리턴, 해당 원소를 찾지 못했다면 False 리턴. bool타입을 리턴한다.RemoveAt : Index로 삭제List&lt;int&gt; list = new List&lt;int&gt;();for(int i = 0; i &lt; 5; i++) list.Add(i); // 0 1 2 3 4list.RemoveAt(0); // 1 2 3 4인수로 넘긴 인덱스에 해당하는 원소를 삭제한다.Clear : 원소를 전부 삭제 하여 리스트 비우기list.Clear(); // 리스트 내의 모든 원소를 싸그리 지운다.참고 사이트 공부하는 식빵맘" }, { "title": "C# Data Structure#03 | Multidimensional Arrays(다차원 정적 배열)", "url": "/posts/Data-Structure-03/", "categories": "C#, 04.Data Structure", "tags": "C#, Data Structure", "date": "2022-09-07 00:00:00 +0900", "snippet": "Multidimensional Arrays(다차원 배열)int [,] arr = new int [2, 3] { {1, 2, 3}, {4, 5, 6} };int [,] arr2 = new int [,] { {1, 2, 3}, {4, 5, 6} };int [,] arr3 = { {1, 2, 3}, {4, 5, 6} };arr[0, 0] = 1;arr[1,...", "content": "Multidimensional Arrays(다차원 배열)int [,] arr = new int [2, 3] { {1, 2, 3}, {4, 5, 6} };int [,] arr2 = new int [,] { {1, 2, 3}, {4, 5, 6} };int [,] arr3 = { {1, 2, 3}, {4, 5, 6} };arr[0, 0] = 1;arr[1, 2] = 6;for(int i = 0; i &lt; arr.GetLength(0); i++) for(int j = 0; j &lt; arr.GetLength(1); j++) C# 에선 arr[a, b] 이런식으로도 표현할 수 있다. 물론 arr[a][b] 표현도 가능하다. 다차원 배열에선 GetLength()로 쓰자. arr.Length() - 배열의 전체 원소 개수. 2 * 3 = 6 arr.GetLength(0) - 행의 개수. 2 arr.GetLength(1) - 열의 개수. 3int [][] a new int[3][];a[0] = new int[3];a[1] = new int[6];a[2] = new int[2];a[0][0] = 1;위와 같이 열의 크기를 나중에 정할 수도 있다. 행마다 배열의 크기가 다르게도 할 수 있다.참고 사이트 공부하는 식빵맘" }, { "title": "C# Data Structure#02 | Array(정적 배열)", "url": "/posts/Data-Structure-02/", "categories": "C#, 04.Data Structure", "tags": "C#, Data Structure", "date": "2022-09-07 00:00:00 +0900", "snippet": "Array(배열)int [] array = new int[5];array[0] = 10;array[1] = 20;array[2] = 30;array[3] = 40;array[4] = 50;int [] array2 = new int[] { 10, 20, 30 };int [] array3 = new int[5] { 10, 20, 30, 40, 50 }; ...", "content": "Array(배열)int [] array = new int[5];array[0] = 10;array[1] = 20;array[2] = 30;array[3] = 40;array[4] = 50;int [] array2 = new int[] { 10, 20, 30 };int [] array3 = new int[5] { 10, 20, 30, 40, 50 }; 동일한 자료형을 가진 데이터들을 연속적인 메모리로 저장하여 인덱스로 접근할 수 있게 된다. new 키워드를 사용하여 동적으로 할당받는 배열을 만들 수 있다. (동적으로 할당 받았다고해서 동적 배열인 것은 아님. 동적 배열은 크기가 가변적인 배열을 의미. 동적으로 할당, 즉 힙 메모리에 할당 받았을 뿐 크기를 바꿀 수 없는 정적 배열이다.) Call by Reference : 배열을 동적으로 할당 받으므로(배열 데이터가 힙메모리에 있으므로) 동일한 배열 메모리를 가리키는 변수가 여러개일 수도 있다. int [] array = new int[5] { 10, 20, 30, 40, 50 };int [] array2 = array; new를 생략하는 것도 가능하다. 그래도 두 변수가 동일한 배열 메모리를 가리킬 수 있는 것을 보면 동적으로 할당(힙 메모리로) 받는 것 같다. C#은 C++과 달리 배열이 무조건 힙 메모리에 존재하게 되어 있다. 즉 무조건 동적으로 할당 받음. int [] array = { 10, 20, 30 };int[] array2 = array; 크기는 한번 선언하면 바꿀 수 없다. 배열 크기를 벗어나는 인덱스로 배열에 접근하면 런타임 에러가 발생한다.참고 사이트 공부하는 식빵맘" }, { "title": "C# Data Structure#01 | Collections 자료구조 정리", "url": "/posts/Data-Structure-01/", "categories": "C#, 04.Data Structure", "tags": "C#, Data Structure, Unity", "date": "2022-09-07 00:00:00 +0900", "snippet": "자료구조의 중요성자료구조는 데이터를 메모리에 저장하는것입니다.데이터량이 많을 때 목적에 맞는 자료구조를 사용하지 않으면 엄청난 비용(속도, 메모리 낭비)의 손실을 가져오거나 심지어 프로그램, 서버가 다운될 수도 있습니다.데이터가 빈번하게 추가되거나 선입선출 등의 우선순위가 있거나 특정 값(Key)로 데이터를 뽑아올 경우가 있거나 등의 목적에 따라 자료...", "content": "자료구조의 중요성자료구조는 데이터를 메모리에 저장하는것입니다.데이터량이 많을 때 목적에 맞는 자료구조를 사용하지 않으면 엄청난 비용(속도, 메모리 낭비)의 손실을 가져오거나 심지어 프로그램, 서버가 다운될 수도 있습니다.데이터가 빈번하게 추가되거나 선입선출 등의 우선순위가 있거나 특정 값(Key)로 데이터를 뽑아올 경우가 있거나 등의 목적에 따라 자료구조를 선택적으로 사용해 주어야 합니다.C# 자료구조 정리 Generic Non-Generic Multi-Thread 동기화 옵션 사용 용도 Dictionary&lt;TKey,TValue&gt; Hashtable ConcurrentDictionary&lt;TKey,TValue&gt;ReadOnlyDictionary&lt;TKey,TValue&gt;ImmutableDictionary&lt;TKey,TValue&gt; Key로 빠르게 데이터를 조회할때 사용Key와 Value 로 데이터가 저장됨 List&lt;T&gt; ArrayArrayList ImmutableList&lt;T&gt;ImmutableArray 데이터가 저장된 순서(인덱스)를 빠르게 탐색함 Queue&lt;T&gt; Queue ConcurrentQueue&lt;T&gt;ImmutableQueue&lt;T&gt; FIFO(선입 선출) 방식으로 항목 사용 Stack&lt;T&gt; Stack ConcurrentStack&lt;T&gt;ImmutableStack&lt;T&gt; LIFO(후입 선출) 방식으로 데이터 사용 SortedList&lt;TKey,TValue&gt; SortedList ImmutableSortedDictionary&lt;TKey,TValue&gt;ImmutableSortedSet&lt;T&gt; 입력된 순서와 상관없이 Key값으로 정렬됨 LinkedList&lt;T&gt; 지원안함 지원안함 데이터 등록, 삭제가 빈번하게 일어날때 ObservableCollection&lt;T&gt; 지원안함 지원안함 목록에 데이터를 넣거나 뺄때 알람을 표시해줌 HashSet&lt;T&gt;SortedSet&lt;T&gt; 지원안함 ImmutableHashSet&lt;T&gt;ImmutableSortedSet&lt;T&gt; 중복된 데이터를 저장하지 않을때(수학에서 집합 사용 시) C# 자료구조 구성도Unity3D에서의 콜렉션Unity3D에서는 배열을 포함한 “콜렉션” 이라고 불리우는 다양한 자료형들을 지원한다. 내장형 배열(Built-in Array) ArrayList HashTable Generic List Generic Dictionary- 2차원 배열모든 타입의 자료형들에는 다음과 같은 공통점이 있다. 모든 자료형은 객체(Object)를 저장할 수 있고, 이를 꺼내서 읽는 것이 가능하다. 자료형의 크기를 알 수 있다. 모든 자료형은 아니지만 대부분의 자료형에 대해서는 임의의 위치에 자료형을 삽입하거나 삭제하는 것이 가능하며 정렬하는 것도 가능하다. 자료형들은 별도의 루프를 통해서 순회하는 것이 가능하다. 다음은 앞에서 언급한 자료형에 대한 설명이다.1.내장형 배열(Built-in Array)Unity의 JS 및 C# 에서 모두 사용이 가능한 기본적인 배열 타입의 자료형이 바로 내장형 배열이다.내장형 배열은 배열을 선언할 때 크기를 함께 설정하기 때문에 고정된 크기를 가지며 매우 빠른 처리가 가능하다. 이 때문에 내장형 배열은 코드에서 빠른 처리를 해야 하고, 자료의 크기(개수)를 알고 있는 경우에는 선택 할 수 있는 가장 좋은 자료형이다. 만약 다양한 개수의 아이템들을 저장해야 하는 경우라도 최대 크기를 알고 있거나 결정할 수 있는 경우라면 내장형 배열을 사용하는 것이 좋다.예를 들어 슈팅 게임에서 총알을 한번에 최대 50개까지만 발사할 수 있다면, 크기가 50인 내장형 내열을 사용해서 사용하지 않는 공간은 null로 채우는 방법을 사용하면 된다.또한 내장형 배열은 Unity 의 Inspector 윈도우 창에 표시할 수 있다.때문에 Unity 에디터를 이용해서 편집이 필요한 자료형이라면 내장형 자료형을 사용하는 것이 편리하다. Unity 의 Get… 함수를 통해서 리턴되는 배열형은 모두 내장형 배열이다.예를 들어 GetComponentInChildren 함수가 리턴하는 컴포넌트 들은 내장형 배열을 사용해서 저장할수 있다. //declarationTheType[] myArray = new TheType[lengthOfArray]; //declaration example using intsInt[] myNumbers = new int[10]; //declaration example using GameObjectsGameObject[] enemies = new GameObject[16]; // get the length of the arrayint howBig = myArray.Length; // set a value at position imyArray[i] = newValue; //get a value from position iTheType thisValue = myArray[i]; 2.ArrayListArrayList는 .NET 의 자료형으로 Javascript 배열과 매우 유사하다. 다만 JS 뿐만 아니라 C#에서도 사용이 가능하다, 하지만 크기가 역시 동적이기 때문에 자료의 삽입 및 삭제시 ArrayList의 크기가 변경될 수 있다. 내장형 배열과 비교하면 속도가 떨어진다. //declarationArrayList myArrayList = new ArrayList();// add an item to the end of the array.myArrayList.Add(anItem);//change the value stored at position imyArrayList[i] = newValue;//retrieve an item from position iTheType thisItem = (TheType) myArrayList[i];//removes an item from position imyArrayList.RemoveAt(i);//get the number of items in the ArrayListVar howBig = myArray.length;  ``` ## 3.Hash Table해시테이블은 각각의 아이템이 KEY 와 VALUE 으로 구성된 자료형으로 빠른 검색이 필요한 경우에 요긴하게 사용할 수 있는 것이 장점이다.주어진 KEY 로 검색하게 되면 VALUE을 리턴하는 방식이다.ArrayList와 마찬가지로 해쉬테이블 역시 얻어 온 값에 대한 형변환(type casting)이 필요하다.```c#//declarationHashtable myHashtable = new Hashtable(); //insert or change the value for the given keymyHashtable[anyKey] = newValue; //retrieve a value for the given keyValueType thisValue = (valueType)myHashtable[theKey]; //get the number of items in the HashtableInt howBig = myHashtable.Count; //remove the key &amp; value pair from the Hashtable, for the given key.myHashtable.Remove(theKey); 4.Generic ListUnity3D엔진은 3.0 버전부터 iOS에서 .NET 의 제너릭 자료형을 지원한다.또한 3.0 버전부터는 Javascript에서도 이 제너릭 콜렉션을 사용할 수 있게 되었다. 제너릭 리스트는 제너릭 콜렉션에 속한 자료형으로 동적인 크기를 가지며, 임의의 위치에 자료형의 삽입과 삭제가 가능하는 점에서 Javascript 배열 및 ArrayList 와 유사하다.제너릭 리스트와 이들 자료형과의 가장 큰 차이점이라면 제너릭 리스트는 자료형을 선언 할 떄 자료형의 타입을 지정한다는 점이다. 그리고 사용 할 때에는 선언시 지정한 자료형만을 삽입하거나 삭제할 수 있다.그러므로 다음과 같은 특징을 가지게 된다. 명시적인 형변환을 할 필요가 없다. ArrayList 보다 빠르다. 이러한 특징을 잘 이해해서 만약에 사용하고자 하는 자료의 형을 미리 알고 있는 경우에는 ArrayList 보다 제너릭 리스트를 사용하는 것이 훨씬 유리하다.제너릭 리스트는 System.Collections 에 기본적으로 포함되어 있지 않기 때문에 제너릭 리스트를 사용하는 경우에는 명시적으로 using System.Collections.Generic 선언이 필요하다.//declarationList&lt;Type&gt; myList = new List&lt;Type&gt;();//a real-world example of declaring a List of ‘ints’List&lt;int&gt; someNumbers = new List&lt;int&gt;(); //a real-world example of declaring a List of “GameObjects”List&lt;GameObject&gt; enemies = new List&lt;GameObject&gt;(); //add an item to the end of the List.myList.Add(theItem); //change the value in the List at position imyList[i] = newItem; //retrieve the item at position iType thisItem = List[i]; //remove the item from position imyList.RemoveAt(i);5.Generic Dictionary (제너릭 딕셔너리)제너릭 리스트와 마찬가지로 Unity 3.0 버전부터 iOS 와 JS에서도 사용이 가능한 제너릭 콜렉션 이다.제너릭 리스트가 ArrayList와 유사한 반면, 제너릭 딕셔너리는 해쉬테이블과 유사하다고 볼수 있다.제너릭 리스트 처럼 Generic Dictionary도 선언시 아이템의 타입을 명시적으로 선언해 주어야 하며, 제너릭 리스트가 ArrayList에 비해 빠른 속도를 나타내는 것처럼 제너릭 딕셔너리도 일반 딕셔너리에 비해 동적인 형변환에 드는 시간이 없기 때문에 더욱 빠르게 작동한다.Using 선언 하는 것은 잊지 말기 // declarationDictionary&lt;KeyType,ValueType&gt; myDictionary = new Dictionary&lt;KeyType,ValueType&gt;(); //and a real-world declaration example(where “person” is a custom class);Dictionary&lt;string,Person&gt; myContacts = new Dictionary&lt;string,Person&gt;(); //insert or change the value for the given keymyDictionary[anyKey] = newValue;//retrieve a value for the given keyValueType thisValue = myDictionary[theKey];//get the number of items in the HashtableInt howBig = myDictionary.count;//remove the key &amp; value pair ifrom the Hashtable, for the given key.myDictionary.Remove(theKey); 6.2차원 배열(2D Array)내장형 배열, Javascript 배열, ArrayList, 제너릭 리스트 및 제너릭 딕셔너리가 1차원인 자료형인 반면에 2차원 배열은 제목 그대로 2차원을 지원하는 배열 자료형이다.게임에서는 타일 인덱스를 저장하기 위한 레벨의 맵 데이터가 이러한 다차원 배열의 예에 속한다. 다차원 배열은 크게 두 종류로 구분할 수 있다.첫번째는 말 그대로 다차원 배열이 경우로 이 경우에는 myArray[x][y]에서와 같이 고정된 x와 y값의 크기가 필요하다.다른 것으로는 jagged 배열이 있는데, 이 경우에는 실제로는 다차원이 아니지만 일차원의 배열을 다차원처럼 사용하는 방법이다. myArray[x + y*width]; 맵 데이터의 예와 같이 실제 다차원 배열을 사용하는 것이 훨씬 직관적인 경우가 있지만 다차원 배열을 중첩해서 사용하는 등의 경우에는 퍼포먼스에 영향을 미칠 수 있기 때문에 직관적이지 않더라도 퍼포먼스를 고려한다면 일차원 배열을 확장하거나 변형해서 사용하는 편이 좋다. //Declaration//a 16x 4 array of stringsstring[,] myArray = new string[16,4]; //and a real-world declaration example( where ‘Tile’ is a user-created custom class): //creat an array to hold a map of 32x32 tilesTile[,] map = new Tile[32,32]; //set the value at a given location in the arraymyArray[x,y] = newValue; //retrieve a value from a given location in the array.ValueType thisValue = myArray[x,y]; //get the length of 1st dimension of the arrayint width = myArray.GetUpperBound(0);//get the length of 2nd dimension of the arrayInt length = myArray.GetUpperBound(1);참고 사이트 tutorials_korea kimseunghyun76 - Unity3D에서의 Collections 콜렉션 자료형" }, { "title": "22-09-06(화)", "url": "/posts/Diary-220906/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-06 00:00:00 +0900", "snippet": "＃블로그 댓글 기능 추가 검색 노출 구글 애널리틱스 연결 아이콘 변경＃취업 활동 입사지원서 인적사항 작성＃위키북스 절대강좌! 유니티 책 따라가기 4장", "content": "＃블로그 댓글 기능 추가 검색 노출 구글 애널리틱스 연결 아이콘 변경＃취업 활동 입사지원서 인적사항 작성＃위키북스 절대강좌! 유니티 책 따라가기 4장" }, { "title": "22-09-05(월)", "url": "/posts/Diary-220905/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-05 00:00:00 +0900", "snippet": "＃경진대회 발표자료＃프로젝트 패널 관련 작업 패널 싱크 조절 스팩트럼 분석한 데이터에서 출력 구간 지정 패널 태그 지정 콜라이더로 함수 컨트롤 트리거와 플래그 변수를 사용했다. 패널 매니저의 ...", "content": "＃경진대회 발표자료＃프로젝트 패널 관련 작업 패널 싱크 조절 스팩트럼 분석한 데이터에서 출력 구간 지정 패널 태그 지정 콜라이더로 함수 컨트롤 트리거와 플래그 변수를 사용했다. 패널 매니저의 컨트롤러와 콜라이더 트리거 반응 추가 소리 파티클 점수 End Event 클립의 플레이 타임이 경과되면 출력하도록 한다. Music List Reset Result UI 출력 하도록 만들기 데이터 저장 및 보안 -&gt; json ＃개인 깃허브 리드미 수정" }, { "title": "22-09-04(일)", "url": "/posts/Diary-220904/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-04 00:00:00 +0900", "snippet": "＃개인 공부 절대강좌! 유니티 14장까지 3장까지 완료 ", "content": "＃개인 공부 절대강좌! 유니티 14장까지 3장까지 완료 " }, { "title": "위키북스 절대강좌! 유니티 책 따라가기", "url": "/posts/Unity-SpaceShooter/", "categories": "Unity", "tags": "Unity", "date": "2022-09-03 00:00:00 +0900", "snippet": "※ 01장 : 유니티 엔진의 소개(생략)※ 02장 : 게임 개발 준비이 책에서 개발할 게임 소개 및 개발 순서이 책을 통해 개발할 게임은 3인칭 시점 슈팅(TPS, Third Person Shooting) 게임이다.개발 순서 게임 개발 환경 설정 게임에서 사용할 리소스 내려받기 및 설치 게임의 배경이 되는 스테이지 제작 주인공의 이동 및 공격 ...", "content": "※ 01장 : 유니티 엔진의 소개(생략)※ 02장 : 게임 개발 준비이 책에서 개발할 게임 소개 및 개발 순서이 책을 통해 개발할 게임은 3인칭 시점 슈팅(TPS, Third Person Shooting) 게임이다.개발 순서 게임 개발 환경 설정 게임에서 사용할 리소스 내려받기 및 설치 게임의 배경이 되는 스테이지 제작 주인공의 이동 및 공격 기능 구현 적 캐릭터 생성 및 추적 기능 구현 주인공과 적 캐릭터 간의 공격 및 피격 기능 구현 게임 매니저 및 오브젝트 풀링 구현프로젝트 생성유니티 허브 새 프로젝트 생성 : 3D / SpaceShooter 기존 프로젝트 관리 유니티 라이센스 등록유니티 버전 Unity 2021.3.9f1(LTS)유니티 에디터의 환경설정레이아웃내가 사용하는 커스텀이다.프로젝트와 하이러키, 인스펙터 이동 동선이 가까워서 좋다.프로젝트 뷰의 칼럼보통 ‘One Column Layout’를 사용한다.Sprite나 Metarial 등을 볼 땐 ‘Two Column Layout’이 편했다.프로젝트 뷰의 체계적인 관리프로젝트 뷰는 게임 개발에 사용하는 모든 리소스가 저장되는 곳이므로, 개발을 진행할수록 많은 리소스가 쌓이므로 혼란이 생긴다. 그러므로 처음부터 체계적으로 관리하는 게 중요하다.캐릭터 모델 임포트하기이 책에선 MADFINGER Games - ShadowGun:Deadzone 게임의 에셋을 사용한다. 깃허브 저장소에서 내려받기유니티 패키지를 통한 리소스 설치프로젝트 뷰에 드래그 &amp; 드랍으로 패키지를 임포트한다.Asset Store에셋 스토어는 다양한 리소스를 사고팔 수 있는 오픈마켓이다.※ 라이센스를 주의하며 설치할 것무료 리소스 내려받기설치 목록 Yughues Free Metal Materials Skybox Volume 2 (Nebula) Barrel이후 패키지 매니저에서 내려 받기정리 프로젝트 폴더 설정 사용할 리소스 설치게임 개발에 필요한 여러 가지 에셋을 설치했다.유니티의 장점 중 하나인 에셋 스토어에서는 많은 무료 에셋을 제공한다.※ 03장 : 게임 스테이지 제작바닥 생성 및 배치게임의 배경이 도는 스테이지를 제작할 때 먼저 작업하는 것 중 하나가 바로 바닥인 Floor다.보통 유니티에서 제공하는 원시 모델(Primitive Model) 중 Plane 또는 Cube를 사용한다.트랜스폼 스케일 값 1단위는 1m로 디자인 되어있다.※ 오브젝트를 생성하면 항상 포지션 값을 확인 후 리셋하는 습관을 기른다.아래의 설정을 하면 자동으로 월드 좌표 원점으로 설정해준다.Texture(텍스처)텍스처(Texture)란 3D 모델의 표면에 매핑시킬 이미지 파일을 지칭한다.텍스처의 크기는 가로 세로가 2ⁿ(예: 256x256, 1024x1024) 형태일 때 압축을 지원하며, 속도가 가장 빠르다.특히 모바일 플랫폼에서 속도를 향상시키고 싶다면 반드시 2ⁿ(POT, Power Of Two) 형태의 텍스처를 사용해야 한다.텍스처의 해상도 조절 해상도를 줄일 수록 용량이 크게 줄어든다. 프로젝트를 진행할 때 대상 플랫폼을 명확히 설정하고 임포트한 텍스처의 품질을 어떻게 관리할 것인지 미리 결정해야 한다. 따라서 프로젝트 진행 중 임포트한 텍스처는 바로 적절한 품질로 설정하는 작업을 병행해야 최적화 작업이 수월하다.Material(머티리얼)3D 모델에 텍스처를 적용하려면 3D 모델과 텍스처 사이에 반드시 Metarial이 필요하다.머티리얼은 3D 모델에 적용할 텍스처의 다양한 속성을 설정하는 역할을 한다.즉, “어떤 텍스처를, 어떤 간격으로 반복하고, 표면의 재질은 어떻게 표현하느냐” 등의 속성을 설정한다.머티리얼의 자동 적용※ 객체에 텍스처를 적용하는 방법은 두 가지가 있다.1.드래그 &amp; 드랍 적용 시 자동으로 “Matarials” 폴더 생성 텍스처와 머티리얼이 여러 폴더에 산재 텍스처가 어떤 절차를 걸쳐서 메시에 연결되는지 명확히 알아야하므로 초보자에겐 권장하지 않음머티리얼 생성2.텍스처 슬롯 바로 옆에 있는 브라우저 버튼을 클릭해 직접 선택 “Matarials” 폴더를 만들고, 아래의 절차대로 머티리얼을 생성한다. 머티리얼의 작명 방법은 개발자들마다 다른데, “m”, “mt”와 같은 Prefix나 Postfix를 붙이기도 한다.Albedo, Normal Map 적용드래그 &amp; 드랍 또는 브라우저 버튼을 클릭하여 Albedo와 Normal Map에 연결해준다.브라우저 버튼 왼쪽 네모 칸을 Ctrl+Click 하면 프리뷰를 볼 수 있다.머티리얼 적용 방법※ 완성된 머티리얼을 적용하는 방법 또한 두 가지가 있다. 하이러키의 객체나, 씬 뷰에 배치된 객체에게 오브젝트 뷰에서 드래그 &amp; 드랍 적용할 객체를 선택한 후 인스펙터에서 Matarials 속성에 드래그 &amp; 드랍TIP - Mesh Filter, Mesh Renderer Component애니메이션이 적용되지 않은 3D 모델은 반드시 메쉬 필터와 메쉬 렌더러 컴포넌트가 있다.Mesh Filter 해당 모델의 3차원 형상 정보인 메시 데이터를 가지고 있다.Mesh Renderer Mesh Filter의 메시 데이터를 기반으로 화면에 렌더링을 처리한다.또한 유니티에서 제공하는 “~ Renderer” 계열의 컴포넌트는 반드시 Materials 속성이 있다.이는 텍스처 정보를 가진 머티리얼을 연결하는 속성임을 의미한다.타일링 속성머티리얼의 기능 가운데 텍스처를 욕실의 타일처럼 반복시키는 기능이 있다.인스펙터 뷰에 Tiling 속성의 X, Y값의 n당 n번 패턴 반복화 한다는 것이다.TIP - Main Maps, Secondary MapsSecondary Maps 섹션의 속성값을 변경 했다가 변화가 없다고 혼동하지 않도록 유의.Secondary Maps 섹션은 3D 모델의 특정 부분을 좀 더 세밀하게 표현하기 위한 텍스처를 적용하는 영역이다.프리뷰의 다양한 기능 확대, 최소화 가능 구체 뿐만 아니라 다양한 물체로 적용된 모습을 볼 수 있다. 광원의 유/무에 따른 모습 3점(케밥 메뉴)에선 별도의 윈도우 창으로 분리해 볼 수 있다.Shader(셰이더) 및 PBS(물리 기반 셰이딩)셰이더는 렌더링할 때 픽셀의 농담, 색조, 명암을 결정하는 프로그래밍 방식을 말한다.쉽게 표현하면, 화면에 텍스처를 표현할 때 재질감 또는 효과를 표현하는 기능이다.셰이더 프로그래밍은 DirectX, OpenGL에 따라 서로 다른 언어로 구현되고 3D 그래픽스의 이론적인 배경을 많이 알아야 할 정도로 깊이 있는 지식을 요구하는 분야이다.유니티는 셰이더 프로그래밍 지식이나 경험이 없더라도 내장 셰이더(Built in Shader)를 제공해줘 손쉽게 사용할 수 있다.2017년 부터 공개된 물리 기반 셰이딩(PBS, Physically-Based Shading)은 물체가 가진 고유의 특성에 맞게 재질을 표현하는 것으로, 현실세계에 존재하는 돌, 나무, 유리, 플라스틱, 금속 등과 같은 재질감을 하난의 셰이더에서 표현할 수 있게 설계돼 있다. Metallic Value Charts Specular Value Charts 유니티의 Standard Shader의 몇 가지 중요한 Matarial Parameters는 다음과 같다.렌더링 모드 Rendering Mode 옵션 설명 Opaque(불투명) 기본값으로 불투명한 텍스처를 표현하는 옵션이다. 투명한 부분이 전혀 없는 Solid 객체에 적합하다. Cutout(그물망 표현) 불투명한 부분과 투명한 부분을 동시에 표현하는 옵션이다. 주로 풀, 그물망 등을 표현할 떄 적합하다. Fade(홀로그램 효과) 투명 속성값을 가진 객체를 페이드 아웃시키는 옵션으로, 페이드 인/아웃을 애니메이션 처리할 수 있다. 불투명한 객체를 부분적으로 페이드 아웃시킬 수 있어 홀로그램 효과를 구현할 수 있다. Transparent(투명) 투명한 플라스틱 또는 유리와 같은 재질을 표현하는 옵션이다. Albedo(알베도)Albedo는 빛을 반사하는 정도를 말하며, 반사율이라고도 한다.일반적으로 가장 기본이 되는 텍스처를 연결하는 속성이다.Metallic(메탈릭)Metallic은 객체 표면에 금속의 재질을 표현하기 위한 텍스처다.슬라이드가 1에 가까워질수록 금속 재질에 가까워진다.Normal Map(노멀 맵)Normal Map은 표면의 세밀한 입체감이나 질감을 표현하기 위한 텍스처의 일종으로 3D 모델링으로 많은 Polygon을 소모하지 않고 같은 효과를 낼 수 있다. 수치가 커질수록 거친 음영효과를 낸다.Height Map(하이트 맵)Height Map은 텍스처로 높낮이를 표현하는 것으로, 노멀 맵과 비슷한 기능을 하지만, 좀 더 돌출시켜 뒤에 있는 사물을 가리는 Occlusion 효과를 낼 수 있다. 슬라이더로 돌출되는 높이를 설정할 수 있다.Occlusion(오클루전)Occlusion은 흑백의 텍스처로 간접조명에 의해 생기는 명암을 더욱 뚜렷이 표시해 사물의 입체감과 깊이감을 살리는 데 사용한다. Occlusion에 사용할 텍스처는 일반적으로 3D 모델링 툴 또는 서드파티 툴에서 추출한다.Emission(이미션)Emission은 스스로 빛을 방출하는 속성을 말한다. 속성값을 변경하면 객체의 표면에서 방출되는 빛의 강도와 빛의 색상을 설정할 수 있는 항목이 나타난다. 또한 하단에 전역 조명에 반영하기 위한 옵션이 나타난다.Detail Mask(디테일 마스크)Detail Mask는 Secondary Maps에 적용할 마스크를 설정하는 텍스처 슬롯이다. 특정 부분만 좀 더 세부적인 텍스처를 표현할 때 사용한다.Info - Standard Shader 세부 정보유니티의 Standard Shader에 대한 세부 정보는 Unity Documents에서 볼 수 있다. Unity DocumentsPrefab(프리팹)Prefab의 사전적 의미는 조립식 주택 또는 미리 부품을 만들어 놓고 현장에서는 조립만 하는 건축 기법을 의미한다. 유니티에선 자주 사용하는 객체를 미리 부품처럼 만들어 놓고 재사용할 수 있게 하는 것이다.프리팹을 복제해서 만든 Clone 객체의 속성은 원본과 일치한다. 따라서 원본 프리팹을 수정하면 그 Clone에게도 수정 사항이 일괄적으로 적용되는 특성이 있다.100개의 Clone들을 일일이 수정해줄 필요 없이 원본만 수정하면 되는 강력한 기능이다.Nested Prefab, 중첩 프리팹Unity 2018.3 버전부터 지원하기 시작한 Nested Prefab 기능은 프리팹 하위에 다른 프리팹을 추가할 수 있는 기능이다. 프리팹 하위에 프리팹을 추가할 수 있기 때문에 개발 효율성을 높인다. OOP 개념의 상속이 가능하다. 다른 프리팹을 상속받아 다양한 기능을 추가할 수 있다. 프리팹 모드 기능으로 프리팹만 수정할 수 있는 별도의 인터페이스를 제공한다.벽 만들기Floor 객체의 네 군데 모서리에 배치할 벽을 프리팹으로 만들어 배치하자.머티리얼도 생성한다.TIP - 모바일 최적화 셰이더자동으로 설정되는 Standard 셰이더는 고품질을 내기 위한 셰이더이기에 모바일 플랫폼에서는 무겁다.따라서 좀 더 가벼운 “Bumped Diffuse”를 선택해 셰이더를 수정한다.아직까진 음영이나 표면의 흠집 같은 세밀함이 표현되지 않는다.Floor처럼 노멀 맵도 적용해보자.지금 이 셰이더에선 스페큘러 속성(빛을 반사하는 속성)이 표현되지 않기 때문에 금속 재질을 표현하지 못하는 것은 아쉬운 부분이다.Legacy Shader/Bumped Specular로 변경해서Main Color, Specular Color, Shininess 등의 속성을 수정해 재질감을 표현해보자.프리팹 생성하이러키 뷰에서 프로젝트 뷰로 드래그 &amp; 드롭하면 같은 이름으로 프리팹이 생성된다.만약 프리팹 원본이 삭제되어 인스턴스가 끊어진 경우 Clone 객체들은 붉은색 이름으로 바뀌는데, 이 땐 [Prefab] -&gt; [Unpack Completely]를 선택한다.프리팹의 복제 및 네이밍객체 복사는 복사할 객체를 지정하고 Ctrl + D를 누르면 넘버링이 붙으며 복제된다.TIP - 복제 네이밍 형식 변경네이밍 형식은 [Project Settings] -&gt; [Editor]의 “Numbering Scheme”의 “Game Object Naming”을 변경한다.Snapping(스내핑) 기능객체가 객체에 붙이기 쉽도록 표면 스내핑(Surface Snapping)과 정점 스내핑(Vertex Snapping) 기능을 제공한다.사용하려면 Move Tool(W)을 선택해야 한다. Vertex Snapping 메시의 꼭짓점과 꼭짓점을 붙이는 기능 먼저 객체간 거리를 벌려준다. 꼭짓점으로 커서를 옮긴 후 (V)키를 누른 상태로 드래그 &amp; 드롭으로 이동 후 객체간 스내핑이 완료되면 (V)키를 릴리스한다. 나머지 벽도 완료된 모습Light(조명)게임의 분위기와 완성도가 완전히 달라질 수도 있을 만큼 중요한 요소이다. 설치할수록 시각적인 효과는 커지지만, 조명을 처리하기 위한 렌더링 부하는 늘어날 수 밖에 없다. 따라서 최소한의 조명으로 시각적인 효과와 게임 수행 속도 사이의 균형을 맞추는 데 항상 신경 써야 한다.유니티는 게임의 속도를 저하하지 않고 실시간 조명의 효과를 낼 수 있는 라이트매핑 및 라이트 프로브 기능을 제공한다. 그 내용은 본문 11장에 있다.유니티가 제공하는 조명은 크게 네 가지가 있다.Directional Light 전체 화면에 균일한 빛을 비춘다. (태양과 같은 조명) 위치는 어디에 있든 관계 없지만(보통 y는 100) 빛을 비추는 각도에 따라 그림자의 방향과 길이가 달라진다. 실시간 조명 중에서 가장 비용이 적게 드는 조명이다.Point Light 일반 전구와 같은 성격(위치한 좌표 기준 360˚) 전역 조명이 아니므로 Range 속성으로 범위 조절Spot Light Corn 모양의 조명(손전등) 실시간 처리 비용이 가장 비싸다. 빛이 뻗어 나가는 각도를 조절할 수 있는 Spot Angle 속성이 있다.Area Light 사각형, 원 형태의 조명으로, 한쪽 면에서 빛을 발하는 조명 Lighting View에서 라이트맵을 Bake해야만 확인할 수 있다. 따라서 유일하게 실시간 조명이 아니다. 주로 간접 조명으로 이용실시간 라이트매핑 기능유니티는 백그라운드로 라이트맵을 베이킹할 수 있는 기능을 제공한다. 개발 중에 조명의 효과를 볼 수 있어 반복적인 작업에 매우 편리하다.Lighting Setting 에셋먼저 라이팅 뷰에서 해당 씬의 조명 속성을 저장하는 Lighting Settings 에셋을 생성해야 한다.보관은 Scene 폴더에서 하는 게 적절하다.Auto Generate 옵션라이팅 뷰의 아래에 있는 [Auto Generate] 옵션을 체크하면 실시간 라이트맵을 베이크한다.정식적인 내용은 11장에서…하늘 표현 방식게임에서 하늘을 표현하는 대표적인 방식으로는 Skybox와 SkyDome이 있다. Skybox 카메라가 볼 수 있는 하늘의 여섯 방면(left, front, right, back, top, bottom)의 이미지를 Cube 형태로 배치해 표현한다. Skydome 돔 형태이 메시에 하늘의 이미지 텍스처를 입혀 구현한다. 6 sided skybox(6방면 스카이박스)먼저 머티리얼을 생성하고, 셰이더의 콤보 박스에서 [Skybox] -&gt; [6sided]를 선택한다. 이후에 준비한 텍스처들을 연결한다.스카이박스 적용완성된 Skybox 머티리얼을 라이팅 뷰의 Environment 탭에서 Skybox Material 속성에 드래그 &amp; 드랍한다. 또는 단순히 씬 뷰의 빈 공간에 드래그 &amp; 드랍해도 된다.Procedural Skybox(프로시저럴 스카이박스) 텍스처를 적용하지 않고 하늘의 색상, 대기 농도, 노출(밝기), 태양의 위치와 크기 등을 설정 가능 유니티 프로젝트를 처음 열었을 때 이 스카이박스가 적용되어 있다. Default-Skybox는 여러가지 설정값을 변경할 수 없으므로 별도의 머티리얼로 만들어야 함머티리얼 적용 방법은 아까와 같이 셰이더 콤보 박스에서 [Procedural]을 선택한다.아래의 표는 프로시저럴 스카이박스의 속성별 기능이다. 속성 설명 Sun None : 태양 이미지를 표시하지 않음Simple : 태양 주변에 헤일로(Halo) 처리를 하지 않음High Quality : 태양 주변에 헤일로 처리 Sun Size 태양 이미지 크기 조절 Sun Size Convergence 태양 주변의 퍼지는 빛의 범위를 조절 (High Quality일 때만 표시됨) Almosphere Thickness 대기 농도 : 청명하거나 탁한 정도를 조절 Sky Tint 하늘 색상 조절 Ground 대지 색상 조절 Exposure 노출 조절 태양 위치를 변경하는 부분은 라이팅 뷰의 Environment 탭에서 Sun Source 속성에 기본 생성된 Directional light의 위치와 각도를 변경하면 된다.Cubemap Skybox(큐브맵 스카이박스)이 방식은 먼저 큐브맵을 생성한 후 하늘을 표현한다. 큐브맵은 6 sided skybox와 마찬가지로 6장의 텍스처가 필요하며 주변 환경을 반사하는 효과에 주로 사용한다.이 스카이박스를 적용하려면 여섯 방면의 이미지가 한 장의 텍스처에 있어야 하며, Texture Type을 Cubemap으로 설정해야 한다.다만 한 장의 텍스처에 여섯 방면의 이미지를 합칠 때는 다음과 같은 세 가지 방식으로 작업해야 한다. 매핑 타입 이미지 형태 6 Frame Layout(Cube Environment) 여섯 방면의 이미지를 평면으로 배치 Latitude-Longitude(Cylindrical) 파노라마 이미지로 실린더 형태의 이미지 Mirrored Ball(Spheremap) 구체(Sphere) 이미지 TIP - 큐브맵 정보큐브맵 생성에 관한 자세한 내용은 다음 페이지를 참조한다. Unity DocumentsInfo - 여섯 방면 스카이박스의 DrawCall(드로우콜) 소모량6 sided skybox는 6개의 텍스처를 사용하므로 기본적으로 6 드로우콜을 소모하지만, 큐브맵 스카이박스와 프로시저럴 스카이박스는 1 드로우콜만 소모하므로 좋은 대안이 될 수 있다. 또한 Sky Dome 역시 1장의 텍스처를 사용할 경우 1 드로우콜만 소모하므로 드로우콜을 낮출 수 있다는 장점이 있다.하지만 게임의 특성에 따라 카메라가 볼 수 있는 최대거리(Far clipping Plane)를 제한해야 할 때는 Sky Dome 방식을 적용하는 것은 적합하지 않을 수 있다.정리 스테이지 디자인 스카이박스 적용이번 장에서는 게임의 무대가 되는 스테이지를 제작했다.※ 04장 : 주인공 캐릭터 제작3D 모델 불러오기3D 모델을 씬 뷰 또는 하이러키 뷰로 드래그 &amp; 드랍하여 배치Transfrom의 Position값이 원점(0, 0, 0)인지 확인할 것유니티 엔진의 개발 방식유니티는 2가지 개발 방식을 지원한다. 컴포넌트 기반의 개발(CBD, Component Based Development) 데이터 기반의 개발(DOTS, Data Oriented Technology Stack) 멀티스레드 기반 초보자가 접하기에는 어렵다. 개발 중인 기능이 많아 안정화 버전이 나올 때까지는 상용으로 사용하기에 위험부담이 크다. 컴포넌트 기반의 개발 방식CBD 방식은 일종의 소프트웨어 개발 방법론으로, 독립적인 기능 단위로 컴포넌트를 제작한 다음 필요한 기능을 조립하는 방식을 말한다.이 개발 방식의 장점은 컴포넌트의 재사용이 가능하고 높은 생산성이다.컴포넌트는 인스펙터 뷰에서 확인할 수 있다.그 중에서 어느 객체라도 Transform 컴포넌트는 유일하게 삭제할 수 없다.트랜스폼 컨포넌트는 해당 게임오브젝트의 3차원 위치, 각 축에 대한 각도 및 스케일 속성을 가진다. 따라서 3차원 공간에서 어떤 객체가 존재하려면 이러한 정보가 반드시 있어야 하므로 삭제할 수 없는 컴포넌트이다.C# 스크립트유니티의 엔진의 코어 부분은 C++로 제작됐고 초기 버전에서는 자바스크립트 문법을 차용한 UnityScript를 지원했지만, 2017년 부터 C# 언어만 지원한다.C#은 C++, 자바 언어의 장점을 차용한 Managed Language(메모리 자동 연산 언어)로써 국내외를 막론하고 많이 사용되는 인기 있는 언어이다.고급 문법은 이 책에선 다루지 않는 거 같다.스크립트 코드 에디터나는 주로 Visual Studio 2022를 개발 도구로 사용한다.블로그 포스팅은 마크다운 프리뷰어 익스텐션을 사용하기 위해 VSCode를 사용한다.추천하는 코드 에디터VS20xx, VSCode, JetBrains Rider 등을 유니티 개발에 추천하고 있다.코드 에디터 변경Preferences의 [External Tools] 섹션의 External Script Editor에서 서드파티 에디터를 선택한다.만약 VSCode를 스크립트 에디터로 사용한다면 코드 자동완성 기능을 사용하기 위해 C# 확장 패키지를 설치해야 한다. 바로가기C# 스크립트 생성프로젝트 뷰 우클릭 [Create] -&gt; [C# Script] 선택스크립트 네임은 클래스명이 된다.프로젝트 뷰의 스크립트 파일 이름을 변경하면 클래스명은 수동으로 변경해주어야 컴파일 에러가 나지 않는다.유니티의 주요 이벤트 함수(P.122)유니티의 생명주기(Life Cycle)에 대한 내용은 본 블로그의 다른 게시물에 정리되어 있다. 바로가기이벤트 함수의 호출 순서 private void Awake() { // 주로 게임의 상태 값, 변수의 초기화에 사용 // 가장 처음 1회 실행 // 스크립트가 비활성화돼 있어도 실행된다. // Coroutine으로 실행 불가능 } private void Start() { // Awake() -&gt; OnEnable() -&gt; Start() // Update함수 호출 전에 호출 // Coroutine으로 실행 가능 } private void Update() { // 프레임마다 호출 // 호출 간격이 불규칙적임 // 화면의 렌더링 주기와 일치 // 주로 게임의 핵심 로직을 작성 } private void LateUpdate() { // Update 함수가 종료된 후 호출 // 모든 Update()가 호출되고 나서 한 번씩 호출 // 주로 Update()에서 전처리가 끝난 후 실행해야 하는 로직에 사용 } private void FixedUpdate() { // 일정한 간격으로 호출(Default 0.02/s) // 물리 엔진의 계산 주기와 일치 } private void OnEnable() { // 게임 오브젝트 또는 스크립트가 Enable될 때마다 호출 // 주로 사용자 정의 이벤트 연결에 사용 // Coroutine으로 실행 불가능 } private void OnDisable() { // 게임 오브젝트 또는 스크립트가 Disable될 때 호출 // 주로 이벤트 연결을 종료할 때 사용 // Coroutine으로 실행 불가능 }키보드 입력값 받아들이기유니티에서 제공하는 Input Class는 외부(키보드, 마우스, 조이패드 등)에서 들어오는 입력값을 관리하는 클래스다. InputSystem의 내용은 14장에서 따로 다룬다.InputManager키본적으로 정의되어 있는 내용도 있고, 추가도 가능하다.GetAxis()미리 설정한 키 조합의 반환값 가져오는 함수. private void Update() { float h = Input.GetAxis(\"Horizontal\"); // -1.0f ~ 0.0f ~ +1.0f float v = Input.GetAxis(\"Vertical\"); // -1.0f ~ 0.0f ~ +1.0f Debug.Log(\"h : \" + h); Debug.Log(\"v : \" + v); }스크립트 적용 방식 Scene View에 적용할 객체에게 스크립트를 드래그 &amp; 드랍 하이러키 뷰의 적용할 객체에게 스크립트를 드래그 &amp; 드랍 적용할 객체의 인스펙터 뷰에 스크립트를 드래그 &amp; 드랍(권장) 적용할 객체의 인스펙터 뷰에서 Add Component로 스크립트 검색TIP - 잘못 추가된 에셋을 찾는 방법스크립트 뿐만 아니라 모든 에셋(머티리얼, 프리팹, 리소스 등)도 이와 같은 방법으로 조회 가능하다.Info - Input에 정의되지 않은 축 이름을 사용했을 때 발생하는 오류스크립트에서 InputManager에 정의된 키 값의 이름을 문자열로 받게 되면 컴파일 에러가 발생하지 않는다.따라서 이와 같은 에러가 발생하면 대/소문자, 띄어쓰기 등을 확인할 것.GetAxisRaw()Input.GetAxis(“Horizontal”)는 -1.0f ~ +1.0f 사이의 연속적인 값을 반환한다. 따라서 부드러운 이동이 필요할 때는 GetAxis()를 사용한다. 하지만 키보드 입력값에 따라 방향을 즉시 바꾸거나 속도를 변경해야할 땐Input.GetAxisRaw(“Horizontal”)를 사용해야 한다. GetAxisRaw는 불연속적인(이산, Discrete) -1.0f, 0.0f, +1.0f의 세 가지 값만 변환한다.캐릭터의 이동유니티에서 어떤 물체를 이동시키거나 회전시키는 방법은 2가지로 분류할 수 있다. 모든 게임오브젝트에 있는 Transform Component의 Position, Rotation 속성값을 변경하는 것 유니티 엔진에 내장된 물리 엔진을 이용해 물리적인 힘(Force) 또는 회전력(Torque)를 가해 변경시키는 것쉽게 말해 Tranform Component를 이용 물리 엔진(PhysX, Box2D)을 사용애니메이션으로도 이동 및 회전을 할 수 있다. 하지만 이것 역시 Transform Component의 속성값을 연속적으로 기록한 것을 재생하는 것이기 때문에 Transform Component를 이용하는 방법이다.아래의 코드는 Player - ‘이동 로직 추가’이다.using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerCtrl : MonoBehaviour{ private void Update() { float h = Input.GetAxis(\"Horizontal\"); // -1.0f ~ 0.0f ~ +1.0f float v = Input.GetAxis(\"Vertical\"); // -1.0f ~ 0.0f ~ +1.0f // Transform Component Position 속성값 변경 transform.position += new Vector3(0, 0, 1); }}누적 대입 연산자로 인해 프레임마다 z축만 +1되는 코드이다.Vector3 구조체유니티에서 3차원 좌표에 대한 개념을 익히려면 Vector3 구조체에 대해 알아야 한다. 이는 3차원 벡터와 좌푯값을 저장하기 위한 용도로 사용되며, 다음 코드는 Vector3 구조체의 일부분이다. 3차원 x, y, z 값이 float로 선언된 것과 방향을 지시하는 약칭(Shorthand)를 볼 수 있다.public struct Vector3 : IEquatable&lt;Vector3&gt;, IFormattable { public const float kEpsilon = 1E-05f; public const float kEpsilonNormalSqrt = 1E-15f; // // 요약: // X component of the vector. public float x; // // 요약: // Y component of the vector. public float y; // // 요약: // Z component of the vector. public float z; private static readonly Vector3 zeroVector = new Vector3(0f, 0f, 0f); private static readonly Vector3 oneVector = new Vector3(1f, 1f, 1f); private static readonly Vector3 upVector = new Vector3(0f, 1f, 0f); private static readonly Vector3 downVector = new Vector3(0f, -1f, 0f); private static readonly Vector3 leftVector = new Vector3(-1f, 0f, 0f); private static readonly Vector3 rightVector = new Vector3(1f, 0f, 0f); private static readonly Vector3 forwardVector = new Vector3(0f, 0f, 1f); private static readonly Vector3 backVector = new Vector3(0f, 0f, -1f); [중략...]다음 표에 제시된 것은 Vector3 구조체의 여러 속성 중에서 자주 사용되는 속성이다. 속성 설명 magnitude 벡터의 길이(read only) normalized 크기가 1인 벡터, 정규화 벡터(read only) sqrMagnitude 벡터의 길이의 제곱(read only) x 벡터의 x 성분(3차원 공간의 x 좌표 y 벡터의 y 성분(3차원 공간의 y 좌표 z 벡터의 z 성분(3차원 공간의 z 좌표 Normalized Vector(정규화 벡터)Vector는 크기와 방향을 나타낼 수 있는 데이터 타입으로, 그 중 각 축의 크기가 1인 벡터를 정규화 벡터(Normalized Vector)라 한다. 즉, 방향만 표시하는 벡터라고 생각하면 된다.Vector3 구조체에서 제공하는 방향을 가리키는 정규화 벡터는 다음과 같다. Shorthand 의미 Vector3.forward Vector3(0, 0, 1) Vector3.back Vector3(0, 0, -1) Vector3.left Vector3(-1, 0, 0) Vector3.right Vector3(1, 0, 0) Vector3.up Vector3(0, 1, 0) Vector3.down Vector3(0, -1, 0) Vector3.one Vector3(1, 1, 1) Vector3.zero Vector3(0, 0, 0) 유니티는 왼손 좌표계를 사용한다.따라서 Vector3.forward가 z축 +1이라는 것을 이해할 수 있다. private void Update() { float h = Input.GetAxis(\"Horizontal\"); // -1.0f ~ 0.0f ~ +1.0f float v = Input.GetAxis(\"Vertical\"); // -1.0f ~ 0.0f ~ +1.0f // 정규화 벡터를 사용한 코드 transform.position += /*전진 방향*/Vector3.forward * /*속력*/1; }컴포넌트 캐시 처리Update()의 사용엔 항상 최적화에 주의를 기울여야 한다. 조금이라도 부하가 걸리는 함수나 잘못된 로직은 피해야 한다. 특히 프레임마다 Transform Component에 접근하는 이동 방식은 바람직하지 않다.앞서 Update()내에서 Transform Component의 멤버 변수 transform을 사용했는데, 이를 미리 변수에 담아 두고 해당 변수에 접근하는 방식이 미세하지만 빠르다. 따라서 컴포넌트의 캐시 처리란 스크립트에서 접근해야 할 컴포넌트를 Awake()나 Start()에서 미리 변수에 할당한 후에 그 변수를 통해 접근하는 것을 말한다.public class PlayerCtrl : MonoBehaviour{ Transform tr; private void Start() { // Transform Component를 추출해 변수에 대입 tr = GetComponent&lt;Transform&gt;(); } [중략...]}Info - GetComponent 함수의 사용법tr = GetComponent&lt;Transform&gt;();tr = GetComponent(\"Transform\") as Transform;tr = (Transform)GetComponent(typeof(Transform));위에 열거한 방법은 모두 같은 의미이다.또, Start()에서 tr 변수에 할당하는 구문은 아래 코드를 축약한 것이다.C#에서 this는 해당 클래스(스크립트)를 뜻함.tr = this.gameobject.GetComponent&lt;Transform&gt;();\"이 스크립트가 포함된 게임 오브젝트가 가진 여러 컴포넌트 중에서 Transform 컴포넌트를 추출해 tr 변수에 저장한다.\"Translate()이 함수는 게임 오브젝트의 이동 처리를 편하게 할 수 있는 함수로서, 함수의 원형은 다음과 같다.void Translate(Vector3 direction, [Space relativeTo])이 함수로 Transform Component의 Position 속성값을 계산해 이동하는 복잡한 방식의 코딩을 예방할 수 있다.Translate()의 두 번째 인자는 기준 좌표계인데, 인자를 생략하면 로컬 좌표를 기준으로 한다. Space.World(월드 좌표계) Space.Self(로컬 좌표계)이 함수를 이용해 수정한 PlayerCtrl 스크립트는 다음과 같다.using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerCtrl : MonoBehaviour{ // 컴포넌트 캐시 처리할 변수 Transform tr; private void Start() { // Transform Component를 추출해 변수에 대입 tr = GetComponent&lt;Transform&gt;(); } private void Update() { float h = Input.GetAxis(\"Horizontal\"); // -1.0f ~ 0.0f ~ +1.0f float v = Input.GetAxis(\"Vertical\"); // -1.0f ~ 0.0f ~ +1.0f // Translate()를 이용한 이동 로직 tr.Translate(Vector3.forward * 1); }}Time.dletaTimeTime.dletaTime은 이전 프레임의 시작 시각부터 현재 프레임이 시작되는 시간의 차(델타)를 말한다. 쉽게 풀이하면 이전 프레임부터 현재 프레임까지 걸린 시간의 차다.Update()는 프레임에 따라 호출 되는데, 이 횟수가 기기의 성능마다 다르므로 속도가 달라지는 문제가 발생한다. 이 문제는 Time.dletaTime을 곱해주는 것으로 해결할 수 있다.30프레임은 1/30초, 60프레임은 1/60초를 해주어 프레임 레이트가 서로 다른 기기에서도 개발자가 정한 일정한 속도로 이동시킬 수 있다.tr.Translate(Vector3.forward * Time.deltaTime * 1); Time.deltaTime을 곱하지 않으면 -&gt; 프레임당 지정한 유닛만큼 이동 Time.deltaTime을 곱하면 -&gt; 초당 지정한 유닛만큼 이동특히 Update()에 이동 및 회전 로직을 작성했다면 반드시 Time.deltaTime 속성을 사용해야 한다.using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerCtrl : MonoBehaviour{ // 컴포넌트 캐시 처리할 변수 Transform tr; public float moveSpeed = 10.0f; private void Start() { // Transform Component를 추출해 변수에 대입 tr = GetComponent&lt;Transform&gt;(); } private void Update() { float h = Input.GetAxis(\"Horizontal\"); // -1.0f ~ 0.0f ~ +1.0f float v = Input.GetAxis(\"Vertical\"); // -1.0f ~ 0.0f ~ +1.0f // Translate()를 이용한 이동 로직 tr.Translate(v * Vector3.forward * moveSpeed * Time.deltaTime); // tr.Translate({전진/후진 변수} * {이동할 방향} * {속도} * Time.deltaTime); }}public, private 접근 제한자C#에서 지원하는 접근 제한자는 public, private, protected, internal이 있다. 접근 제한자는 외부 클래스(구조체), 멤버 변수 등의 접근을 허용하는 범위를 지정한다. 접근 제한자 설명 public 외부 클래스(외부 스크립트)에서 접근 가능 private 동일 클래스(스크립트 內)에서만 접근 가능. 외부에서는 불가능 protected private과 동일하게 외부에선 접근이 불가능하고, 상속받은 파생 클래스에서만 접근 가능 internal 같은 어셈블리에서만 접근 가능. 클래스의 경우 접근 제한자를 생략하면 internal이 기본값으로 설정됨 유니티에서 public으로 선언한 변수는 인스펙터 뷰의 프로퍼티로 노출돼 값을 직접 수정할 수 있다. 반대로 private 접근 제한자로 설정된 변수는 노출되지 않는다.인스펙터 뷰에 노출된 변수의 우선순위public으로 접근되는 변수의 변경은 인스펙터 뷰가 우선이다. 즉, 스크립트에선 10의 속도를 주었는데, 인스펙터 뷰에선 20으로 변경했을 때 게임에 적용되는 속도는 20으로 지정되어 있다.private 변수의 인스펙터 뷰 노출인스펙터 뷰의 모드를 디버그 모드로 설정하면 private 변숫값도 확인할 수 있다.또 다른 방법은 SerializeField 속성(Attribute)을 사용하는 것이다. 이 방법은 디버그 모드가 아니여도 private 접근 지시자의 속성을 유지한 채 인스펙터 뷰에 노출하는 기능이다.[SerializeField] Transform tr;벡터의 덧셈 연산이제 플레이어의 좌우 이동을 구현하기 위해 Vector3.right의 +, -값을 곱한다. private void Update() { float h = Input.GetAxis(\"Horizontal\"); // -1.0f ~ 0.0f ~ +1.0f float v = Input.GetAxis(\"Vertical\"); // -1.0f ~ 0.0f ~ +1.0f // 전후좌우 이동 방향 벡터 계산 Vector3 moveDir = (Vector3.forward * v) + (Vector3.right * h); // Translate(이동 방향 * 속력 * Time.deltaTime) 이동 로직 tr.Translate(moveDir * moveSpeed * Time.deltaTime); }플레이했을 때 대각선 이동은 빠른 감이 있었다. moveDir 변수는 Vector3 타입으로, 키보드 입력값을 이용해 벡터 연산을 했다. 전진 방향의 벡터와 좌우 방향의 벡터를 덧셈 연산하면 대각선 방향의 벡터가 생성된다. 이 대각선 벡터의 길이는 피타고라스의 정리ˇ에 의해 루트2(약 1.414・・・)임을 알 수 있다. 피타고라스의 정리대각선으로 이동할 때 속도가 빨라진 원인이다. 따라서 길이가 1인 벡터로 변환해 방향 성분만 사용해야 한다. 이처럼 길이가 1인 벡터를 ‘단위 벡터’ 또는 ‘정규화 벡터(Normalized Vector)’라고 앞서 언급했다.벡터의 방향 성분만 추출하기 위해 정규화 벡터로 변경하려면 Vector3.normalized 속성을 이용해 정규화 벡터값을 사용한다. 즉, Vector3 타입으로 선언한 moveDir 변수는 vormalized 속성을 이용할 수 있다.using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerCtrl : MonoBehaviour{ Transform tr; // 컴포넌트 캐시 처리할 변수 public float moveSpeed = 8.0f; private void Start() { tr = GetComponent&lt;Transform&gt;(); // Transform Component를 추출해 변수에 대입 } private void Update() { float h = Input.GetAxis(\"Horizontal\"); // -1.0f ~ 0.0f ~ +1.0f float v = Input.GetAxis(\"Vertical\"); // -1.0f ~ 0.0f ~ +1.0f Vector3 moveDir = (Vector3.forward * v) + (Vector3.right * h); // 전후좌우 이동 방향 벡터 계산 tr.Translate(moveDir.normalized * moveSpeed * Time.deltaTime); // Translate(이동 방향 * 속력 * Time.deltaTime) 이동 로직 }}Info - 벡터의 크기와 정규화벡터의 크기(magnitude)는 Vector3.magnitude 함수를 이용해 가져올 수 있다. private void Start() { float vec1 = Vector3.Magnitude(Vector3.forward); float vec2 = Vector3.Magnitude(Vector3.forward + Vector3.right); float vec3 = Vector3.Magnitude((Vector3.forward + Vector3.right).normalized); Debug.Log(\"vec1 : \" + vec1); Debug.Log(\"vec2 : \" + vec2); Debug.Log(\"vec3 : \" + vec3); }캐릭터 회전 - Rotate게임 오브젝트를 회전할 때는 Transform.rotation 속성값을 변경하거나 Rotate 계열의 함수를 사용할 수 있다. 가장 기초적인 Rotate()는 다음과 같은 다양한 인자를 사용할 수 있다.- void Rotate(new Vector3 eulerAngles, [Space relativeTo]);- void Rotate(float xAngle, float yAngle, float zAngle, [Space relativeTo]);- void Rotate(Vector3 axis, float angle, [Space relativeTo]);다음 코드는 Update()에서 Rotate()의 인자에 Y축에 Time.deltaTime을 곱해서 시계방향으로 회전하는 것을 볼 수 있다. Rotate()의 인자는 모두 다르지만 전부 같은 의미이다.void Update(){ transform.Rotate(Vector3.up * Time.deltaTime); transform.Rotate(0, Time.deltaTime, 0); transform.Rotate(Vector3.up, Time.deltaTime);}PlayerCtrl.csusing System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerCtrl : MonoBehaviour{ Transform tr; // 컴포넌트 캐시 처리할 변수 public float moveSpeed = 8.0f; public float turnSpeed = 80.0f; private void Start() { tr = GetComponent&lt;Transform&gt;(); // Transform Component를 추출해 변수에 대입 } private void Update() { float h = Input.GetAxis(\"Horizontal\"); float v = Input.GetAxis(\"Vertical\"); float r = Input.GetAxis(\"Mouse X\"); Vector3 moveDir = (Vector3.forward * v) + (Vector3.right * h); // 전후좌우 이동 방향 벡터 계산 tr.Translate(moveDir.normalized * moveSpeed * Time.deltaTime); // Translate(이동 방향 * 속력 * Time.deltaTime) 이동 로직 tr.Rotate(r * Vector3.up * turnSpeed * Time.deltaTime); // Vector3.up 축을 기준으로 turnSpeed만큼의 속도로 회전 }}씬 뷰에서 가상 카메라의 이동씬 뷰의 가상 카메라가 오브젝트를 추적하게 하려면 하이러키 뷰에서 추적할 객체를 선택 Shift + F 또는 [Edit] -&gt; [Lock View to Selected] 플레이Animation유니티는 Legacy Animation과 Mecanim Animation이라는 두 가지 유형의 애니메이션을 지원한다. 레거시 애니메이션 : 하위 호환성을 고려한 애니메이션, 소스 코드로 컨트롤해야 함 메카님 애니메이션 : 모션 캡처 애니메이션, 리타게팅ˇ 기능주인공 캐릭터는 레거시 애니메이션 타입으로 구현하고, 적 캐릭터는 메카님 애니메이션을 적용해보자. 리타게팅(Retagetting) : 애니메이션을 재사용하는 기능을 말한다. 6장에서 자세히 소개 Animation Type 옵션 설명 none 애니메이션을 사용하지 않는다. Legacy 하위 호환성을 유지하기 위한 이전 방식의 애니메이션 Generic 메카님 애니메이션. 인체형 모델이 아닌 3D 모델에 적용. 리타게팅 불가 Humanoid 메카님 애니메이션. 사람과 같이 2족 보행하는 모델에 적용. 리타게팅 가능 Player는 레거시 애니메이션을 사용하기로 했으니 Legacy로 변경해준다.Info - 메카님 애니메이션 권장레거시 애니메이션은 하위 호환성을 고려한 유형이기 때문에 유니티사는 특별한 경우가 아니면 메카님 애니메이션을 사용하길 권장함. 하짐나 빠른 속도와 간단한 애니메이션을 동작하는 데는 아직도 레거시 애니메이션이 유용하게 사용되고 있다. 또한, 개발자 포럼에서 레거시 애니메이션은 곧 지원 중단될 것으로 예측하는 개발자들이 있지만, 당분간은 계속 지원할 것으로 예상한다.하이러키 뷰에 배치되어 있는 Player 객체의 인스펙터 뷰를 보면 Animation 컴포넌트가 추가돼 있다. 이 모델은 레거시 타입으로 설정된 모델을 의미한다.애니메이션 처리가 된 3D 모델을 씬 뷰에 추가했을 때 Animation Type에 따라 다음과 같이 서로 다른 컴포넌트가 자동으로 추가된다. 레거시 애니메이션 : Animation Component 메카님 애니메이션 : Animator Component둘 다 애니메이션과 관련된 컴포넌트지만, 작동 방식이 전혀 다르다. 따라서 3D 모델에 추가된 컴포넌트의 종류를 보고 해당 모델의 애니메이션 유형이 무엇으로 설정됐는지 구별할 수 있어야 한다.Animation Clip애니메이션 클립 : 캐릭터의 걷기, 달리기, 점프, 총 쏘기와 같은 동작을 기록한 파일을 말한다. 그리고 애니메이션 컴포넌트는 애니메이션 클립에 기록된 관절의 위치와 회전 값을 프레임 단위로 재생시키는 역할을 한다.3D 모델링 툴에서 제작한 애니메이션 클립을 애니메이션 파일로 만드는 방법에는 세 가지 방식이 있다. 모든 애니메이션 클립이 하나의 애니메이션 파일에 들어 있고, 각 애니메이션 클립이 시작 프레임과 종료 프레임을 가지는 방식 위와 동일하게 모든 애니메이션 클립이 하나의 애니메이션 파일에 들어가 있지만, 미리 분리된 경우 애니메이션 클립을 동작별로 분리해 별도의 파일로 생성하는 방식. 이 때 생성된 애니메이션 클립의 파일명은 “모델명@애니메이션 클립명” 형태의 명명 규칙이 적용된다. 애니메이션 클립의 수가 많거나 애니메이션의 수정 작업이 빈번하게 일어날 것으로 예상한다면 이 방식으로 작업하는 것을 추천애니메이션 적용 하이러키 뷰의 객체를 적용할 애니메이션 인스펙터 뷰 - 프리뷰에 드래그 &amp; 드랍 프로젝트 뷰의 원본 객체를 적용할 애니메이션 인스펙터 뷰 - 프리뷰에 드래그 &amp; 드랍애니메이션 클립의 Wrap Mode 속성값 중 ‘Loop’로 설정한다. Loop : 클립의 첫 프레임부터 마지막 프레임까지 계속 반복애니메이션 컴포넌트 속성값 Animation : 실행되면 처음 동작하는 애니메이션 클립을 연결 Animations[] : 해당 모델이 실행할 수 있는 클립들을 저장(즉, 여기 포함되어 있지 않은 클립은 실행 불가) Play Automatically : 게임이 실행되면 자동으로 클립을 재생함(언체크시 스크립팅으로 체크 가능) 이하 생략아래의 코드는 Play Automatically를 언체크하고 스크립트에서 직접 컨트롤 하는 코드이다.public class PlayerCtrl : MonoBehaviour{ // 컴포넌트 캐시 처리할 변수 Transform tr; Animation anim; [중략...] private void Start() { // Component를 추출해 변수에 대입 tr = GetComponent&lt;Transform&gt;(); anim = GetComponent&lt;Animation&gt;(); // 애니메이션 실행 anim.Play(\"Idle\"); } private void Update() { [중략...] }}이제 주인공 캐릭터를 이동시키면 이동 방향에 적합한 애니메이션을 생성되게 만들어보자.Animation Blending유니티는 현재 수행 중인 애니메이션에서 다른 애니메이션으로 변경될 때 이를 부드럽게 연결해주는 애니메이션 블렌딩 기능을 제공한다.주인공이 정지 상태일 때는 Idle 애니메이션을 실행하다가 전진하는 경우 자연스럽게 RunF 애니메이션으로 변경되게 해보자. private void Update() { [중략...] PlayerAnim(h, v); // 주인공 캐릭터의 애니메이션 설정 } void PlayerAnim(float h, float v) // 키보드 입력값을 기준으로 동작할 애니메이션 수행 { if (v &gt;= 0.1f) anim.CrossFade(\"RunF\", 0.25f); // 전진 애니메이션 실행 else if (v &lt;= -0.1f) anim.CrossFade(\"RunB\", 0.25f); // 후진 애니메이션 실행 else if (h &gt;= 0.1f) anim.CrossFade(\"RunR\", 0.25f); // 오른쪽 이동 애니메이션 실행 else if (h &lt;= -0.1f) anim.CrossFade(\"RunL\", 0.25f); // 왼쪽 이동 애니메이션 실행 else anim.CrossFade(\"Idle\", 0.25f); // 정지 시 대기 애니메이션 실행 }PlayerAnim()는 주인공 캐릭터에 적절한 애니메이션 클립을 재생시키는 역할을 한다. 주인공 캐릭터의 이동 방향을 판단하는 기준인 h와 v 변수를 인자로 넘겨준다. 주인공 캐릭터가 전후/좌우로 움직이는 것을 0을 기준으로 판단할 수 있기 때문이다. 그리고 키보드를 누르지 않아서 0 값이 전달되면 대기 상태인 Idle 애니메이션 클립을 실행한다.애니메이션 클립을 실행하는 CrossFade()는 두 개의 인자를 받는다. 첫 번째 인자는 변경할 애니메이션 클립의 명칭이며, 두 번째 인자는 다른 애니메이션 클립으로 페이드아웃되는 시간을 의미한다. 이 때 단순히 정해진 시간동안 애니메이션이 변경되는 것이 아니라 애니메이션 키프레임을 보간(Interpolate)해 부드럽게 보정시킨다.무기 장착무기류를 장착하려면 모델의 Bone 구조를 확인해야 한다.무기류를 장착해준다면 처음엔 무기 객체의 Transform 속성값을 리셋해준다.이후 플레이에서 애니메이션과 무기류의 싱크를 확인하고 부족하다면 Transform을 적절히 변경해준다.그림자게임에 있어서 입체감을 표현하기 위한 그림자 효과는 매우 중요한 요소다. 이어서 그림자를 표현하는 몇 가지 방법을 소개하고자 한다.실시간 그림자유니티는 Directional Light, Point Light, Spotlight라는 세 가지 광원에 대해 실시간 그림자(Real Time Shadow)를 지원한다. 하지만 모바일 디바이스의 성능에 따라 실시간 그림자는 처리 비용이 매우 크다.유니티는 실시간 그림자가 기본으로 적용돼 있으며 Directional Light 속성 중 Shadow Type 옵션으로 설정한다. Shadow Type 속성으로는 No Shadows, Soft Shadows, Hard Shadows로 세 가지 옵션이 있고 각각은 아래의 내용이다. No Shadows : 실시간 그림자를 적용하지 않는다.(기본 설정값) Soft Shadows : 실시간 그림자를 표현하지만, 외곽선에 계단 현상이 발생한다. Hard Shadows : 부드러운 실시간 그림자를 표현하지만, 가장 많은 부하를 준다.실시간 그림자의 시각적 효과는 매우 탁월하지만, 엔진에 많은 부하를 준다. 따라서 실시간 그림자 효과가 필요 없는 3D 모델은 실시간 그림자 영향에서 제외하는 설정을 빠뜨리지 않아야 한다.3D 모델은 Mesh Renderer 또는 Skinned Mesh Renderer 중 한 컴포넌트를 반드시 갖고 있다. 그리고 이 두 가지 컴포넌트에는 실시간 그림자와 관련된 Cast Shadows와 Receive Shadows 속성이 있다. Cast Shadows : 빛을 받아서 자신의 그림자를 만들 것인지 결정하는 속성|Cast Shadows|Option||—|—||Off|그림자를 만들지 않는다.||On|그림자를 만든다.||Two Sided|백 페이스 컬링을 무시하고 그림자를 양면으로 만든다.||Shadows Only|그림자를 만들지만, 자신은 렌더링하지 않는다. 즉, 화면에 보이지 않는 특성이 있어 그림자 처리만을 위한 로우 폴리 3D 모델에 활용할 수 있다.| Receive Shadows : 다른 그림자에 들어갔을 때 표면에 그림자의 영향을 받는지 아닌지따라서 실시간 그림자의 영향을 받지 않아도 시각적 효과에 크게 상관없는 3D 모델은 이 두가지 옵션을 적절히 설정해 그림자를 생성하지 않게 한다.Info = Cast Shadows 속성의 Two Sided 옵션에 대해Plane 또는 Quad처럼 단면(Single-Side)만 렌더링 하는 모델은 Cast Shadows 속성을 On으로 하고, 빛을 모델의 뒤쪽(Backface)에서 비추면 그림자가 생성되지 않는다.(두 번째 그림 참고). 이 때 Cast Shadows 속성을 Two Sided로 설정하면 그림자가 생성된다.(세 번째 그림 참고).메시를 이용한 그림자실시간 그림자보다 시각적인 효과는 덜 하지만, 그래도 입체감을 낼 수 있는 가벼운 그림자 처리를 구현할 수 있는 방법. 단순한 평면 메시를 이용하는 방법으로 모바일 게임에서 흔히 볼 수 있는 방식먼저 객체에 적용된 실시간 그림자가 생성되지 않도록 설정한다. + 무기류 Cast Shadows - Off Receive Shadows - 언체크다음 단계로 그림자를 표시할 메시는 유니티에서 제공하는 Quad를 사용한다. Quad 모델을 생성해 Player에게 자식화한다. 콜라이더 컴포넌트 삭제 이름 변경 준비한 Material 지정 Material Shader를 [Mobile] -&gt; [Particles] -&gt; [Multiply]로 변경이 방법은 부하가 적은 방법으로 많이 사용되고 있지만, 스테이지에 굴곡이 있거나 경사로가 있다면 그림자가 다른 메시에 묻혀 제대로 표현되지 않는다는 점도 기억하자.Level Of Detail 설정LOD, Level Of Detail란, 화면을 렌더링하는 카메라로부터 멀리 떨어질수록 낮은 폴리곤으로 변경해 렌더링 부하를 줄여주는 기법이다.주인공 모델의 3가지 메시는 3단계 LOD로 설정된 메시다.LOD Group ComponentLOD Group Component는 카메라와 피사체의 거리에 따라 렌더링할 메시를 결정하는 역할을 함LOD Group Component를 Add한다.LOD 구간대로 메시를 차례대로 드래그 &amp; 드롭한다. LOD 0구간은 하이 폴리곤이며 숫자가 커질수록 로우 폴리곤 메시를 연결한다.Culled(Red)는 카메라와의 거리가 아주 멀리 떨어져 화면에서 렌더링하지 않는 구간을 의미한다.주인공 캐릭터는 대부분 카메라와의 거리가 고정돼있기 때문에 굳이 LOD를 적용할 필요는 없지만, 멀티플레이어 게임에서는 상대편이 멀리 떨어져 있는 내 캐릭터를 봤을 때 LOD가 유용하게 사용될 수 있다. 특히 모바일 게임에서는 렌더링 최적화 기법 가운데 중요하게 꼽는 것 중 하나가 바로 LOD 기능이다.Follow Camera 로직using System.Collections;using System.Collections.Generic;using UnityEngine;public class FollowCam : MonoBehaviour{ // 따라가야 할 대상을 연결할 변수 public Transform targetTr; // Main Camera 자신의 Transform 컴포넌트 private Transform camTr; // 따라갈 대상으로부터 떨어질 거리 [Range(2.0f, 20.0f)] public float distance = 10.0f; // Y축으로 이동할 높이 [Range(0.0f, 10.0f)] public float height = 2.0f; void Start() { // Main Camera 자신의 Transform 컴포넌트를 추출 camTr = GetComponent&lt;Transform&gt;(); } void LateUpdate() { // 추적해야 할 대상의 뒤쪽으로 distance만큼 이동 // 높이를 height만큼 이동 Vector3 pos = targetTr.position + (-targetTr.forward * distance) + (Vector3.up * height); // Camera를 피벗 좌표를 향해 회전 camTr.LookAt(targetTr.position + (targetTr.up)); }}[Range(min, max)] 어트리뷰트를 사용하면 다음 라인에 선언한 변수의 입력 범위를 (min, max)로 제한할 수 있고, 인스펙터 뷰에 슬라이드 바를 표시한다.LateUpdate()에서 후처리 로직으로 이용한 이유는 Update()의 순서에 플레이어의 이동 로직이 항상 먼저 실행되는 것이 보장되지 않기 때문에 카메라가 떨리는 현상이 발생한다. 따라서 선행된 결괏값을 갖고 후처리 작업을 해야 하므로 LateUpdate()를 이용했다.Transform.LookAt() 함수는 인자로 Vector3 좌표 또는 Transform 컴포넌트를 전달하면 해당 좌표로 회전시키는 기능을 한다. 먼저 카메라의 위치를 이동시킨 후 따라갈 대상을 향해 카메라의 각도를 회전시키는 역할Vecotr3.Lerp, Vector3.Slerp선형 보간(Linear Interpolation)과 구면 선형 보간(Spherical Linear Interpolation)은 시작점과 끝점 사이의 특정 위치의 값을 추정할 때 사용한다. 이러한 보간 함수는 현재 값을 목푯값으로 변경할 때 갑자기 변경하지 않고 부드럽게 변경시키는 로직에 많이 활용된다.선형 보간이라는 명칭에서 알 수 있듯이 “선형”은 “직선”을 의미한다. 균일한 속도로 이동시키거나 회전시킬 때 사용한다.유니티에서는 Lerp 선형 보간 함수를 제공하며 Vector3, Mathf, Quaternion, Color 구조체에서 사용할 수 있다.매개변수는 Lerp(a, b, t)로, a와 b를 잇는 선을 t를 통해 분할하는 지점을 반환한다. 예를 들어 t값이 0.5라면 a, b의 중간지점을 반환한다.Vector3.Lerp(시작 좌표, 종료 좌표, t);Mathf.Lerp(시작 값, 종료 값, t);Quaternion.Lerp(시작 각도, 종료 각도, t);구면 선형 보간(Spherical Linear Interpolation)은 직선의 형태가 아닌 구면(구체)의 형태로 값을 추론한다. 구면을 따라서 값을 반환하기에 시간 t가 증가할 때 시작점과 종료점은 느리게 증가하고 중간지점은 동일한 시간 대비 이동해야 할 거리가 크기 때문에 빠르게 이동하는 특성이 있다. 따라서 구면 선형 보간은 회전 로직에 사용된다.유니티에서 제공하는 구면 선형 보간 함수는 Slerp로 Vector3, Quaternion 구조체에서 사용할 수 있고, 매개변수는 Lerp와 똑같이 가지게 되며 함수의 사용법은 다음과 같다.Vector3.Slerp(시작 좌표, 종료 좌표, t);Quaternion.Slerp(시작 각도, 종료 각도, t);이제 스크립트를 수정한다.using System.Collections;using System.Collections.Generic;using UnityEngine;public class FollowCam : MonoBehaviour{ // 따라가야 할 대상을 연결할 변수 public Transform targetTr; // Main Camera 자신의 Transform 컴포넌트 private Transform camTr; // 따라갈 대상으로부터 떨어질 거리 [Range(2.0f, 20.0f)] public float distance = 10.0f; // Y축으로 이동할 높이 [Range(0.0f, 10.0f)] public float height = 2.0f; // 반응 속도 public float damping = 10.0f; void Start() { // Main Camera 자신의 Transform 컴포넌트를 추출 camTr = GetComponent&lt;Transform&gt;(); } void LateUpdate() { // 추적해야 할 대상의 뒤쪽으로 distance만큼 이동 // 높이를 height만큼 이동 Vector3 pos = targetTr.position + (-targetTr.forward * distance) + (Vector3.up * height); 구면 선형 보간함수를 사용해 부드럽게 위치를 변경 camTr.position = Vector3.Slerp(camTr.position, // 시작 위치 pos, // 목표 위치 Time.deltaTime * damping); // 시간 t // Camera를 피벗 좌표를 향해 회전 camTr.LookAt(targetTr.position + (targetTr.up)); }}변경한 코드는 카메라가 이동할 목표 위치를 변수에 저장한 후 Slerp()를 이용해 점진적으로 이동시킨다. 실행해보면 처음 작성했던 코드보다 부드러워진 것을 확인할 수 있다.Vector3.SmoothDamp부드럽게 이동시키는 방법 중 Vector3.SmoothDamp() 함수를 이용하는 방법도 있다. 보통 카메라의 Follow 로직에 많이 사용되며 사용법은 다음과 같다.Vector3.SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed, float deltaTime); 매개 변수 설명 current 시작 위치 target 목표 위치 currentVelocity 현재 속도 smoothTime 목표 위치까지의 도달 시간 maxSpeed 최대 속력 제한 값(기본값: 무한대 Mathf.Infinity), 생략 가능 deltaTime 프레임 보정을 위한 델타 타임(기본값: Time.deltaTime), 생략 가능 앞서 작성한 코드에서 구면 선형 보간을 사용한 부분은 주석 처리하고 다음과 같이 수정한다.using System.Collections;using System.Collections.Generic;using UnityEngine;public class FollowCam : MonoBehaviour{ // 따라가야 할 대상을 연결할 변수 public Transform targetTr; // Main Camera 자신의 Transform 컴포넌트 private Transform camTr; // 따라갈 대상으로부터 떨어질 거리 [Range(2.0f, 20.0f)] public float distance = 10.0f; // Y축으로 이동할 높이 [Range(0.0f, 10.0f)] public float height = 2.0f; // 반응 속도 public float damping = 10.0f; // SmoothDamp에서 사용할 변수 private Vector3 velocity = Vector3.zero; void Start() { // Main Camera 자신의 Transform 컴포넌트를 추출 camTr = GetComponent&lt;Transform&gt;(); } void LateUpdate() { // 추적해야 할 대상의 뒤쪽으로 distance만큼 이동 // 높이를 height만큼 이동 Vector3 pos = targetTr.position + (-targetTr.forward * distance) + (Vector3.up * height); // 구면 선형 보간함수를 사용해 부드럽게 위치를 변경 // camTr.position = Vector3.Slerp(camTr.position, // 시작 위치 // pos, // 목표 위치 // Time.deltaTime * damping); // 시간 t // SmoothDamp을 이용한 위치 보간 camTr.position = Vector3.SmoothDamp(camTr.position, // 시작 위치 pos, // 목표 위치 ref velocity, // 현재 속도 damping); // 목표 위치까지 도달할 시간 // Camera를 피벗 좌표를 향해 회전 camTr.LookAt(targetTr.position + (targetTr.up)); }}Damping 속성을 0.1로 변경하고 테스트해보면 구면 선형 보간 로직에 사용했던 Damping 변수는 값이 클수록 반응 속도가 빨랐지만 SmoothDamp에서는 목표 지점까지 이동할 때 걸리는 시간으로 사용되기 때문에 반대로 값이 작을수록 반응 속도가 빨라진다.Target Offset 적용지금까지의 코드를 플레이해보면 주인공 캐릭터가 중앙에 위치해 전반 시야가 매우 좁다. 이것은 FollowCam.cs에서 메인 카메라가 플레이어를 향해 LookAt 처리를 해서 플레이어의 피벗 좌표를 바라보기 때문이다. 따라서 LookAt 좌표를 조정해서 전방 시야를 확보해보자.스크립트를 다음과 같이 수정한다.using System.Collections;using System.Collections.Generic;using UnityEngine;public class FollowCam : MonoBehaviour{ // 따라가야 할 대상을 연결할 변수 public Transform targetTr; // Main Camera 자신의 Transform 컴포넌트 private Transform camTr; // 따라갈 대상으로부터 떨어질 거리 [Range(2.0f, 20.0f)] public float distance = 10.0f; // Y축으로 이동할 높이 [Range(0.0f, 10.0f)] public float height = 2.0f; // 반응 속도 public float damping = 10.0f; // 카메라 LookAt의 Offset 값 public float targetOffset = 2.0f; // SmoothDamp에서 사용할 변수 private Vector3 velocity = Vector3.zero; void Start() { // Main Camera 자신의 Transform 컴포넌트를 추출 camTr = GetComponent&lt;Transform&gt;(); } void LateUpdate() { // 추적해야 할 대상의 뒤쪽으로 distance만큼 이동 // 높이를 height만큼 이동 Vector3 pos = targetTr.position + (-targetTr.forward * distance) + (Vector3.up * height); // 구면 선형 보간함수를 사용해 부드럽게 위치를 변경 // camTr.position = Vector3.Slerp(camTr.position, // 시작 위치 // pos, // 목표 위치 // Time.deltaTime * damping); // 시간 t // SmoothDamp을 이용한 위치 보간 camTr.position = Vector3.SmoothDamp(camTr.position, // 시작 위치 pos, // 목표 위치 ref velocity, // 현재 속도 damping); // 목표 위치까지 도달할 시간 // Camera를 피벗 좌표를 향해 회전 camTr.LookAt(targetTr.position + (targetTr.up * targetOffset)); }}실행한 화면이다. 카메라가 플레이어를 향해 다가오고, 캐릭터가 화면 아래쪽에 배치되고 전방 시야가 확보됐다.정리 주인공 3D 모델 임포트 C# 스크립트 생성 방법 키보드 입력값 처리 캐랙터의 이동 및 회전 애니메이션 처리 실시간 그림자와 모바일용 그림자 처리 LOD 설정 FollowCamera 로직 구현게임오브젝트와 컴포넌트 사이의 관계와 기본적인 이동, 회전 기능에 대한 스크립트를 작성해봤다.※ 05장 : 총 발사 로직총알 모델 준비Rigidbody ComponentPhysics Manager(물리 엔진 속성 설정)Collider ComponentBox ColliderSphere ColliderCapsule ColliderMesh ColliderWheel ColliderTerrain Collider충돌 감지 조건충돌 이벤트Tag 이용OnCollisionEnter 콜백 함수CompareTag 함수Bullet의 프리팹 전환총알 발사 로직총알의 발사 위치런 모드에서 수정한 속성기즈모의 활용스크립트 작성 방식Trail Renderer(총알 발사 궤적 효과)Trail Renderer프리팹의 변경 내용 조회 및 저장파티클 활용하기충돌 지점과 법선 벡터Quaternion폭발 효과 및 폭발력 생성Scale Factor하이러키 뷰의 간략화Mesh Renderer(텍스처 변경)폭발력 적용하기 - AddExplosionForceOverlapSPhereNonAllocAudioAudioListener, AudioSource Component오디오 파일 임포트 및 설정오디오 임포트 옵션 - Load Type오디오 임포트 옵션 - Compression Format총소리 구현총구 화염 효과 - Muzzle Flash코루틴 함수MuzzleFlash의 블링크 효과MuzzleFlash의 텍스처 오프셋 변경코루틴의 응용 - 임계치정리※ 06장 : 적 캐릭터 제작유한 상태 머신의 정의메카님적 캐릭터 3D 모델 임포트메카님 애니메이션으로 전환애니메이션 클립 속성애니메이션 리타게팅Animator Component애니메이터 컨트롤러스테이트 전이와 파라미터내비게이션 - 적 캐릭터의 순찰 및 추적내비게이션 설정 - Navigation Static Flag내비메시 베이크NavMeshAgent Component유한 상태 머신 구현적 캐릭터의 상태 체크적 캐릭터의 행동 구현애니메이션 동기화몬스터 공격 루틴몬스터 피격 리액션혈흔 효과Resources 폴더적 캐릭터의 공격 능력OnTriggerEnter 콜백 함수특정 레이어 간의 충돌 감지본 구조의 최적화몬스터 공격 중지애니메이션의 재생 속도 조절사용자 정의 이벤트 - Delegate델리게이트주인공의 사망 이벤트 처리몬스터의 사망 처리Root Transform Position정리※ 07장 : 유니티 UI 시스템유니티 UI 구현 형태IMGUIUI ToolkitUnity UIUI 리소스 준비Canvas 객체EventSystem 객체Canvas 객체의 ComponentCanvas ComponentScreen Space - OverlayScreen Space - CameraWorld SpaceRect Transform Component앵커 프리셋기본 앵커 프리셋Alt 키 조합의 앵커 프리셋Shift 키 조합의 앵커 프리셋Alt + Shift 키 조합의 앵커 프리셋anchoredPosition 속성Anchors 속성Image ComponentSimpleSlicedTiled텍스처의 Wrap ModeFilledRawImage ComponentButton ComponentTransition 속성NavigationButton EventText Component스크립트에서 버튼 이벤트 처리하기람다식TextMesh ProTextMesh Pro의 필수 리소스 설치Text - TextMesh ProTextMesh Pro의 한글 처리KS X 1001 규격의 한글 2350자생명 게이지 구현정리※ 08장 : 게임 매니저적 캐릭터의 출현 로직SpawnPointGroup 생성GameManager 객체 생성Invoke, InvokeRepeate 함수싱글턴 디자인 패턴오브젝트 풀링스코어 UI 구현Playerprefs를 활용한 스코어 저장정리※ 09장 : 레이캐스트 활용레이캐스트DrawRayRaycast, RaycastHit정리※ 10장 : 내비게이션 고급 기법동적 장애물NavMeshObstacle ComponentOff Mesh Link Generation사용자 정의 Off Mesh Link자연스러운 회전 처리Area Mask의 활용경로의 가중치정리※ 11장 : 라이트매핑 및 라이트 프로브전역 조명조명 모드Realtime 모드Mixed 모드Baked 모드라이트매핑Generate Lightmap UVs OptionLightmap Static 플래그라이팅 뷰Progressive 라이트매퍼라이팅 뷰의 EnvironmentBaked 라이트매핑라이트맵 베이크Area Light라이트 프로브Light Probe GroupAnchor Override정리※ 12장 : 씬 관리Scene 분리Scene 병합Multi Scene Edit정리※ 13장 : 오클루전 컬링컬링 방식프리스텀 컬링거리 비례에 의한 컬링오클루전 컬링오클루전 컬링 실습Occluder Static, Occludee Static정리※ 14장 : Input System레거시 Input 클래스새로운 Input System의 특징Input System의 구조Input System의 환경 설정Input System 패키지 설치Active Input Handling테스트 환경 제작Input Action 에셋Control SchemesAction Map 및 Action 생성바인딩 속성 설정이동 동작의 바인딩 추가공격 동작의 액션과 바인딩 추가Player Input ComponentAction 속성Behavior 속성Behavior - Send Messages OptionBehavior - Invoke Unity Events OptionBehavior - Invoke C Sharp EventsDirect BindingInput Debug정리※ 15장 : 포톤 클라우드를 활용한 네트워크 게임" }, { "title": "22-09-03(토)", "url": "/posts/Diary-220903/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-03 00:00:00 +0900", "snippet": "＃깃허브 정리 리포지토리 정리 깃허브 리드미(프로필) 수정＃깃허브/readme＃블로그/About", "content": "＃깃허브 정리 리포지토리 정리 깃허브 리드미(프로필) 수정＃깃허브/readme＃블로그/About" }, { "title": "MongoDB Cloud in Unity", "url": "/posts/Unity-MongoDB/", "categories": "Unity", "tags": "Unity", "date": "2022-09-02 00:00:00 +0900", "snippet": "GitHub 내려받기MongoDB Atlas Database - Cloud DBaaS for MongoDBMongoDB는 자체적으로 서버를 구축해야하지만, 하위 플러그인으로 아틀라스DB를 사용하면 더 간단하게 무료(512MB)로 구축 가능하다.MongoDB 프로젝트 생성 후 구축MongoDB in Unity다운 받은 MongoDB Plugin을 에셋 ...", "content": "GitHub 내려받기MongoDB Atlas Database - Cloud DBaaS for MongoDBMongoDB는 자체적으로 서버를 구축해야하지만, 하위 플러그인으로 아틀라스DB를 사용하면 더 간단하게 무료(512MB)로 구축 가능하다.MongoDB 프로젝트 생성 후 구축MongoDB in Unity다운 받은 MongoDB Plugin을 에셋 폴더에 Import한다.‘MongoDBCtrl.cs’ 생성 후 선언using MongoDB.Bson;using MongoDB.Driver;커넥션 주소를 정수 문자열로 받는다.// xxx:xxx 아이디:비밀번호const string MONGO_URI = \"mongodb+srv://User:User@cluster0.lsm0ujc.mongodb.net/?retryWrites=true&amp;w=majority\";＃Get Connect(User) Info : Loginpublic class MongoDBCtrl : MonoBehaviour{ // 커넥트 정보 const string MONGO_URI = \"mongodb+srv://User:User@cluster0.lsm0ujc.mongodb.net/?retryWrites=true&amp;w=majority\"; MongoClient client; void DB_Login() { client = new MongoClient(MONGO_URI); } private void Start() { DB_Login(); Debug.Log(client); }}＃Get Database Infopublic class MongoDBCtrl : MonoBehaviour{ // 데이터베이스 가져오기 const string DATABASE_NAME = \"TestDB\"; IMongoDatabase db; void Get_DataBase() { db = client.GetDatabase(DATABASE_NAME); }}＃Get IMongoCollectionpublic class MongoDBCtrl : MonoBehaviour{ // 이번엔 콜렉션이 하나이므로 전역변수로 가져오기(DB 안에선 여러 콜렉션이 있을 땐 내부 함수에서 가져오는걸 권장) // GameData Class의 형태로 생성 IMongoCollection&lt;GameData&gt; db_col; void Get_Collection() { db_col = db.GetCollection&lt;GameData&gt;(\"TestDB.TestDB.col\"); }}// GameData.cs - 구조체로 콜렉션의 내용을 추가public class GameData{ // MongoDB 내에서 관리하는 객체 public ObjectId id { get; set; } public string name { get; set; }}＃Insert : 필드 추가 void db_Insert(string name, int score) { GameData _GameData = new GameData(); // 빈 데이터 _GameData.name = name; _GameData.score = score; db_col.InsertOne(_GameData); }＃name 필드가 중복되지 되도록 C#에서 제한하고 생성하기 void DB_Insert(string name, int score ) { // MongoDB 내에서 name필드에 중복이 있는지 검사 if (db_exist(name)) { Debug.Log(\"Name is Exist : \" + name); return; } GameData _GameData = new GameData(); // 빈 데이터 _GameData.name = name; _GameData.score = score; db_col.InsertOne(_GameData); } bool db_exist(string name) { BsonDocument _bson = new BsonDocument { { \"name\", name } }; List&lt;GameData&gt; user_list = db_col.Find(_bson).ToList(); GameData[] user_data = user_list.ToArray(); if (user_data.Length == 0) return false; // 데이터가 없다면 false return true; }＃Search : 필드 검색 void DB_All_View() { List&lt;GameData&gt; user_list = db_col.Find(user =&gt; true).ToList(); // 콜렉션을 리스트화 한다. GameData[] user_data = user_list.ToArray(); // 최적화를 위해 List 자료형 -&gt; 배열로 변환 for (int i = 0; i &lt; user_data.Length; i++) { Debug.Log(user_data[i].name + \" : \" + user_data[i].score); } }하지만 위의 방법은 보안은 좋지 않으므로 아래의 코드처럼 한 번 BsonDocumen를 거쳐 생성한다. void DB_Find(string name) { BsonDocument _bson = new BsonDocument { { \"name\", name } }; List&lt;GameData&gt; user_list = db_col.Find(_bson).ToList(); GameData[] user_data = user_list.ToArray(); for (int i = 0; i &lt; user_data.Length; i++) { Debug.Log(user_data[i].name + \" : \" + user_data[i].score); } }＃Remove : 필드 삭제사용 시 주의할 점 : Undo기능이 없으므로 신중하게 삭제해야 한다.(보통의 서비스들은 1년의 복구기간을 준다. 하지만 이건 아님) DeleteOne() Method DeleteMany() Method // 한 필드만 삭제 void DB_Remove(string name) { BsonDocument _bson = new BsonDocument { { \"name\", name} }; db_col.DeleteOne(_bson); } // 동일 name의 필드들을 삭제 void DB_Removes(string name) { BsonDocument _bson = new BsonDocument { { \"name\", name} }; db_col.DeleteMany(name); } // 전체 필드 삭제 void DB_Remove_All() { BsonDocument _bson = new BsonDocument {}; // &lt;- 모든 선택 db_col.DeleteMany(_bson); }＃Update : 필드 갱신 void DB_Update(string name, int score) { BsonDocument _bson_search = new BsonDocument { { \"name\", name } }; // 조회 BsonDocument _bson_update = new BsonDocument { { \"name\", name }, { \"score\", score } }; // Update db_col.FindOneAndUpdate(_bson_search, _bson_update); }전체 코드＃MongoDBCtrl.cs/// &lt;summary&gt;/// 클라이언트 내부 → 데이터베이스/// 데이터베이스 내부 → 콜렉션/// &lt;/summary&gt;using System.Collections;using System.Collections.Generic;using UnityEngine;using MongoDB.Bson;using MongoDB.Driver;public class MongoDBCtrl : MonoBehaviour{ // Get Connect(User) Info const string MONGO_URI = \"mongodb+srv://song:song@cluster0.qs1ppkp.mongodb.net/?retryWrites=true&amp;w=majority\"; MongoClient client; // Get Database Info const string DATABASE_NAME = \"TestDB\"; IMongoDatabase db; // - 예습에선 콜렉션이 하나이므로 전역변수로 관리 // - DB 안에선 여러 콜렉션이 있을 땐 내부 함수에서 가져오는걸 권장 // - GameData Class의 형태로 생성 IMongoCollection&lt;GameData&gt; db_col; private void Start() { First(); Debug.Log(\"=====:Action:=====\"); //DB_Find(\"song\"); //DB_All_View(); //DB_Insert(\"ugi\", 1); //DB_Remove(\"song\"); } void First() { DB_Login(); Get_DataBase(); Get_Collection(); Debug.Log(\"=====:접속 정보:=====\"); Debug.Log(\"Client : \" + client); Debug.Log(\"DataBase Name : \" + db); Debug.Log(\"Data Collection : \" + db_col); } void DB_Login() { client = new MongoClient(MONGO_URI); } void Get_DataBase() { db = client.GetDatabase(DATABASE_NAME); } void Get_Collection() { db_col = db.GetCollection&lt;GameData&gt;(\"TestDB.col\"); } void DB_Insert(string name, int score) { // MongoDB 내에서 name필드에 중복이 있는지 검사 if (db_exist(name)) { Debug.Log(\"Name is Exist : \" + name); return; } GameData _GameData = new GameData(); // 빈 데이터 _GameData.name = name; _GameData.score = score; db_col.InsertOne(_GameData); } bool db_exist(string name) { BsonDocument _bson = new BsonDocument { { \"name\", name } }; List&lt;GameData&gt; user_list = db_col.Find(_bson).ToList(); GameData[] user_data = user_list.ToArray(); if (user_data.Length == 0) return false; // 데이터가 없다면 false return true; } void DB_All_View() { List&lt;GameData&gt; user_list = db_col.Find(user =&gt; true).ToList(); // 콜렉션을 리스트화 한다. GameData[] user_data = user_list.ToArray(); // 최적화를 위해 List 자료형 -&gt; 배열로 변환 for (int i = 0; i &lt; user_data.Length; i++) { Debug.Log(user_data[i].name + \" : \" + user_data[i].score); } } void DB_Find(string name) { // 데이터를 주고 받는 일은 json으로 보내어 보안을 강화한다. BsonDocument _bson = new BsonDocument { { \"name\", name } }; List&lt;GameData&gt; user_list = db_col.Find(_bson).ToList(); GameData[] user_data = user_list.ToArray(); for (int i = 0; i &lt; user_data.Length; i++) { Debug.Log(user_data[i].name + \" : \" + user_data[i].score); } } void DB_Remove(string name) // 한 필드만 삭제 { BsonDocument _bson = new BsonDocument { { \"name\", name } }; db_col.DeleteOne(_bson); } void DB_Removes(string name) // 동일 name의 필드들을 삭제 { BsonDocument _bson = new BsonDocument { { \"name\", name } }; db_col.DeleteMany(name); } void DB_Remove_All() // 전체 필드 삭제 { BsonDocument _bson = new BsonDocument { }; // &lt;- 모든 선택 db_col.DeleteMany(_bson); } void DB_Update(string name, int score) { BsonDocument _bson_search = new BsonDocument { { \"name\", name } }; // 조회 BsonDocument _bson_update = new BsonDocument { { \"name\", name }, { \"score\", score } }; // Update db_col.FindOneAndUpdate(_bson_search, _bson_update); }}＃GameData.csusing System.Collections;using System.Collections.Generic;using UnityEngine;using MongoDB.Bson;using MongoDB.Driver;// GameData.cs - 구조체로 콜렉션의 내용을 추가public class GameData{ // MongoDB 내에서 관리하는 객체 public ObjectId id { get; set; } // 필드의 고유 Index public string name { get; set; } public int score { get; set; }}" }, { "title": "22-09-02(금)", "url": "/posts/Diary-220902/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-02 00:00:00 +0900", "snippet": "＃깃허브 계정 복구 회신 &amp; 병합부계정은 관라자를 본 계정으로 이전하고 삭제했다.. 잔디가 아깝지만 ㅠㅠ＃경진대회 사업 계획서 제출 발표자료＃프로젝트 패널 관련 작업 컨트롤러와 콜라이더 트리거 반응 추가 소리 파티클 점수 E...", "content": "＃깃허브 계정 복구 회신 &amp; 병합부계정은 관라자를 본 계정으로 이전하고 삭제했다.. 잔디가 아깝지만 ㅠㅠ＃경진대회 사업 계획서 제출 발표자료＃프로젝트 패널 관련 작업 컨트롤러와 콜라이더 트리거 반응 추가 소리 파티클 점수 End Event 클립의 플레이 타임이 경과되면 출력하도록 한다. Music List Reset Result UI 출력 하도록 만들기 데이터 저장 및 보안 -&gt; json ＃개인 공부 절대강좌! 유니티 14장까지" }, { "title": "Playerprefs를 활용하여 데이터 저장하기", "url": "/posts/Unity-Playerprefs/", "categories": "Unity", "tags": "Unity", "date": "2022-09-01 00:00:00 +0900", "snippet": "PlayerPrefs를 이용하여 게임 결과를 Result UI에 저장하기＃스크립트Using UnityEngine.UI※ 모든 키 값 삭제 DeleteAll※ 특정 키 값 삭제 DeleteKey※ 해당 키가 존재 유무를 반환 HasKey※ 변경된 모든 키 값들을 물리적인 저장 공간에 저장 Save※ 지정한 키로 형식별 타입의 값을 저장 GetF...", "content": "PlayerPrefs를 이용하여 게임 결과를 Result UI에 저장하기＃스크립트Using UnityEngine.UI※ 모든 키 값 삭제 DeleteAll※ 특정 키 값 삭제 DeleteKey※ 해당 키가 존재 유무를 반환 HasKey※ 변경된 모든 키 값들을 물리적인 저장 공간에 저장 Save※ 지정한 키로 형식별 타입의 값을 저장 GetFloat GetInt GetString※ 지정한 키로 형식별 타입의 값을 저장 SetFloat SetInt SetString참고 사이트 [너랑 나랑 개발자 이야기](https://you-rang.tistory.com/139" }, { "title": "22-09-01(목)", "url": "/posts/Diary-220901/", "categories": "Diary, 2022.09", "tags": "Diary", "date": "2022-09-01 00:00:00 +0900", "snippet": "＃깃허브 계정 복구 회신 &amp; 병합＃경진대회 통합 공고문 확인 신청서 작성 발표자료＃프로젝트 패널 관련 작업 컨트롤러와 콜라이더 트리거 반응 추가 소리 파티클 점수 End Event 클립의 플레이 타임이 경과...", "content": "＃깃허브 계정 복구 회신 &amp; 병합＃경진대회 통합 공고문 확인 신청서 작성 발표자료＃프로젝트 패널 관련 작업 컨트롤러와 콜라이더 트리거 반응 추가 소리 파티클 점수 End Event 클립의 플레이 타임이 경과되면 출력하도록 한다. Music List Reset Result UI 출력 하도록 만들기 데이터 저장 및 보안 -&gt; json ＃개인 공부 절대강좌! 유니티 14장까지" }, { "title": "22-08-31(수)", "url": "/posts/Diary-220831/", "categories": "Diary, 2022.08", "tags": "Diary", "date": "2022-08-31 00:00:00 +0900", "snippet": "＃프로젝트 Controller Changer아래의 함수를 만들고, 각 버튼 이벤트에서 호출하게 했다. public void Change() { if (isHandChange) // Hand Controller { layControllerDeviceLeft.SetActive(false); ...", "content": "＃프로젝트 Controller Changer아래의 함수를 만들고, 각 버튼 이벤트에서 호출하게 했다. public void Change() { if (isHandChange) // Hand Controller { layControllerDeviceLeft.SetActive(false); layControllerDeviceRight.SetActive(false); handControllerDeviceLeft.SetActive(true); handControllerDeviceRight.SetActive(true); isHandChange = false; return; } else // Lay Controller { handControllerDeviceLeft.SetActive(false); handControllerDeviceRight.SetActive(false); layControllerDeviceLeft.SetActive(true); layControllerDeviceRight.SetActive(true); isHandChange = true; return; } } Quiz Panel Event 모델링 의뢰 제작 Quiz Canves 회의 Scripts Result UI(Event는 미구현) Collider(충돌 이벤트는 미구현) 장면 꾸미기(Light Baked) Music List Reset End Event 클립의 플레이 타임이 경과되면 출력하도록 한다. ＃개인 공부 절대강좌! 유니티 14장까지" }, { "title": "TimeScale을 이용한 일시정지 기능 만들기", "url": "/posts/Unity-TimeScale/", "categories": "Unity", "tags": "Unity", "date": "2022-08-30 00:00:00 +0900", "snippet": "Time.timeScaleProject Setting - Time의 Time Scale과 동일통상적인 게임 속도는 1이다.그러므로 1을 0으로 바꾼다면 일시 정지가 된다.Time.timeScale = 0;타임 스케일을 0으로 두고 메뉴 UI가 나왔을 때 메뉴를 선택하는 작동 등은 가능하다.0.5를 한다면 2분의 1 속도를 연출할 수 있다.(슬로우모션)...", "content": "Time.timeScaleProject Setting - Time의 Time Scale과 동일통상적인 게임 속도는 1이다.그러므로 1을 0으로 바꾼다면 일시 정지가 된다.Time.timeScale = 0;타임 스케일을 0으로 두고 메뉴 UI가 나왔을 때 메뉴를 선택하는 작동 등은 가능하다.0.5를 한다면 2분의 1 속도를 연출할 수 있다.(슬로우모션)게임의 연산 중 시간의 변화에 따라 연산이 되는 부분들을 제어하게 될 수 있는 것 같다.이걸로 프로젝트에선 게임 진행 중에 패널과 시간 등을 멈추게 하고 Pause UI 출력해 봐야겠다!참고 사이트 Technical Artist의 기록" }, { "title": "22-08-30(화)", "url": "/posts/Diary-220830/", "categories": "Diary, 2022.08", "tags": "Diary", "date": "2022-08-30 00:00:00 +0900", "snippet": "＃프로젝트 Music List Reset End Event 클립의 플레이 타임이 경과되면 출력하도록 한다. Result UI + Event Played Music 소스에 클립 없으면 시작 못하게 하기 평소엔 interactable을 비활성화 해두고, 버튼 프리팹에서 Select했을 때 활성화 시켜줌 ...", "content": "＃프로젝트 Music List Reset End Event 클립의 플레이 타임이 경과되면 출력하도록 한다. Result UI + Event Played Music 소스에 클립 없으면 시작 못하게 하기 평소엔 interactable을 비활성화 해두고, 버튼 프리팹에서 Select했을 때 활성화 시켜줌 public class MusicElements : MonoBehaviour{ GameObject selectedElement; public void Select() { GameManager.instance.btnPlay.GetComponent&lt;Button&gt;().interactable = true; // 노래 재생(Play) 버튼 활성화 ... }} Pause UI + Event(UnPause) XR Interaction Toolkit Manual XR Interaction Toolkit Input Document Unity XR Toolkit을 이용한 VR Input 설정 방법 XR Interaction Toolkit Input 타이밍에 맞도록 BGM 정지, 재생 설정 (float)MusicLength to (string)PlayTimepublic void CustomListRenewal() { isOriginal = false; isCustom = true; // Custom Music 폴더의 AudioClip 속성 파일 조회 customMusics = Resources.LoadAll&lt;AudioClip&gt;(\"Custom Music\"); for (int i = 0; i &lt; customMusics.Length; i++) { customMusicElementPrefab = customMusics[i] as GameObject; // AudioClip to GameObject customMusicElementPrefab = Instantiate(musicElement); customMusicElementPrefab.name = $\"Custom Music Element_{i}\"; customMusicElementPrefab.transform.parent = contentCustom.transform; customMusicElementPrefab.transform.localScale = Vector3.one; customMusicElementPrefab.transform.position = contentCustom.transform.position; //customMusicElementPrefab.transform.GetChild(3).GetComponent&lt;AudioSource&gt;().playOnAwake = false; // Off 'Play On Awake' // AudioSource.clip ← Resources-Custom Musics.AudioClip customMusicElementPrefab.transform.GetChild(3).gameObject.GetComponent&lt;AudioSource&gt;().clip = (AudioClip)customMusics[i]; // (float)MusicLength to (string)PlayTime customMusicElementPrefab.transform.GetChild(2).gameObject.GetComponent&lt;Text&gt;().text = TimeFormatter(customMusicElementPrefab.transform.GetChild(3).gameObject.GetComponent&lt;AudioSource&gt;().clip.length, false); // textTitle.text ← customMusicElements.AudioSource.text customMusicElementPrefab.transform.GetChild(1).gameObject.GetComponent&lt;Text&gt;().text = customMusicElementPrefab.transform.GetChild(3).gameObject.GetComponent&lt;AudioSource&gt;().clip.name; } } public static string TimeFormatter(float seconds, bool forceHHMMSS = false) { float secondsRemainder = Mathf.Floor((seconds % 60) * 100) / 100.0f; int minutes = ((int)(seconds / 60)) % 60; int hours = (int)(seconds / 3600); if (!forceHHMMSS) { if (hours == 0) { return System.String.Format(\"{0:00}:{1:00.00}\", minutes, secondsRemainder); } } return System.String.Format(\"{0}:{1:00}:{2:00}\", hours, minutes, secondsRemainder); }＃개인 공부 절대강좌! 유니티 14장까지" }, { "title": "22-08-29(월)", "url": "/posts/Diary-220829/", "categories": "Diary, 2022.08", "tags": "Diary", "date": "2022-08-29 00:00:00 +0900", "snippet": "경진대회경남창조혁신센터 - 2022 동남권 메가시티 창업아이디어 경진대회 참가자 모집 공고＃프로젝트 UI 연결 마무리 BPM Sync＃개인 공부 절대강좌! 유니티 14장까지프로젝트 발표 피드백 핵심 기술에 대해 구체적인 설명이 부족 설문지 작성자 인적사항(성별란, 나이란(10대 이하, 10대, 20대, 30대, 40대, 50대...", "content": "경진대회경남창조혁신센터 - 2022 동남권 메가시티 창업아이디어 경진대회 참가자 모집 공고＃프로젝트 UI 연결 마무리 BPM Sync＃개인 공부 절대강좌! 유니티 14장까지프로젝트 발표 피드백 핵심 기술에 대해 구체적인 설명이 부족 설문지 작성자 인적사항(성별란, 나이란(10대 이하, 10대, 20대, 30대, 40대, 50대 이상)) 플레이 시간(10분 미만, 10분~30분, 30분~1시간, 1시간 이상) 이번 주 과제 프리핑송환욱 - 게임 흐름 구현강원우 - 퀴즈 디자인김재원 - 패널 디자인, 퀴즈 모델링최희원 - 퀴즈 디자인" }, { "title": "22-08-28(일)", "url": "/posts/Diary-220828/", "categories": "Diary, 2022.08", "tags": "Diary", "date": "2022-08-28 00:00:00 +0900", "snippet": "＃프로젝트 발표 자료 14, 16, 18페이지 UI 연결 마무리 설문지 작성 BPM Sync＃개인 공부 블로그 절대강좌! 유니티 14장까지유니티어제 세분화 했던 스크립트에서 오류가 터져서 다시 GameMgr로 한 데 모았다..각각의 이벤트로 연결되는 동적 버튼을 더 공부해야 해결 될 거 같다.프로젝트의 설계 단계에서 꽤나 준비를 많이 한 것...", "content": "＃프로젝트 발표 자료 14, 16, 18페이지 UI 연결 마무리 설문지 작성 BPM Sync＃개인 공부 블로그 절대강좌! 유니티 14장까지유니티어제 세분화 했던 스크립트에서 오류가 터져서 다시 GameMgr로 한 데 모았다..각각의 이벤트로 연결되는 동적 버튼을 더 공부해야 해결 될 거 같다.프로젝트의 설계 단계에서 꽤나 준비를 많이 한 것 같았지만 여전히 핵심적인 부분은 많이 부족했던 거 같아서 아쉽지만서도 좋은 경험이 된 것 같다..그래서 먼저 내일 있을 발표 자료부터 완성하고, 설문지도 완성했다. 나름 잘 된 거 같다 ㅋㅋ" }, { "title": "개발 기초, 좋은 팁 모음", "url": "/posts/Unity-Info/", "categories": "Unity", "tags": "Unity", "date": "2022-08-27 00:00:00 +0900", "snippet": "유니티 팁Unity 프로그래머로써 취업을 목표로 했다면, C#에 집중하라취업 후에도 90%는 외부(에셋스토어, API, 라이브러리 등)에서, 나머지 10%는 개인 역량으로 해결하는 것이 보통이다.※ 패키지 매니저로 설치할 땐 공식 지원이 아닌 방법이므로 위험하다. 귀찮더라도 프로젝트 백업은 필수!!※ 빠르게 유니티 프로그램을 공부하는 방법 -&gt; ...", "content": "유니티 팁Unity 프로그래머로써 취업을 목표로 했다면, C#에 집중하라취업 후에도 90%는 외부(에셋스토어, API, 라이브러리 등)에서, 나머지 10%는 개인 역량으로 해결하는 것이 보통이다.※ 패키지 매니저로 설치할 땐 공식 지원이 아닌 방법이므로 위험하다. 귀찮더라도 프로젝트 백업은 필수!!※ 빠르게 유니티 프로그램을 공부하는 방법 -&gt; 에셋스토어에서 크로스플랫폼 되는 기본 예제를 분석한다.※ SystemInfo 클래스의 graphicsDeviceType 열거형에 해당하는 GUP 엔진을 확인한다.※ 휴대폰 환경도 확인하고, 다른 역할을 수행하게 할 수 있다.※ Sprite와 Texture게임 개발자가 주로 사용하는 용어 Sprite 2D GPU이전에 메인보드에서 처리 일반 좌표계 :: 좌측 상단에서 (0, 0) Texture 3D GPU에 올리고 변경은 Transform으로 변환한다. UV좌표계 :: 좌측 하단에서 (0(U), 0(V)) ※ 라이브러리에서 이미지 파일을 불러올 때 필수 작업GPU의 연산이 과도하게 낭비될 수 있다.따라서 파일의 해상도에 따라 **반드시** 조절해야한다.그래픽 디자이너에게 커미션 할 때 2의 배수 또는 4의 배수로 리퀘스트하기가로x세로 해상도 중에 큰 수를 기준으로 한 단계 위로 설정하기Ex. 900x512 사이즈의 .png 파일을 수정한다면 '1024'로 설정※ 안드로이드 포팅운이 좋으면 바로 될 수 있다.하지만 에러가 발생했을 땐 현직자들도 매우 어려워한다.유니티 버전마다 SDK, NDK, JDK 기본 세팅법이 다르기 때문에 오류가 빈번하다.심지어 그 오류를 콘솔에서 확인하는 방법이 별로 없기 때문에, 검색을 통해서 알아내야함" }, { "title": "22-08-27(토)", "url": "/posts/Diary-220827/", "categories": "Diary, 2022.08", "tags": "Diary", "date": "2022-08-27 00:00:00 +0900", "snippet": "일상 국민취업지원제도 신청 저장 코로나 지원금 신청 → 오프라인으로 방문해야 함개발 오큘러스 개발자 계정 블로그 카테고리, 태그 구현 블로그 정리 VR 프로젝트 발표 자료 공유, 보완 VR 프로젝트 설문지 취합 프로젝트 UI 연결 절대강좌! 유니티 책 14장까지회의 진행22.08.27 20:00 ~ 21:10회의 안건 :: 발표 자료...", "content": "일상 국민취업지원제도 신청 저장 코로나 지원금 신청 → 오프라인으로 방문해야 함개발 오큘러스 개발자 계정 블로그 카테고리, 태그 구현 블로그 정리 VR 프로젝트 발표 자료 공유, 보완 VR 프로젝트 설문지 취합 프로젝트 UI 연결 절대강좌! 유니티 책 14장까지회의 진행22.08.27 20:00 ~ 21:10회의 안건 :: 발표 자료(검토, 보완)＃김재원, 최희원 글이 많은 페이지에선, 글의 자간과 행간을 적절히 조절한다. ‘개발 목적’과 ‘핵심 기술-퀴즈’ : KCI 논문(노인의 인지-신체활동 프로그램 참여가 인지기능에 미치는 영향)의 연구 결과에 근거하여 설계함을 주장＃송환욱 ‘기술 보호 계획’ : 프로젝트 완성 단계 쯤 수립 ‘UI/UX 와이어 프레임’ : png파일로 누끼따기 ‘레퍼런스’ : 참조한 핵심 내용을 기술 ‘2주 뒤 결과’ : 금일 회의에서 정해진 타임라인을 참고 ‘회의록 모음’ : 금일 회의록 추가 ‘마무리’ : 팀, 어드레스 수정 설문지 작성(양식, 질문)양식 : 한글 파일＃질문 별로 1줄 정도의 주관식 답변을 적을 수 있도록 한다. 매우 그렇다 2. 그렇다 3. 보통이다 4. 아니다 5. 매우 아니다※ 질문 게임 플레이 ＃게임은 전반적으로 재밌었나요? ＃난이도는 적절했나요? ＃게임 진행 과정이 불편하지 않았나요? ＃배경을 보고, 배경음을 들음으로써 마음이 편안해졌나요? ＃효과음은 적절한가요? ＃퀴즈의 난이도는 적절한가요? ＃전반적인 퀴즈 내용에 대해 선호도를 선택해주세요. 사용자 ＃[효과]전반적으로 운동 효과가 있었나요? ＃[부상]게임을 진행하면서 다칠 것 같던 동작이 있었나요? ＃[피로]게임을 진행하면서 눈이 피로해지셨나요? ＃[어지러움]멀미 정도는 어떠셨나요? ＃[어지러움]게임의 색이 화려해서 어지럽지는 않았나요? ＃주관식) 추가 개선사항을 적어주세요. [8.28(일)~09.09(금)] 2주뒤 결과 / 일정, 스케줄 정리＃22-08-29(월) ~ 22-09-02(금) 송환욱, 강원우 - 자동 채보 로직 기반 커스텀 레벨 디자인 최희원, 김재원 - 퀴즈 디자인 김재원 - 메인/인게임 컨트롤러 변경 강원우, 송환욱 - 2차 UI(Stop / Easy Result) ＃22-09-05(월) ~ 22-09-09(금) 3차 UI(Result + Detail) 점수 디자인 동작 별 칼로리 소모량 로직 UML 다이어그램 작성 기술 보호 계획 수립" }, { "title": "22-08-26(금)", "url": "/posts/Diary-220826/", "categories": "Diary, 2022.08", "tags": "Diary", "date": "2022-08-26 00:00:00 +0900", "snippet": "강사님의 조언 / 나의 생각프래그래머는 고집이 세다, 자신의 예술성을 고집하고 자신이 좋아하는 것을 만드는 경향이 강하기 때문이다.어떤 엔진이든 개발을 하면서 가져야 할 마음가짐은 ‘돈을 벌기 위해서 하는 것’이라는 마인드로 해야 한다.특히 게임 등의 컨텐츠에서 취급하는 예술성은 대중이 그 가치를 자세히 알아주지 않기 때문이다.그러므로 자기가 좋아하는...", "content": "강사님의 조언 / 나의 생각프래그래머는 고집이 세다, 자신의 예술성을 고집하고 자신이 좋아하는 것을 만드는 경향이 강하기 때문이다.어떤 엔진이든 개발을 하면서 가져야 할 마음가짐은 ‘돈을 벌기 위해서 하는 것’이라는 마인드로 해야 한다.특히 게임 등의 컨텐츠에서 취급하는 예술성은 대중이 그 가치를 자세히 알아주지 않기 때문이다.그러므로 자기가 좋아하는 컨텐츠를 만드는 건 어느정도 객관적인 타협이 필요하다.세상의 경향과 니즈를 잘 파악하고 객관적인 시선으로 바라보며 만들어진 창작물은 론칭 시작부터 반 이상은 호감을 얻고 시작할 수 있다.초보의 시기엔 기본기(주 언어, 알고리즘, 패턴, 공식)가 가장 중요하고, 다음으로 라이센스, 버전 관리(프로젝트 관리 / 협업 과정), 기록하는 방법 등을 공부하는 과정이 중요하다고 생각한다." }, { "title": "Mathf.Sin()곡선을 이용해 간단한 물결 애니메이션 구현하기", "url": "/posts/Unity-Mathf.Sin/", "categories": "Unity", "tags": "Unity", "date": "2022-08-25 00:00:00 +0900", "snippet": "y = sin x다양한 수학 공식을 알고 있다면, 복잡한 애니메이션을 쉽게 구현할 수 있다.※ 보통 에셋스토어에도 있음sin 곡선의 공식을 이용해 위/아래 또는 좌/우로 부드럽게 움직이는 곡선 애니메이션 적용카메라가 이동 때 마다 물결 애니메이션 구현using System.Collections;using System.Collections.Generic...", "content": "y = sin x다양한 수학 공식을 알고 있다면, 복잡한 애니메이션을 쉽게 구현할 수 있다.※ 보통 에셋스토어에도 있음sin 곡선의 공식을 이용해 위/아래 또는 좌/우로 부드럽게 움직이는 곡선 애니메이션 적용카메라가 이동 때 마다 물결 애니메이션 구현using System.Collections;using System.Collections.Generic;using UnityEngine;public class CameraMove : MonoBehaviour{ float sin_val = 0; void Sin_wave_Compute() // y = Sin x (곡선 함수) { float _ry = Mathf.Sin(sin_val); // 3.14 sin_val += 0.01f; m_cam.transform.Translate(0, _ry * 0.005f, 0); } public Camera m_cam; private void Update() { if (Input.GetKey(KeyCode.D)) { m_cam.transform.position += m_cam.transform.right * Time.deltaTime * 2.0f; Sin_wave_Compute(); } if (Input.GetKey(KeyCode.A)) { m_cam.transform.position += -m_cam.transform.right * Time.deltaTime * 2.0f; Sin_wave_Compute(); } if (Input.GetKey(KeyCode.W)) { m_cam.transform.Translate(0, 0, Time.deltaTime * 2.0f); Sin_wave_Compute(); } if (Input.GetKey(KeyCode.S)) { m_cam.transform.Translate(0, 0, -Time.deltaTime * 2.0f); Sin_wave_Compute(); } }}" }, { "title": "Unity LifeCycle(유니티 생명주기)", "url": "/posts/Unity-LifeCycle/", "categories": "Unity", "tags": "Unity", "date": "2022-08-25 00:00:00 +0900", "snippet": "참고 사이트 Unity Documentation (스크립팅 개념 - 이벤트 함수의 실행 순서)※ Unity LifeCycle(유니티 생명주기)※ 생명주기별 주의할 점 | 최적화- Find()는 최대한 사용하지 않는다.- 'GetComponent'는 Update()에서 사용하지 않도록 한다. 반면, Start()에선 성능 저하가 덜하므로 사용해도 된다.", "content": "참고 사이트 Unity Documentation (스크립팅 개념 - 이벤트 함수의 실행 순서)※ Unity LifeCycle(유니티 생명주기)※ 생명주기별 주의할 점 | 최적화- Find()는 최대한 사용하지 않는다.- 'GetComponent'는 Update()에서 사용하지 않도록 한다. 반면, Start()에선 성능 저하가 덜하므로 사용해도 된다." }, { "title": "Unity AR SDK 소개, 설치 후 세팅", "url": "/posts/Unity-AR/", "categories": "Unity, Unity AR", "tags": "Unity, Unity AR", "date": "2022-08-25 00:00:00 +0900", "snippet": "※ 시작하기 전AR의 한계는 이미지 프로세싱에서 명확하므로, 발전 가능성은 낮다고 생각된다.반면, 홀로렌즈는 그 한계에서 자유로워 미래 시장 가치가 높다.물론 Andorid, IOS 한정 프로젝트에서 여러가지 모듈을 이용하여 색다른 변화를 줄 수 있다. ※ Unity AR Components 대표적인 AR 컴포넌트는 3가지가 있다. 1. AR F...", "content": "※ 시작하기 전AR의 한계는 이미지 프로세싱에서 명확하므로, 발전 가능성은 낮다고 생각된다.반면, 홀로렌즈는 그 한계에서 자유로워 미래 시장 가치가 높다.물론 Andorid, IOS 한정 프로젝트에서 여러가지 모듈을 이용하여 색다른 변화를 줄 수 있다. ※ Unity AR Components 대표적인 AR 컴포넌트는 3가지가 있다. 1. AR Foundation 유니티에서 공식 제공(무료) 접근성은 편하지만 상업용으로 사용하기엔 부족함이 많아서 추천하지 않음 Documents(바로가기) 1-1. Support Platform ARCore(Android) ARKit(IOS) Magic Leap HoloLens 1-2. 지원 하는 기능 안드로이드는 종류가 많아서 IOS에 비해 기능적 제한이 있다. 자주 사용되는 기능 Device tracking Plane tracking : 4개의 점 좌표를 기반해 평면으로 보여준다. Point clouds : 4개의 점 좌표 추적 Face tracking : 얼굴 추적 2D/3D Image tracking : 이미지 추적 3D Object tracking(Only IOS): 3차원적 물체를 추적(집, 사람 등) 2D &amp; 3D body tracking(Only IOS) : 몸을 추적 Raycast Occlusion 2. MAXST 성능이 우수하지만, 유료이며 가격이 비싸다. 퍼포먼스가 가볍다. 무료 버전은 워터마크가 있음(유료 전환 시 삭제 可) 3. Vuforia MAXST대비 성능은 부족해도 가격은 싸다. ※ Setup AR Foundation in Unity Project 1. 유니티 프로젝트 -&gt; 패키지 매니저에서 아래의 패키지 인스톨 AR Foundation ARCore XR Plugin : Andorid ARKit Face Tracking : IOS Face Tracking ARKit XR Plugin : IOS 2. AR Foundation Samples 에서 버전 선택(4.2) 후 Download Zip 3. 압축 해제한 파일 프로젝트로 덮어쓰기 ※ AR Foundation Module Option 자주 사용하는 모듈을 정리했다. ＃SimpleAR ARSessionOrigin.cs 통제 대상이 될 기준(카메라)을 가져온다. ARPlaneManager.cs 평면(Plane)을 이미지 프로세싱하여 추적한다. Player(Origin)가 걸어다닐 곳을 판단 ARPointCloudManager.cs 평면 인식을 사용하는 포인트, 유용하진 않다. ARRaycastManager.cs Ray로 추적한 Obj 정보를 전부 가져온다. 프리팹은 Ray에서 지정한 위치에 생성된다. PlaceOnPlane.cs 사각 평면을 찾는다. 프리팹은 평면을 찾았을 때 그 평면 위에 생성된다. AR Session Origin - AR Camera - Scirpts ＃Object Tracking: 오브젝트 추적 AR Session Origin - Scirpts ARTrackedObjectManager.cs 비슷한 물체를 추적하도록 돕는 스크립트 Reference Library : 추적 기준이 되는 본체 모듈 ＃Image Tracking: 이미지 추적 AR Session Origin - Scirpts ＃Face Tracking: 사람 얼굴 인식 ＃CameraGrain: 카메라 해상도 ＃Configurations ＃Depth ※ Setup MAXST in Unity Project 회원가입 필수 4.1.3 버전으로 다운로드(버전업 할 수록 웹캠은 지원하지 않음) 공식 홈페이지 : MAXST AR SDK Download In Project → Package Import ※ MAXST Module Option ＃GPU Engine Change OpenGL Core 생성 후 기존 엔진 삭제 -&gt; Restart Direct X 11 -&gt; OpenGL 4.5 ＃CameraConfiguration 카메라 셋팅 AR Camera OBJ만 있으면 바로 사용 가능 CameraBackground 내에서 이미지 프로세싱을 한다. ＃CodeReader : 바코드 스캔 ＃InstantTracker : 오브젝트 위치 지정 트래킹 후에 카메라가 회전해도 오브젝트는 제 자리에 있음 카메라가 많을 수록 정확도가 높다. ＃ImageTracker : 이미지 트래킹 트래킹 전용 데이터(이미지)를 설정해주는 작업이 필요하다. MAXST 홈페이지에서 타깃 그룹/데이터를 업로드하고 학습받은 데이터를 내려받는다. Image Trackable Obj -&gt; Image Trackable Behavior 스크립트 이미지 타겟 선정 트래킹 성공 시 Image Trackable Obj 자식들을 Enable해준다. 그 때 자식 오브젝트는 오디오 소스, url, 모델 등 유니티 내에서 불러낼 수 있는 요소는 무엇이든 가능하다. ＃VideoTracker : 비디오 트래킹 보통은 드문 경우이지만, 재생중인 영상에게 트래킹을 시도해서 추가 정보를 전달할 때 사용한다. 기술이 어렵고(시간, 비용이 높다.) 보통 전시회나 관공서에서 사용하고 이외엔 잘 없음 ＃CloudRecognizer : 서버의 데이터와 트래킹해준다. 트래킹 할 오브젝트의 컴포넌트로 설정 유료로 전환해야 제대로 사용할 수 있음 클라우드의 개념상, 정적인 개념에 가까워 그다지 유용하지 않다. MAXST에서 SceneMgr의 역할은 어느 모듈이여도 초기화하고 준비하는 역할로 사용된다. 빌드 중일 때 스크립트에 의해 SceneMgr에서 비디오 플레이어를 준비하게 된다. ＃ObjectTracker : 실제 물체를 트래킹한다. 인앱을 이용해 좌표를 스캔하고서 그 데이터를 다른 트래킹에 이용할 수 있다. 오브젝트 촬영, 핀 설정 후 데이터 내보내고 프로젝트에서 임포트하기 임포트한 오브젝트를 배치하고 핀에 Trackable obj를 배치한다. 이후 빌드 " }, { "title": "Jekyll Chirpy theme Setting", "url": "/posts/Jekyll-Chirpy-theme-Setting/", "categories": "Tech Tip, Github Pages", "tags": "jekyll, Github Pages, Chripy", "date": "2022-08-25 00:00:00 +0900", "snippet": "참고 사이트 Chirpy 테마 커스터마이징 By 하얀눈길 푸쉬 전 로컬에서 확인하기 ＃Git Bash$ jekyll serve＃Web Browserhttp://localhost:4000/ GitHub Pages Source _config.yml : 블로그 기본 환경세팅 _data : 왼쪽 사이드바 ...", "content": "참고 사이트 Chirpy 테마 커스터마이징 By 하얀눈길 푸쉬 전 로컬에서 확인하기 ＃Git Bash$ jekyll serve＃Web Browserhttp://localhost:4000/ GitHub Pages Source _config.yml : 블로그 기본 환경세팅 _data : 왼쪽 사이드바 / 포스트 하단의 공유하기 버튼등의 구성을 변경, 언어 설정에 따라 기본적으로 화면에 나오는 단어들이 변경 _include : Side-Bar / toc / Google Analytics / footer / comments 등 모듈형으로 삽입되는 UI를 변경하는 공간 _layout : 블로그 전역에 적용되는 기본 형식, 카테고리, 포스트 등에 적용되는 형식등을 변경할 수 있습니다. _posts : 내가 작성한 블로그 글을 저장해 두는 곳입니다. _sass : css 파일을 커스터마이징 할 수 있습니다. _site : 로컬에서 실행할 때, 화면 UI를 구성하는 모든 내용이 들어 있습니다. 이곳의 내용을 변경하면 로컬에는 잘 반영되지만, git에는 올라가지 않습니다. 또한 다른 기본 디렉토리의 내용을 변경하고 빌드하게 되면 이곳의 내용이 바뀌게 됩니다. _tabs : 왼쪽 사이드바의 기본 탭메뉴들에 대한 랜딩페이지가 들어 있습니다. assets : css, img등이 있습니다. 포스팅에 들어갈 이미지는 assets/img 아래에 넣으면 됩니다. tools : github에서 자동 배포를 위한 코드가 들어 있습니다. 이곳은 아예 건들지 맙시다 " }, { "title": "22-08-24(수)", "url": "/posts/Diary-220824/", "categories": "Diary, 2022.08", "tags": "Diary, C#", "date": "2022-08-24 00:00:00 +0900", "snippet": "GitHub 본계정이 일시 정지 처분을 받았다..계정 복원이 될 때 까진 프로젝트 진행을 멈추고 C#, 유니티 내장 함수, 디자인 패턴, 알고리즘 공부Velog를 사용하려 했지만, 커스터마이징 기능이 부족해서 다시 한 번 GitHub 블로그를 공부하고 사용해보기로 했다. C# Study Feat.식빵맘 const와 readonly 키워드 Chap...", "content": "GitHub 본계정이 일시 정지 처분을 받았다..계정 복원이 될 때 까진 프로젝트 진행을 멈추고 C#, 유니티 내장 함수, 디자인 패턴, 알고리즘 공부Velog를 사용하려 했지만, 커스터마이징 기능이 부족해서 다시 한 번 GitHub 블로그를 공부하고 사용해보기로 했다. C# Study Feat.식빵맘 const와 readonly 키워드 Chapter 1-1. 데이터 : 정수 형식, 2진수, 16진수, 정수 범위 Chapter 1-2. 데이터 : 형변환 Chapter 1-3. 데이터 : 비트 연산 Chapter 2-1. 코드의 흐름 제어 : switch, 열거형 Chapter 2-2. 코드의 흐름 제어 : 함수, ref, out Chapter 3. 디버깅 기초 Chapter 4. Text RPG Chapter 5-1. 객체 지향 : 객체 지향, 복사와 참조, 스택과 힙 Chapter 5-2. 객체 지향 : 생성자, static Chapter 5-3. 객체 지향 : 상속성, 은닉성 Chapter 5-4. 객체 지향 : 클래스 형변환(is, as)" }, { "title": "유용한 URL 모음", "url": "/posts/%EC%9C%A0%EC%9A%A9%ED%95%9C-URL-%EB%AA%A8%EC%9D%8C/", "categories": "Tech Tip, URL", "tags": "URL", "date": "2022-08-24 00:00:00 +0900", "snippet": " C# C# - C# online editor, IDE, compiler, interpreter, and REPL C# - 공부하는 식빵맘 C# - 예제로 배우는 C# 프로그래밍 C# - 나무위키 C# - Microsoft Docs UNITY Documentation AR Foundation (v4....", "content": " C# C# - C# online editor, IDE, compiler, interpreter, and REPL C# - 공부하는 식빵맘 C# - 예제로 배우는 C# 프로그래밍 C# - 나무위키 C# - Microsoft Docs UNITY Documentation AR Foundation (v4.2.3) BLOG novlog Dang Hyeona 공부하는 식빵맘 하얀눈길 너랑나랑개발자이야기(유니티 튜토리얼, 강의) YOUTUBE 어소트락 게임아카데미 - C# 무료강의[2019] 총48강 " } ]
